<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Album Cover Mosaic Builder</title>
    <script>
        // Immediately scroll to top when page loads
        if ('scrollRestoration' in history) {
            history.scrollRestoration = 'manual';
        }
        window.scrollTo(0, 0);
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            overflow-x: hidden;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
            background: #FFFBF5;
            min-height: 100vh;
            overflow-x: hidden;
            margin: 0;
            padding: 0;
        }

        html {
            overflow-x: hidden;
        }

        .main-container {
            display: flex;
            min-height: 100vh;
            max-width: 100vw;
            overflow-x: hidden;
            margin: 0 auto;
        }

        /* Left Panel - 3D Viewer */
        .viewer-panel {
            flex: 1;
            min-width: 0;
            background: #FFFBF5;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: #FFF8F0;
            border-right: 1px solid #e0e0e0;
            min-height: 600px; /* ensure visible height when shown */
        }

        #canvas-container canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        /* Inline editor panel that replaces the 3D view initially */
        #editor-panel {
            flex: 1;
            padding: 20px 24px;
            overflow: visible;
            background: #FFFBF5;
            min-width: 0;
            display: flex;
            flex-direction: column;
        }

        .viewer-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .viewer-btn {
            background: #E0E0E0;
            border: 1px solid #333333;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            box-shadow: none;
            font-size: 14px;
            transition: all 0.2s;
            font-weight: normal;
            color: #333333;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .viewer-btn:hover {
            background: #d0d0d0;
        }

        .viewer-btn.icon-only {
            padding: 10px;
            font-size: 18px;
        }

        .placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #333333;
            font-size: 16px;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .placeholder-icon {
            font-size: 80px;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        /* Right Panel - Controls */
        .control-panel {
            flex: 0 0 450px;
            min-width: 450px;
            background: #FFFBF5;
            padding: 40px;
            overflow: visible;
            border-left: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-left: 20px;
            padding-right: 20px;
            margin: 0 auto;
            box-sizing: border-box;
        }

        .title {
            font-size: 32px;
            font-weight: normal;
            margin-bottom: 10px;
            color: #E87D3E;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .price {
            font-size: 20px;
            color: #333333;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e0e0e0;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .section {
            margin-bottom: 30px;
            width: 100%;
        }
        
        /* Reduce spacing for grid size section before action buttons */
        #size-panel {
            margin-bottom: 5px;
        }
        
        /* Reduce spacing for upload panel */
        #upload-panel {
            margin-top: 0;
        }

        .section:not(.collapsible-section) {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .section-label {
            font-size: 13px;
            font-weight: normal;
            color: #FF6B35;
            margin-bottom: 12px;
            text-transform: none;
            letter-spacing: 0;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
            text-align: center;
            width: 100%;
        }

        .upload-area {
            border: 2px dashed #ddd;
            border-radius: 12px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #fafafa;
            margin-bottom: 15px;
        }

        .upload-area:hover {
            border-color: #999;
            background: #f5f5f5;
        }

        .upload-area.has-file {
            border-color: #999;
            background: #f5f5f5;
        }

        .upload-icon {
            font-size: 40px;
            margin-bottom: 10px;
            opacity: 0.5;
        }

        .upload-text {
            font-size: 14px;
            color: #333333;
            margin-bottom: 5px;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .upload-subtext {
            font-size: 12px;
            color: #333333;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .file-input {
            display: none;
        }

        .grid-options {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
            width: 100%;
        }

        .grid-btn {
            flex: 1;
            padding: 12px;
            border: 1px solid #333333;
            background: #E0E0E0;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: normal;
            color: #333333;
            transition: all 0.2s;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
            min-width: 0;
            box-sizing: border-box;
        }

        .grid-btn.active {
            background: #333333;
            color: #FFFFFF;
            border-color: #333333;
        }

        .grid-btn:hover:not(.active) {
            background: #d0d0d0;
        }

        /* Top Action Buttons Bar */
        .top-action-buttons {
            display: flex;
            gap: 0;
            margin: 5px 0;
            justify-content: space-around;
            border-top: 1px solid #e0e0e0;
            border-bottom: 1px solid #e0e0e0;
            padding: 16px 0;
        }

        .top-action-btn {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px 4px;
            border: none;
            background: transparent;
            color: #666666;
            font-size: 12px;
            font-weight: normal;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
            text-align: center;
        }

        .top-action-btn:hover {
            color: #333333;
        }

        .top-action-btn.active {
            color: #333333;
        }

        .top-action-btn .btn-icon {
            font-size: 24px;
            margin-bottom: 6px;
            line-height: 1;
            color: inherit;
        }

        .top-action-btn .btn-text {
            font-size: 12px;
            line-height: 1.2;
            color: inherit;
        }

        /* Collapsible Sections */
        .collapsible-section {
            display: none !important;
        }

        .collapsible-section.active {
            display: flex !important;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .color-palette {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            margin-bottom: 30px;
            padding-bottom: 20px;
            width: 100%;
            justify-content: space-between;
        }

        .color-swatch {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: transform 0.2s;
            position: relative;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .color-swatch.selected {
            border: 3px solid #333333;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #333333;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 30px;
            width: 100%;
        }

        .btn {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid #333333;
            border-radius: 6px;
            font-size: 14px;
            font-weight: normal;
            cursor: pointer;
            transition: all 0.2s;
            background: #E0E0E0;
            color: #333333;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
            width: 100%;
            box-sizing: border-box;
        }

        .btn-primary {
            background: #333333;
            color: #FFFFFF;
            border: 1px solid #333333;
        }

        .btn-primary:hover:not(:disabled) {
            background: #444444;
        }

        .btn-secondary {
            background: #333333;
            color: #FFFFFF;
            border: 1px solid #333333;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #444444;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .status-message {
            margin-top: 20px;
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            display: none;
        }

        .status-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-message.loading {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 3px solid rgba(0,0,0,0.1);
            border-radius: 50%;
            border-top-color: #0c5460;
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .info-box {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            font-size: 13px;
            color: #856404;
        }

        .info-box strong {
            display: block;
            margin-bottom: 5px;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            flex-shrink: 0;
        }

        .panel-title {
            font-size: 24px;
            font-weight: normal;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
            color: #E87D3E;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #999;
        }

        .close-btn:hover {
            color: #333;
        }

        .editor-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 20px;
        }

        .canvas-wrapper {
            text-align: center;
            margin-bottom: 0;
        }

        .canvas-label {
            font-size: 14px;
            font-weight: normal;
            margin-bottom: 10px;
            color: #E87D3E;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .editor-canvas {
            max-width: 100%;
            width: 100%;
            aspect-ratio: 1 / 1;
            height: auto;
            border-radius: 10px;
            border: 2px solid #ddd;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            background: #ffffff !important;
            display: block;
            margin: 0 auto;
            object-fit: contain;
        }

        #png-preview img { background: #ffffff !important; }

        .slider-control {
            margin-bottom: 20px;
            width: 100%;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: normal;
            color: #333333;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: black;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: black;
            cursor: pointer;
            border: none;
        }

        .editor-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            flex-shrink: 0;
            margin-top: auto;
        }

        /* Toggle Switch Styling */
        #stand-toggle + span,
        #addon-mounting-toggle + span {
            background-color: #ccc;
        }

        #stand-toggle:checked + span,
        #addon-mounting-toggle:checked + span {
            background-color: #2d5016;
        }

        #stand-toggle + span:before,
        #addon-mounting-toggle + span:before {
            content: "";
            position: absolute;
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            border-radius: 50%;
            transition: .4s;
        }

        #stand-toggle:checked + span:before,
        #addon-mounting-toggle:checked + span:before {
            content: "";
            position: absolute;
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            border-radius: 50%;
            transition: .4s;
            transform: translateX(20px);
        }

        @media (max-width: 1024px) {
            .main-container {
                flex-direction: column;
                width: 100%;
                margin: 0;
                padding: 0;
            }

            .control-panel {
                width: 100%;
                max-width: 100%;
                padding-left: 20px;
                padding-right: 20px;
                padding-top: 20px;
                padding-bottom: 20px;
                margin: 0;
                min-width: 0;
                flex: 1 1 auto;
                align-items: center;
            }

            #canvas-container {
                height: 400px;
            }

            .editor-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Mobile portrait view - ensure equal padding and centering */
        @media (max-width: 768px) and (orientation: portrait) {
            .control-panel {
                padding-left: 20px;
                padding-right: 20px;
                padding-top: 20px;
                padding-bottom: 20px;
                width: 100%;
                max-width: 100%;
                margin: 0;
                align-items: center;
            }

            .section {
                width: 100%;
                max-width: 100%;
                margin-left: auto;
                margin-right: auto;
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .top-action-buttons {
                width: 100%;
                max-width: 100%;
                margin-left: auto;
                margin-right: auto;
                display: flex;
                justify-content: center;
            }

            .section-label {
                text-align: center;
                width: 100%;
            }
        }

        /* iPhone 12 Pro and similar sizes (390px width) */
        @media (max-width: 428px) {
            .control-panel {
                padding-left: 20px;
                padding-right: 20px;
                padding-top: 20px;
                padding-bottom: 20px;
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                margin: 0;
                align-items: center;
            }

            .section {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                margin-left: auto;
                margin-right: auto;
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .top-action-buttons {
                width: 100%;
                max-width: 100%;
                margin-left: auto;
                margin-right: auto;
                box-sizing: border-box;
                display: flex;
                justify-content: center;
            }

            .grid-options {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                margin-left: auto;
                margin-right: auto;
                display: flex;
                justify-content: center;
            }

            #png-preview {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                margin-left: auto;
                margin-right: auto;
                display: flex;
                justify-content: center;
            }

            #crop-container {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                margin-left: auto;
                margin-right: auto;
            }

            .section-label {
                text-align: center;
                width: 100%;
                margin-left: auto;
                margin-right: auto;
            }
        }

        /* Smaller phones (iPhone SE, etc. - 375px width) */
        @media (max-width: 375px) {
            .control-panel {
                padding-left: 15px;
                padding-right: 15px;
                padding-top: 15px;
                padding-bottom: 15px;
            }
        }

        /* Very small phones (320px width) */
        @media (max-width: 320px) {
            .control-panel {
                padding-left: 10px;
                padding-right: 10px;
                padding-top: 10px;
                padding-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Left Panel: Editor (initial) and 3D Viewer -->
        <div class="viewer-panel">
            <!-- Inline Editor Panel (shown first) -->
            <div id="editor-panel" style="display: none;">
                <div class="panel-header">
                    <h2 class="panel-title" id="mobile-panel-title">Edit Your Photo</h2>
                </div>
                <div style="margin-top:12px;">
                    <div class="canvas-wrapper">
                        <div class="canvas-label" id="mobile-canvas-label">Processed (Posterized)</div>
                        <div style="position: relative; display: inline-block; width: 100%;">
                            <canvas id="processed-canvas" class="editor-canvas" style="max-width:100%; width:100%; aspect-ratio:1/1; cursor: crosshair;"></canvas>
                        </div>
                        <div style="display: flex; flex-direction: row; gap: 5px; justify-content: space-between; align-items: center; margin-top: 10px; margin-bottom: 0; width: 100%;">
                            <div style="display: flex; flex-direction: row; gap: 5px;">
                                <button onclick="zoomInProcessed()" style="padding: 0; margin: 0; font-size: 18px; background: #E0E0E0; border: 1px solid #333333; border-radius: 6px; cursor: pointer; box-shadow: none; color: #333333; width: 40px; height: 40px; min-width: 40px; max-width: 40px; min-height: 40px; max-height: 40px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; box-sizing: border-box;" title="Zoom In">+</button>
                                <button onclick="zoomOutProcessed()" style="padding: 0; margin: 0; font-size: 18px; background: #E0E0E0; border: 1px solid #333333; border-radius: 6px; cursor: pointer; box-shadow: none; color: #333333; width: 40px; height: 40px; min-width: 40px; max-width: 40px; min-height: 40px; max-height: 40px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; box-sizing: border-box;" title="Zoom Out">‚àí</button>
                                <button onclick="resetZoomProcessed()" id="processed-reset-btn" style="padding: 0; margin: 0; font-size: 18px; background: #E0E0E0; border: 1px solid #333333; border-radius: 6px; cursor: pointer; box-shadow: none; color: #333333; width: 40px; height: 40px; min-width: 40px; max-width: 40px; min-height: 40px; max-height: 40px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; box-sizing: border-box;" title="Reset View">‚ñ°</button>
                            </div>
                            <button onclick="show3DView()" style="padding: 12px 16px; margin: 0; font-size: 14px; background: #E0E0E0; border: 1px solid #333333; border-radius: 6px; cursor: pointer; box-shadow: none; color: #333333; white-space: nowrap; flex-shrink: 0; font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace; font-weight: normal;" title="View in 3D">View in 3D</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 3D Viewer (hidden initially) -->
            <div id="canvas-container" style="display:none;">
                <div class="viewer-controls">
                    <button class="viewer-btn" onclick="showEditorPanel()" id="edit-photo-btn">Edit Photo</button>
                    <button class="viewer-btn icon-only" onclick="resetCamera()" title="Reset View">‚Ü∫</button>
                </div>
                <div id="three-placeholder" class="placeholder">
                    <div class="placeholder-icon">‚ñ°</div>
                    <div>Upload an STL file to preview your 3D model</div>
                </div>
            </div>
        </div>

        <!-- Right Panel: Controls -->
        <div class="control-panel">
            <!-- Initial Upload Box (shown before image upload) -->
            <div id="initial-upload-box" style="width: 100%; padding: 40px 20px; background: #fafafa; border: 2px dashed #d0d0d0; border-radius: 8px; margin-bottom: 20px; text-align: center; cursor: pointer; box-sizing: border-box; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 200px;" onclick="document.getElementById('png-input').click()">
                <div style="font-size: 32px; color: #999; margin-bottom: 16px;">‚Üë</div>
                <div style="font-size: 14px; color: #666; font-family: 'Courier New', monospace; margin-bottom: 8px;">Upload an image to convert to brick art</div>
                <div style="font-size: 12px; color: #666; font-family: 'Courier New', monospace;">Will be initially set to 32x32</div>
            </div>
            
            <!-- Upload PNG Section with Cropper (appears above buttons) -->
            <div class="section" id="upload-panel" style="display: none;">
                <div class="section-label" id="mobile-section-upload" style="margin-bottom: 4px;">Uploaded Image</div>
                <div class="upload-area" id="png-upload-area" onclick="document.getElementById('png-input').click()" style="margin-bottom: 0; padding: 8px;">
                    <div class="upload-icon" style="font-size: 20px; margin-bottom: 4px;">üñºÔ∏è</div>
                    <div class="upload-text" id="png-upload-text" style="font-size: 12px; margin-bottom: 2px;">Choose image file...</div>
                    <div class="upload-subtext" id="png-upload-subtext" style="font-size: 10px;">Will be resized to 75√ó75 pixels</div>
                </div>
                
                <!-- Divider line -->
                <div style="width: 100%; height: 1px; background: #e0e0e0; margin: 5px 0 0 0;"></div>
                
                <!-- Crop Buttons - Always visible when image is uploaded -->
                <div id="crop-buttons" style="display: none; margin-top: 15px; text-align: center;">
                    <button class="btn" id="show-cropper-btn" onclick="showCropper()" style="width: 100%; background: #E0E0E0; color: #333333; border: 1px solid #333333;">
                        Show Cropper
                    </button>
                    <button class="btn" id="hide-cropper-btn" onclick="hideCropper()" style="width: 100%; background: #E0E0E0; color: #333333; border: 1px solid #333333; display: none; margin-top: 10px;">
                        Hide Cropper ^
                    </button>
                </div>
                
                <!-- PNG Preview with Crop Tool -->
                <div id="png-preview" style="display: none; text-align: center; margin-top: 15px; width: 100%;">
                    <div id="crop-container" style="position: relative; display: inline-block; max-width: 400px; width: 100%; margin: 0 auto;">
                        <img id="png-preview-img" style="width: 100%; max-width: 400px; height: auto; aspect-ratio: 1/1; object-fit: contain; border-radius: 8px; border: 2px solid #ddd; display: block; margin: 0 auto;" />
                        <canvas id="crop-canvas" style="position: absolute; top: 0; left: 0; pointer-events: auto; display: none; border: none; background: transparent; z-index: 10;"></canvas>
                    </div>
                </div>
            </div>
            
            <!-- Panels (appear above buttons) -->
            <!-- Grid Size (Collapsible) -->
            <div class="section collapsible-section" id="size-panel">
                <div class="section-label" id="mobile-section-grid">2. Select Grid Size</div>
                <div class="grid-options">
                    <button class="grid-btn" data-size="48" id="mobile-grid-btn-48" onclick="selectGridSize(48)">48 √ó 48</button>
                    <button class="grid-btn active" data-size="75" id="mobile-grid-btn-75" onclick="selectGridSize(75)">75 √ó 75</button>
                    <button class="grid-btn" data-size="96" id="mobile-grid-btn-96" onclick="selectGridSize(96)">96 √ó 96</button>
                </div>
            </div>

            <!-- Image Adjustments (Collapsible) -->
            <div class="section collapsible-section" id="adjust-panel">
                <div class="section-label" id="mobile-section-adjustments">Image Adjustments</div>
                <div class="slider-control">
                    <div class="slider-label">
                        <span id="mobile-slider-contrast-label">Contrast</span>
                        <span id="contrast-value">1.2</span>
                    </div>
                    <input type="range" class="slider" id="contrast-slider" min="0" max="3" step="0.1" value="1.2" />
                </div>
                <div class="slider-control">
                    <div class="slider-label">
                        <span id="mobile-slider-brightness-label">Brightness</span>
                        <span id="brightness-value">1.0</span>
                    </div>
                    <input type="range" class="slider" id="brightness-slider" min="0" max="3" step="0.1" value="1.0" />
                </div>
                <div class="slider-control">
                    <div class="slider-label">
                        <span id="mobile-slider-tones-label">Tones</span>
                        <span id="tones-value">4</span>
                    </div>
                    <input type="range" class="slider" id="tones-slider" min="2" max="4" step="1" value="4" />
                </div>
            </div>

            <!-- Painting (Collapsible) -->
            <div class="section collapsible-section" id="paint-panel">
                <div class="section-label" id="mobile-section-painting">Painting</div>
                <div class="color-palette">
                    <div class="color-swatch selected" data-color="0,0,0" style="background: rgb(0,0,0); position: relative;" title="Black" onclick="selectPaintColor(0, 0, 0, this)">
                        <span id="mobile-color-black-title" style="position: absolute; bottom: -20px; left: 50%; transform: translateX(-50%); font-size: 10px; color: #333; white-space: nowrap;">Black</span>
                    </div>
                    <div class="color-swatch" data-color="85,85,85" style="background: rgb(85,85,85); position: relative;" title="Dark Gray" onclick="selectPaintColor(85, 85, 85, this)">
                        <span id="mobile-color-darkgray-title" style="position: absolute; bottom: -20px; left: 50%; transform: translateX(-50%); font-size: 10px; color: #333; white-space: nowrap;">Dark Gray</span>
                    </div>
                    <div class="color-swatch" data-color="170,170,170" style="background: rgb(170,170,170); position: relative;" title="Light Gray" onclick="selectPaintColor(170, 170, 170, this)">
                        <span id="mobile-color-lightgray-title" style="position: absolute; bottom: -20px; left: 50%; transform: translateX(-50%); font-size: 10px; color: #333; white-space: nowrap;">Light Gray</span>
                    </div>
                    <div class="color-swatch" data-color="255,255,255" style="background: rgb(255,255,255); position: relative;" title="White" onclick="selectPaintColor(255, 255, 255, this)">
                        <span id="mobile-color-white-title" style="position: absolute; bottom: -20px; left: 50%; transform: translateX(-50%); font-size: 10px; color: #333; white-space: nowrap;">White</span>
                    </div>
                </div>
                <div class="slider-control" style="margin-top: 15px;">
                    <div class="slider-label">
                        <span>Brush Size</span>
                        <span id="brush-size-value">1</span>
                    </div>
                    <input type="range" class="slider" id="brush-size-slider" min="1" max="10" step="1" value="1" />
                </div>
                <div id="undo-redo-buttons" style="display: none; margin-top: 15px; gap: 10px;" class="action-buttons">
                    <button class="btn" id="undo-btn" onclick="undoPaint()" style="flex: 1; background: #E0E0E0; color: #333333; border: 1px solid #333333;" disabled>‚Üê Undo</button>
                    <button class="btn" id="redo-btn" onclick="redoPaint()" style="flex: 1; background: #E0E0E0; color: #333333; border: 1px solid #333333;" disabled>Redo ‚Üí</button>
                </div>
                <button class="btn" onclick="resetProcessedImage()" style="width: 100%; margin-top: 10px; background: #E0E0E0; color: #333333; border: 1px solid #333333;">
                    Reset Image
                </button>
            </div>
            
            <!-- Top Action Buttons -->
            <div class="top-action-buttons" id="action-buttons-container" style="display: none;">
                <button class="top-action-btn" id="upload-btn" onclick="document.getElementById('png-input').click()">
                    <div class="btn-icon">‚Üë</div>
                    <div class="btn-text">Upload</div>
                </button>
                <button class="top-action-btn" id="size-btn" onclick="togglePanel('size')">
                    <div class="btn-icon">‚ñ°</div>
                    <div class="btn-text">Size</div>
                </button>
                <button class="top-action-btn" id="adjust-btn" onclick="togglePanel('adjust')">
                    <div class="btn-icon">‚ò∞</div>
                    <div class="btn-text">Adjust</div>
                </button>
                <button class="top-action-btn" id="paint-btn" onclick="togglePanel('paint')">
                    <div class="btn-icon">‚úé</div>
                    <div class="btn-text">Paint</div>
                </button>
            </div>
            <input type="file" id="png-input" class="file-input" accept=".png,.jpg,.jpeg,.heic,.heif" />
        </div>

            <!-- Price Display Section -->
            <div class="section" id="price-display-section" style="margin-top: 5px; width: 100%; display: none; padding: 0 20px; box-sizing: border-box;">
                <!-- Price and Details Cards -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px; width: 100%; align-items: stretch;">
                    <!-- Price Card -->
                    <div style="flex: 1; background: #f0f0f0; border-radius: 8px; box-sizing: border-box; display: flex; align-items: center; justify-content: center;">
                        <div id="main-price" style="font-size: 24px; font-weight: 600; color: #333; text-align: center; padding: 16px; width: 100%;">Price loading...</div>
                    </div>
                    <!-- Details Card -->
                    <div style="flex: 1; padding: 16px; background: #f0f0f0; border-radius: 8px; box-sizing: border-box; display: flex; align-items: center;">
                        <div style="font-size: 12px; color: #666; line-height: 1.6; text-align: left;">
                            <div><span id="mobile-label-dimensions">Dimensions:</span> <span id="price-dimensions">75 √ó 75</span></div>
                            <div>Baseplate: <span id="baseplate-type">Framed</span></div>
                        </div>
                    </div>
                </div>
                
                <!-- Add to Cart Button -->
                <button id="add-to-cart-btn" style="width: 100%; padding: 16px; margin-bottom: 20px; background: #2d5016; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer; text-transform: uppercase; box-sizing: border-box;">ADD TO CART</button>
                
                <!-- Stand Toggle -->
                <div id="stand-section" style="margin-bottom: 15px; width: 100%;">
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: #f9f9f9; border-radius: 6px; width: 100%; box-sizing: border-box;">
                        <div style="display: flex; align-items: center; flex: 1;">
                            <img id="stand-image" src="" alt="Stand" style="width: 40px; height: 40px; object-fit: cover; border-radius: 4px; margin-right: 12px; display: none;">
                            <div style="flex: 1;">
                                <div id="mobile-stand-name" style="font-size: 14px; font-weight: 500; color: #333;">Stand</div>
                                <div id="stand-price-display" style="font-size: 12px; color: #666;">$10.00</div>
                            </div>
                        </div>
                        <label style="position: relative; display: inline-block; width: 44px; height: 24px;">
                            <input type="checkbox" id="stand-toggle" style="opacity: 0; width: 0; height: 0;" onchange="updateStandAndPrice()">
                            <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; border-radius: 24px; transition: .4s;"></span>
                        </label>
                    </div>
                </div>
                
                <!-- Add-ons Section -->
                <div id="addons-section" style="width: 100%;">
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: #f9f9f9; border-radius: 6px; width: 100%; box-sizing: border-box;">
                        <div style="display: flex; align-items: center; flex: 1;">
                            <img id="mounting-image" src="" alt="Wall Mounting Dots" style="width: 40px; height: 40px; object-fit: cover; border-radius: 4px; margin-right: 12px; display: none;">
                            <div style="flex: 1;">
                                <div id="mobile-mounting-name" style="font-size: 14px; font-weight: 500; color: #333;">Nano Wall Mounting Dots (Pack of 8)</div>
                                <div id="addon-mounting-price" style="font-size: 12px; color: #666;">$5.99</div>
                            </div>
                        </div>
                        <label style="position: relative; display: inline-block; width: 44px; height: 24px;">
                            <input type="checkbox" id="addon-mounting-toggle" style="opacity: 0; width: 0; height: 0;" onchange="updateTotalPrice()">
                            <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; border-radius: 24px; transition: .4s;"></span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Status Message -->
        <div class="status-message" id="status-message"></div>

        <!-- Info Box -->
        <div class="info-box" style="background: transparent; border: none; padding: 20px; margin: 20px 0; text-align: center; max-width: 100%; box-sizing: border-box;">
            <div id="desktop-info-title" style="font-size: 16px; font-weight: bold; margin-bottom: 15px; color: #333; text-align: center;">Custom Brick Mosaic Designer</div>
            <div id="desktop-info-description" style="font-size: 14px; line-height: 1.6; color: #666; margin-bottom: 15px; text-align: center;">
                Turn your favourite photos into stunning brick art‚Äîmade by you!
            </div>
            <div id="desktop-info-additional" style="font-size: 14px; line-height: 1.6; color: #666; text-align: center;">
                Bring your memories to life, one brick at a time. With our Custom Brick Mosaic Designer you can transform any image into a beautiful 3D printable mosaic.
            </div>
        </div>

        <!-- Directions Section -->
        <div style="padding: 20px; margin-top: 20px; background: transparent;">
            <div id="desktop-howto-title" style="font-size: 18px; font-weight: 600; margin-bottom: 20px; color: #333;">How to Use</div>
            <div id="desktop-howto-content" style="font-size: 14px; line-height: 1.8; color: #666;">
                <div style="margin-bottom: 16px;">
                    <strong style="color: #333; display: block; margin-bottom: 4px;">1. Upload Your Image</strong>
                    Click the "Upload" button and select a photo from your device. The image will be automatically processed.
                </div>
                <div style="margin-bottom: 16px;">
                    <strong style="color: #333; display: block; margin-bottom: 4px;">2. Adjust Size & Crop</strong>
                    Use the "Size" button to crop your image and choose your grid size (48√ó48, 75√ó75, or 96√ó96). Drag the blue crop box to select the area you want to use.
                </div>
                <div style="margin-bottom: 16px;">
                    <strong style="color: #333; display: block; margin-bottom: 4px;">3. Fine-Tune Adjustments</strong>
                    Click "Adjust" to modify brightness, contrast, and other settings to get the perfect look for your mosaic.
                </div>
                <div style="margin-bottom: 16px;">
                    <strong style="color: #333; display: block; margin-bottom: 4px;">4. Paint & Customize (Optional)</strong>
                    Use the "Paint" button to manually adjust individual colors and add your personal touch to the design.
                </div>
                <div style="margin-bottom: 16px;">
                    <strong style="color: #333; display: block; margin-bottom: 4px;">5. View in 3D</strong>
                    Click "View in 3D" to see your custom brick mosaic come to life. Rotate and zoom to explore your creation.
                </div>
                <div>
                    <strong style="color: #333; display: block; margin-bottom: 4px;">6. Proceed to Checkout</strong>
                    Once you're happy with your design, click "Proceed to Checkout" to order your custom brick mosaic.
                </div>
            </div>
        </div>
        </div>
    </div>

    <script>
        // Shopify Configuration - UPDATE THIS WITH YOUR SHOPIFY STORE URL
        const SHOPIFY_PRODUCT_URL = 'https://your-store.myshopify.com/products/3d-album-mosaic'; // UPDATE THIS

        // Price management
        let prices = {};
        let productImages = {};
        let textContent = {};
        let selectedAddons = {
            mounting: false
        };
        let standSelected = false; // Default to stand OFF

        // Load prices from API
        async function loadPrices() {
            try {
                const response = await fetch('/api/prices');
                if (!response.ok) {
                    throw new Error(`Failed to fetch prices: ${response.status}`);
                }
                prices = await response.json();
                console.log('Prices loaded from admin:', prices);
                console.log('Price keys available:', Object.keys(prices));
                
                // Ensure 75√ó75 is selected by default
                selectedGridSize = 75;
                
                await loadImages();
                await loadTextContent();
                
                // Ensure images are displayed after a short delay to ensure DOM is ready
                setTimeout(() => {
                    updateProductImages();
                }, 100);
                
                // Ensure 75√ó75 button is active
                document.querySelectorAll('.grid-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.size === '75') {
                        btn.classList.add('active');
                    }
                });
                
                // Update price display with 75√ó75 price after button is set
                updatePriceDisplay();
                
                // Force update price multiple times to ensure it's correct
                setTimeout(() => {
                    updatePriceDisplay();
                }, 50);
                setTimeout(() => {
                    updatePriceDisplay();
                }, 200);
                setTimeout(() => {
                    updatePriceDisplay();
                }, 500);
            } catch (error) {
                console.error('Failed to load prices:', error);
                // Retry after 1 second
                setTimeout(() => loadPrices(), 1000);
            }
        }

        // Load text content from API
        async function loadTextContent() {
            try {
                // Add cache-busting parameter to ensure fresh content
                const response = await fetch('/api/content?t=' + Date.now());
                textContent = await response.json();
                updateTextContent();
            } catch (error) {
                console.error('Failed to load text content:', error);
            }
        }
        
        // Periodically refresh content to pick up admin changes
        setInterval(() => {
            loadTextContent();
        }, 5000); // Check every 5 seconds

        // Update text content on page
        function updateTextContent() {
            // Upload area text
            if (textContent.upload_image_text) {
                const uploadText = document.getElementById('png-upload-text');
                if (uploadText) uploadText.textContent = textContent.upload_image_text;
            }
            if (textContent.upload_subtext) {
                const uploadSubtext = document.getElementById('png-upload-subtext');
                if (uploadSubtext) uploadSubtext.textContent = textContent.upload_subtext;
            }
            
            // STL files are pre-uploaded, no UI needed
            
            // Info box content (using mobile view text)
            if (textContent.info_title) {
                const titleEl = document.getElementById('desktop-info-title');
                if (titleEl) titleEl.textContent = textContent.info_title;
            }
            if (textContent.info_description) {
                const descEl = document.getElementById('desktop-info-description');
                if (descEl) descEl.textContent = textContent.info_description;
            }
            if (textContent.info_additional) {
                const addEl = document.getElementById('desktop-info-additional');
                if (addEl) addEl.textContent = textContent.info_additional;
            }
            
            // How to Use section
            if (textContent.howto_title) {
                const howtoTitleEl = document.getElementById('desktop-howto-title');
                if (howtoTitleEl) howtoTitleEl.textContent = textContent.howto_title;
            }
            if (textContent.howto_content) {
                const howtoContentEl = document.getElementById('desktop-howto-content');
                if (howtoContentEl) {
                    // Parse the howto_content and format it with the step structure
                    const steps = textContent.howto_content.split('\n\n');
                    let formattedContent = '';
                    steps.forEach((step, index) => {
                        const lines = step.split('\n');
                        const title = lines[0];
                        const description = lines.slice(1).join(' ');
                        formattedContent += `
                            <div style="margin-bottom: 16px;">
                                <strong style="color: #333; display: block; margin-bottom: 4px;">${title}</strong>
                                ${description}
                            </div>
                        `;
                    });
                    howtoContentEl.innerHTML = formattedContent;
                }
            }
            
            // Mobile-specific text elements
            if (textContent.panel_title) {
                const el = document.getElementById('mobile-panel-title');
                if (el) el.textContent = textContent.panel_title;
            }
            if (textContent.canvas_label) {
                const el = document.getElementById('mobile-canvas-label');
                if (el) el.textContent = textContent.canvas_label;
            }
            if (textContent.section_upload) {
                const el = document.getElementById('mobile-section-upload');
                if (el) el.textContent = textContent.section_upload;
            }
            if (textContent.section_grid) {
                const el = document.getElementById('mobile-section-grid');
                if (el) el.textContent = textContent.section_grid;
            }
            if (textContent.section_adjustments) {
                const el = document.getElementById('mobile-section-adjustments');
                if (el) el.textContent = textContent.section_adjustments;
            }
            if (textContent.section_painting) {
                const el = document.getElementById('mobile-section-painting');
                if (el) el.textContent = textContent.section_painting;
            }
            if (textContent.grid_btn_48) {
                const el = document.getElementById('mobile-grid-btn-48');
                if (el) el.textContent = textContent.grid_btn_48;
            }
            if (textContent.grid_btn_75) {
                const el = document.getElementById('mobile-grid-btn-75');
                if (el) el.textContent = textContent.grid_btn_75;
            }
            if (textContent.grid_btn_96) {
                const el = document.getElementById('mobile-grid-btn-96');
                if (el) el.textContent = textContent.grid_btn_96;
            }
            if (textContent.slider_contrast_label) {
                const el = document.getElementById('mobile-slider-contrast-label');
                if (el) el.textContent = textContent.slider_contrast_label;
            }
            if (textContent.slider_brightness_label) {
                const el = document.getElementById('mobile-slider-brightness-label');
                if (el) el.textContent = textContent.slider_brightness_label;
            }
            if (textContent.slider_tones_label) {
                const el = document.getElementById('mobile-slider-tones-label');
                if (el) el.textContent = textContent.slider_tones_label;
            }
            if (textContent.label_dimensions) {
                const el = document.getElementById('mobile-label-dimensions');
                if (el) el.textContent = textContent.label_dimensions;
            }
            if (textContent.stand_name) {
                const el = document.getElementById('mobile-stand-name');
                if (el) el.textContent = textContent.stand_name;
            }
            if (textContent.mounting_name) {
                const el = document.getElementById('mobile-mounting-name');
                if (el) el.textContent = textContent.mounting_name;
            }
            if (textContent.color_black_title) {
                const el = document.getElementById('mobile-color-black-title');
                if (el) el.textContent = textContent.color_black_title;
            }
            if (textContent.color_darkgray_title) {
                const el = document.getElementById('mobile-color-darkgray-title');
                if (el) el.textContent = textContent.color_darkgray_title;
            }
            if (textContent.color_lightgray_title) {
                const el = document.getElementById('mobile-color-lightgray-title');
                if (el) el.textContent = textContent.color_lightgray_title;
            }
            if (textContent.color_white_title) {
                const el = document.getElementById('mobile-color-white-title');
                if (el) el.textContent = textContent.color_white_title;
            }
        }

        // Load product images from API
        async function loadImages() {
            try {
                // Add cache-busting parameter to force reload
                const response = await fetch('/api/images?t=' + Date.now());
                const images = await response.json();
                console.log('Loaded images from server:', images);
                productImages = images;
                updateProductImages();
            } catch (error) {
                console.error('Failed to load images:', error);
            }
        }

        // Update product images display
        function updateProductImages() {
            console.log('Updating product images:', productImages);
            
            // Stand image
            const standImage = document.getElementById('stand-image');
            if (standImage) {
                if (productImages.stand) {
                    // Add cache-busting parameter to image URL
                    const imageUrl = productImages.stand + (productImages.stand.includes('?') ? '&' : '?') + 't=' + Date.now();
                    standImage.src = imageUrl;
                    standImage.style.display = 'block';
                    standImage.onerror = function() {
                        console.error('Failed to load stand image:', imageUrl);
                        standImage.style.display = 'none';
                    };
                    standImage.onload = function() {
                        console.log('Stand image loaded successfully:', imageUrl);
                    };
                } else {
                    console.log('No stand image in productImages');
                    standImage.style.display = 'none';
                }
            }
            
            // Mounting dots image
            const mountingImage = document.getElementById('mounting-image');
            if (mountingImage) {
                if (productImages.wall_mounting_dots) {
                    // Add cache-busting parameter to image URL
                    const imageUrl = productImages.wall_mounting_dots + (productImages.wall_mounting_dots.includes('?') ? '&' : '?') + 't=' + Date.now();
                    mountingImage.src = imageUrl;
                    mountingImage.style.display = 'block';
                    mountingImage.onerror = function() {
                        console.error('Failed to load mounting image:', imageUrl);
                        mountingImage.style.display = 'none';
                    };
                    mountingImage.onload = function() {
                        console.log('Mounting image loaded successfully:', imageUrl);
                    };
                } else {
                    console.log('No wall_mounting_dots image in productImages');
                    mountingImage.style.display = 'none';
                }
            }
        }

        // Update price display based on selected grid size, stand, and addons
        async function updatePriceDisplay() {
            // Reload prices from admin API to ensure they're up-to-date
            try {
                const response = await fetch('/api/prices');
                if (response.ok) {
                    const freshPrices = await response.json();
                    // Only update if prices have changed
                    if (JSON.stringify(freshPrices) !== JSON.stringify(prices)) {
                        prices = freshPrices;
                        console.log('Prices refreshed from admin:', prices);
                        // Also reload images when prices are refreshed
                        await loadImages();
                    }
                }
            } catch (error) {
                console.error('Failed to refresh prices:', error);
                // Continue with cached prices if refresh fails
            }
            
            // Use 75√ó75 as default if no grid size is selected
            const gridSize = selectedGridSize || 75;
            const priceKey = `${gridSize}x${gridSize}`;
            
            // Get base price for the selected grid size (defaults to 75√ó75)
            // Try multiple key formats in case admin uses different format
            let basePrice = 0;
            if (prices) {
                // Try exact key first
                if (prices[priceKey] !== undefined && prices[priceKey] !== null) {
                    basePrice = parseFloat(prices[priceKey]) || 0;
                } 
                // Try 75x75 as fallback
                else if (prices['75x75'] !== undefined && prices['75x75'] !== null) {
                    basePrice = parseFloat(prices['75x75']) || 0;
                    console.log(`Price for ${priceKey} not found, using 75x75 price: $${basePrice}`);
                }
                // Try other possible formats
                else if (prices['75√ó75'] !== undefined && prices['75√ó75'] !== null) {
                    basePrice = parseFloat(prices['75√ó75']) || 0;
                }
                else {
                    console.warn('Prices loaded but grid size price not found. Grid size:', gridSize, 'Price key:', priceKey);
                    console.warn('Available price keys:', Object.keys(prices));
                    console.warn('Full prices object:', prices);
                }
            }
            
            // Calculate total with stand and addons
            let total = basePrice;
            
            // Add stand price if selected
            if (standSelected && prices && prices.stand !== undefined) {
                const standPrice = parseFloat(prices.stand) || 0;
                total += standPrice;
            }
            
            // Add addons (nano mounting dots)
            if (selectedAddons.mounting && prices && prices.wall_mounting_dots !== undefined) {
                const mountingPrice = parseFloat(prices.wall_mounting_dots) || 0;
                total += mountingPrice;
            }
            
            // Update main price
            const mainPriceEl = document.getElementById('main-price');
            if (mainPriceEl) {
                // Simple check: if prices object exists, show the price
                if (prices && typeof prices === 'object') {
                    // Always show the calculated price
                    mainPriceEl.textContent = `$${total.toFixed(2)}`;
                } else {
                    // Prices not loaded yet
                    mainPriceEl.textContent = 'Price loading...';
                }
            }
            
            // Update dimensions
            const dimensionsEl = document.getElementById('price-dimensions');
            
            if (dimensionsEl) {
                dimensionsEl.textContent = `${gridSize} √ó ${gridSize}`;
            }
            
            // Update stand price display
            const standPriceEl = document.getElementById('stand-price-display');
            if (standPriceEl) {
                const standPrice = prices.stand || 0;
                standPriceEl.textContent = `$${standPrice.toFixed(2)}`;
            }
            
            // Update addons breakdown
            updateOrderBreakdown();
            
            // Update addon prices
            const mountingPriceEl = document.getElementById('addon-mounting-price');
            if (mountingPriceEl && prices.wall_mounting_dots !== undefined) {
                mountingPriceEl.textContent = `$${prices.wall_mounting_dots.toFixed(2)}`;
            }
        }

        // Update stand selection and total price
        function updateStandAndPrice() {
            const standToggle = document.getElementById('stand-toggle');
            standSelected = standToggle ? standToggle.checked : false;
            updatePriceDisplay();
            // Also ensure images are displayed
            updateProductImages();
        }

        // Update total price when addons change
        function updateTotalPrice() {
            const mountingToggle = document.getElementById('addon-mounting-toggle');
            
            selectedAddons.mounting = mountingToggle ? mountingToggle.checked : false;
            
            updatePriceDisplay();
            // Also ensure images are displayed
            updateProductImages();
        }

        // Update order breakdown display
        function updateOrderBreakdown() {
            const breakdownAddons = document.getElementById('breakdown-addons');
            
            if (breakdownAddons) {
                const addons = [];
                if (standSelected) {
                    addons.push('Stand');
                }
                if (selectedAddons.mounting) {
                    addons.push('Nano');
                }
                
                if (addons.length > 0) {
                    breakdownAddons.textContent = addons.join(', ');
                } else {
                    breakdownAddons.textContent = 'None';
                }
            }
        }

        let stlFile = null;
        let pngFile = null;
        let pngImage = null;
        let scene, camera, renderer, controls, currentMesh;
        let originalGeometry = null;
        let selectedGridSize = 75;
        let rawUploadedImage = null;
        let editorSettings = {
            contrast: 1.2,
            brightness: 1.0,
            pixelSize: 75,
            tones: 4,
            blackPoint: 0,
            whitePoint: 255
        };
        // Crop variables
        let cropperVisible = false;
        let cropperManuallyHidden = false; // Track if user manually hid the cropper
        let cropX = 0, cropY = 0, cropSize = 0;
        let cropInitialized = false; // Track if crop has ever been initialized
        let isDraggingCrop = false;
        let isResizingCrop = false;
        let resizeEdge = ''; // 'left', 'right', 'top', 'bottom', 'topleft', 'topright', 'bottomleft', 'bottomright'
        let dragStartX = 0, dragStartY = 0;
        let cropStartX = 0, cropStartY = 0, cropStartSize = 0;
        // Cropper zoom/pan variables
        let cropperZoom = 1.0;
        let cropperPanX = 0;
        let cropperPanY = 0;
        let isPanningCropper = false;
        let panStartX = 0, panStartY = 0;
        
        // Paint variables
        let selectedPaintColor = { r: 0, g: 0, b: 0 }; // Default to black
        let brushSize = 1; // Brush size in pixels (1 = single pixel, larger = area)
        let processedImageData = null; // Store the processed image data for pixel editing
        let originalProcessedImageData = null; // Store the original processed image data (before painting)
        let undoStack = []; // Stack for undo history
        let redoStack = []; // Stack for redo history
        let lastPaintState = null; // Store state before current paint stroke starts
        let processedZoom = 1.0; // Zoom level for processed canvas
        let processedZoomOffsetX = 0;
        let processedZoomOffsetY = 0;
        let isPanningProcessed = false;
        let processedPanStartX = 0, processedPanStartY = 0;
        let zoomMode = null; // 'zoom-in', 'zoom-out', or null
        let fullOriginalImage = null; // Store the full original uncropped image
        let cropCoordinates = null; // Store crop coordinates {x, y, size} for processing
        let fullProcessedImageDataURL = null; // Store the full processed image snapshot for cropper preview

        const pixelSizes = [48, 75, 96];

        // IndexedDB persistence for files
        let dbPromise = null;
        function openDB() {
            if (dbPromise) return dbPromise;
            dbPromise = new Promise((resolve, reject) => {
                const req = indexedDB.open('albumCoverDB', 1);
                req.onupgradeneeded = () => {
                    const db = req.result;
                    if (!db.objectStoreNames.contains('files')) {
                        db.createObjectStore('files');
                    }
                };
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
            return dbPromise;
        }

        // Key helper for per-size storage
        function dbKey(type, size = selectedGridSize) {
            return `${type}_${size}`;
        }

        async function saveFileToDB(key, file) {
            try {
                const db = await openDB();
                await new Promise((resolve, reject) => {
                    const tx = db.transaction('files', 'readwrite');
                    const store = tx.objectStore('files');
                    const value = { name: file.name, type: file.type, blob: file };
                    const req = store.put(value, key);
                    req.onsuccess = () => resolve();
                    req.onerror = () => reject(req.error);
                });
            } catch (e) {
                console.warn('Failed to save file to IndexedDB', e);
            }
        }

        async function loadFileFromDB(key) {
            try {
                const db = await openDB();
                return await new Promise((resolve, reject) => {
                    const tx = db.transaction('files', 'readonly');
                    const store = tx.objectStore('files');
                    const req = store.get(key);
                    req.onsuccess = () => resolve(req.result || null);
                    req.onerror = () => reject(req.error);
                });
            } catch (e) {
                console.warn('Failed to load file from IndexedDB', e);
                return null;
            }
        }

        // Persist simple state in localStorage
        function saveSimpleState() {
            localStorage.setItem('selectedGridSize', String(selectedGridSize));
            localStorage.setItem('editorSettings', JSON.stringify(editorSettings));
        }

        function loadSimpleState() {
            const sizeStr = localStorage.getItem('selectedGridSize');
            if (sizeStr) {
                const s = parseInt(sizeStr);
                if ([32,48,75,96].includes(s)) {
                    selectedGridSize = s;
                }
            }
            const es = localStorage.getItem('editorSettings');
            if (es) {
                try {
                    const parsed = JSON.parse(es);
                    editorSettings = { ...editorSettings, ...parsed };
                } catch {}
            }
        }

        async function restoreForSize(size) {
            // PNG
            const pngEntry = await loadFileFromDB(dbKey('png', size));
            if (pngEntry && pngEntry.blob) {
                const restoredPNG = new File([pngEntry.blob], pngEntry.name || 'image.png', { type: pngEntry.type || 'image/png' });
                pngFile = restoredPNG;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.onload = () => {
                        rawUploadedImage = img;
                        fullOriginalImage = img; // Store full original uncropped image
                        cropCoordinates = null; // Reset crop coordinates when restoring image
                        pngImage = img;
                        
                        // Reset cropper state when restoring image
                        fullProcessedImageDataURL = null;
                        cropperVisible = false;
                        cropperManuallyHidden = false; // Reset flag when restoring
                        cropInitialized = false;
                        const previewImg = document.getElementById('png-preview-img');
                        if (previewImg) {
                            previewImg.removeAttribute('data-cropper-fixed');
                        }
                        document.getElementById('png-preview').style.display = 'none';
                        document.getElementById('crop-canvas').style.display = 'none';
                        document.getElementById('show-cropper-btn').style.display = 'block';
                        document.getElementById('hide-cropper-btn').style.display = 'none';
                        
                        // Auto-tune per restored image
                        autoTuneSettingsFromImage(img);
                        document.getElementById('contrast-slider').value = String(editorSettings.contrast);
                        document.getElementById('brightness-slider').value = String(editorSettings.brightness);
                        document.getElementById('contrast-value').textContent = editorSettings.contrast.toFixed(1);
                        document.getElementById('brightness-value').textContent = editorSettings.brightness.toFixed(1);
                        // Don't set preview image here - it will be set to processed version after processImage() runs
                        // document.getElementById('png-preview-img').src = ev.target.result;
                        // Show crop buttons when image is restored
                        document.getElementById('crop-buttons').style.display = 'block';
                        // Don't show preview automatically - only show when "Show Cropper" is clicked
                        // document.getElementById('png-preview').style.display = 'block';
                        document.getElementById('png-upload-area').classList.add('has-file');
                        document.getElementById('png-upload-text').textContent = restoredPNG.name;
                        if (currentMesh) applyColorsToMesh();
                        processImage();
                        // Automatically show cropper after image is processed (with small delay to ensure processed canvas is ready)
                        // Only auto-show if user hasn't manually hidden it
                        if (!cropperManuallyHidden) {
                            setTimeout(() => {
                                showCropper();
                            }, 100);
                        }
                    };
                    img.src = ev.target.result;
                };
                reader.readAsDataURL(restoredPNG);
            } else {
                // Clear preview if no PNG for this size
                document.getElementById('png-preview').style.display = 'none';
                document.getElementById('crop-buttons').style.display = 'none';
                document.getElementById('png-upload-area').classList.remove('has-file');
                document.getElementById('png-upload-text').textContent = 'Choose image file...';
                pngFile = null;
            }

            // STL - Try to restore from IndexedDB first, then fall back to server
                const stlEntry = await loadFileFromDB(dbKey('stl', size));
                if (stlEntry && stlEntry.blob) {
                    const restoredSTL = new File([stlEntry.blob], stlEntry.name || `${size}x${size}_grid.stl`, { type: stlEntry.type || 'application/octet-stream' });
                    stlFile = restoredSTL;
                    await loadSTL(restoredSTL);
                    console.log(`‚úÖ Restored STL for ${size}√ó${size} grid from cache`);
                } else {
                    // No STL in IndexedDB, load from server
                    await loadSTLFromServer(size);
                }
        }

        // Helper function to create processed image at a specific size
        function createProcessedImageAtSize(image, targetSize, callback) {
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = targetSize;
            finalCanvas.height = targetSize;
            const finalCtx = finalCanvas.getContext('2d');

            // If crop coordinates exist, crop from the full original image first
            let imageToProcess = image;
            if (cropCoordinates && cropCoordinates.size > 0) {
                // Create cropped version from full original
                const cropCanvas = document.createElement('canvas');
                cropCanvas.width = cropCoordinates.size;
                cropCanvas.height = cropCoordinates.size;
                const cropCtx = cropCanvas.getContext('2d');
                cropCtx.drawImage(image, cropCoordinates.x, cropCoordinates.y, cropCoordinates.size, cropCoordinates.size, 0, 0, cropCoordinates.size, cropCoordinates.size);
                imageToProcess = cropCanvas;
            }

            // Draw and process (cropped image if crop exists, otherwise full image)
            finalCtx.drawImage(imageToProcess, 0, 0, targetSize, targetSize);
            const imageData = finalCtx.getImageData(0, 0, targetSize, targetSize);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                let gray = 0.299 * r + 0.587 * g + 0.114 * b;

                const bp = editorSettings.blackPoint ?? 0;
                const wp = editorSettings.whitePoint ?? 255;
                gray = (gray - bp) * 255 / Math.max(1, (wp - bp));

                gray = ((gray / 255 - 0.5) * editorSettings.contrast + 0.5) * 255;
                gray = gray * editorSettings.brightness;
                gray = Math.max(0, Math.min(255, gray));

                const base = [0,85,170,255];
                const n = Math.max(2, Math.min(4, editorSettings.tones|0));
                const indices = [];
                for (let k = 0; k < n; k++) {
                    const idx = Math.round((k*(base.length-1))/(n-1));
                    indices.push(base[idx]);
                }
                let finalColor = indices[indices.length-1];
                for (let t = 0; t < indices.length-1; t++) {
                    const mid = (indices[t] + indices[t+1]) / 2;
                    if (gray < mid) { finalColor = indices[t]; break; }
                }

                data[i] = finalColor;
                data[i + 1] = finalColor;
                data[i + 2] = finalColor;
            }

            finalCtx.putImageData(imageData, 0, 0);

            // Convert to image
            finalCanvas.toBlob((blob) => {
                const processedFile = new File([blob], 'processed.png', { type: 'image/png' });
                const img = new Image();
                img.onload = () => {
                    if (callback) callback(processedFile, img);
                };
                img.src = URL.createObjectURL(blob);
            });
        }

        // Handle grid size selection
        // Panel Toggle Function
        function togglePanel(panelName) {
            // Hide all panels
            document.getElementById('adjust-panel').classList.remove('active');
            document.getElementById('size-panel').classList.remove('active');
            document.getElementById('paint-panel').classList.remove('active');
            
            // Remove active class from all buttons
            document.getElementById('adjust-btn').classList.remove('active');
            document.getElementById('size-btn').classList.remove('active');
            document.getElementById('paint-btn').classList.remove('active');
            
            // Hide cropper when switching away from size panel
            if (panelName !== 'size') {
                hideCropper();
            }
            
            // Show selected panel and activate button (always show, no toggle)
            const panel = document.getElementById(panelName + '-panel');
            const btn = document.getElementById(panelName + '-btn');
            
            if (panel && btn) {
                // Always show the selected panel
                panel.classList.add('active');
                btn.classList.add('active');
                
                // If showing size panel and image is uploaded, show cropper
                if (panelName === 'size') {
                    // Small delay to ensure panel is visible first
                    setTimeout(() => {
                        if (rawUploadedImage) {
                            // Make sure upload panel is visible for cropper
                            const uploadPanel = document.getElementById('upload-panel');
                            if (uploadPanel) {
                                uploadPanel.style.display = 'block';
                                // Hide upload area and label, keep only cropper visible
                                const uploadArea = document.getElementById('png-upload-area');
                                const sectionLabel = uploadPanel.querySelector('.section-label');
                                if (uploadArea) uploadArea.style.display = 'none';
                                if (sectionLabel) sectionLabel.style.display = 'none';
                                // Show crop buttons
                                const cropButtons = document.getElementById('crop-buttons');
                                if (cropButtons) {
                                    cropButtons.style.display = 'block';
                                }
                            }
                            showCropper();
                        }
                    }, 100);
                }
            }
        }

        async function selectGridSize(size) {
            selectedGridSize = size;
            saveSimpleState();
            
            // Update button states
            document.querySelectorAll('.grid-btn').forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.dataset.size) === size) {
                    btn.classList.add('active');
                }
            });
            
            // Update text to show selected grid size
            const pngSubtext = document.getElementById('png-upload-subtext');
            if (pngSubtext) {
                pngSubtext.textContent = `Will be resized to ${size}√ó${size} pixels`;
            }
            
            // Update price display
            updatePriceDisplay();
            
            console.log(`Grid size selected: ${size}√ó${size}`);

            // Clear current STL to allow restore
            stlFile = null;

            // If there's a current image loaded, reprocess it with the new size
            // Otherwise, restore saved files for this size
            if (rawUploadedImage) {
                // Reprocess current image with new grid size
                processImage(); // Update preview canvas
                // Also create new processed image for 3D view
                createProcessedImageAtSize(rawUploadedImage, size, (file, img) => {
                    pngFile = file;
                    pngImage = img;
                    // Save to IndexedDB for this size
                    saveFileToDB(dbKey('png', size), file);
                    // Apply colors to 3D mesh if loaded
                    if (currentMesh) {
                        applyColorsToMesh();
                    }
                });
                
                // Load STL for this size (from IndexedDB cache or admin server)
                const stlEntry = await loadFileFromDB(dbKey('stl', size));
                if (stlEntry && stlEntry.blob) {
                    const restoredSTL = new File([stlEntry.blob], stlEntry.name || `${size}x${size}_grid.stl`, { type: stlEntry.type || 'application/octet-stream' });
                    stlFile = restoredSTL;
                    await loadSTL(restoredSTL);
                    console.log(`‚úÖ Restored STL for ${size}√ó${size} grid from cache`);
                } else {
                    // No cached STL, load from admin server
                    console.log(`üîÑ Loading STL for ${size}√ó${size} grid from admin...`);
                    await loadSTLFromServer(size);
                }
            } else if (pngFile) {
                // If we have a processed PNG file, reload the original if possible
                // Otherwise, just restore saved files for this size
                await restoreForSize(size);
                // Also load STL for this size
                await loadSTLFromServer(size);
            } else {
                // No current image, restore saved PNG for this size
                await restoreForSize(size);
                // Also load STL for this size
                await loadSTLFromServer(size);
            }
        }

        // Photo Editor Functions
        function showEditorPanel() {
            document.getElementById('editor-panel').style.display = 'block';
            document.getElementById('canvas-container').style.display = 'none';
            if (rawUploadedImage) {
                // If we have painted image data, just redraw it instead of reprocessing
                if (processedImageData && processedImageData.width === selectedGridSize && processedImageData.height === selectedGridSize) {
                    redrawProcessedCanvas();
                } else {
                    // No painted data, process from scratch
                    processImage();
                }
            }
        }

        async function show3DView() {
            // Always ensure STL is loaded before showing 3D view
            if (!stlFile || !currentMesh) {
                console.log('üì¶ Loading STL before showing 3D view...');
                try {
                    await loadSTLFromServer(selectedGridSize);
                } catch (error) {
                    console.error('‚ùå Failed to load STL:', error);
                    const placeholder = document.getElementById('three-placeholder');
                    if (placeholder) {
                        placeholder.style.display = 'block';
                        placeholder.querySelector('div:last-child').textContent = `STL file not found for ${selectedGridSize}√ó${selectedGridSize} grid. Please upload via admin.`;
                    }
                    return;
                }
            }
            
            // If still no mesh after loading, show error
            if (!currentMesh) {
                console.error('‚ùå Failed to load STL mesh. Cannot show 3D view.');
                const placeholder = document.getElementById('three-placeholder');
                if (placeholder) {
                    placeholder.style.display = 'block';
                    placeholder.querySelector('div:last-child').textContent = `STL file not found for ${selectedGridSize}√ó${selectedGridSize} grid. Please upload via admin.`;
                }
                return;
            }
            
            // Hide placeholder before showing 3D view (mesh is loaded)
            const placeholder = document.getElementById('three-placeholder');
            if (placeholder) {
                placeholder.style.display = 'none';
            }
            
            // Regenerate PNG with current crop settings before showing 3D view
            // If there's painted image data, use that instead of regenerating from scratch
            if (rawUploadedImage && currentMesh) {
                if (processedImageData && processedImageData.width === selectedGridSize) {
                    // Use painted image data if available
                    const paintedCanvas = document.createElement('canvas');
                    paintedCanvas.width = selectedGridSize;
                    paintedCanvas.height = selectedGridSize;
                    const paintedCtx = paintedCanvas.getContext('2d');
                    paintedCtx.putImageData(processedImageData, 0, 0);
                    
                    // Convert to blob and image
                    paintedCanvas.toBlob((blob) => {
                        const paintedFile = new File([blob], 'painted.png', { type: 'image/png' });
                        const img = new Image();
                        img.onload = () => {
                            pngFile = paintedFile;
                            pngImage = img;
                            // Apply colors to 3D mesh with painted image
                            applyColorsToMesh();
                        };
                        img.src = URL.createObjectURL(blob);
                    });
                } else {
                    // Create processed image at current grid size with current crop
                    createProcessedImageAtSize(rawUploadedImage, selectedGridSize, (file, img) => {
                        pngFile = file;
                        pngImage = img;
                        // Apply colors to 3D mesh with cropped image
                        applyColorsToMesh();
                    });
                }
            }
            
            // Ensure Three.js is initialized before showing 3D view
            if (!scene || !camera || !renderer) {
                console.log('‚ö†Ô∏è Three.js not initialized, initializing now...');
                initThree();
            }
            
            document.getElementById('editor-panel').style.display = 'none';
            document.getElementById('canvas-container').style.display = 'block';
            
            // Ensure Three.js canvas resizes correctly after becoming visible (wait a frame)
            requestAnimationFrame(() => {
                try {
                    const container = document.getElementById('canvas-container');
                    if (!container) {
                        console.error('‚ùå canvas-container not found');
                        return;
                    }
                    
                    let w = container.clientWidth || container.offsetWidth;
                    let h = container.clientHeight || container.offsetHeight;
                    if (!w || !h) {
                        w = window.innerWidth;
                        h = window.innerHeight;
                    }
                    
                    // Ensure renderer exists and is attached
                    if (!renderer) {
                        console.error('‚ùå Renderer not initialized');
                        initThree();
                        return;
                    }
                    
                    // Ensure renderer DOM is attached to container
                    if (renderer.domElement && renderer.domElement.parentNode !== container) {
                        container.appendChild(renderer.domElement);
                    }
                    
                    if (camera) {
                        renderer.setSize(w, h, true);
                        camera.aspect = w / h;
                        camera.updateProjectionMatrix();
                    }
                    
                    // Fit camera to current mesh if available
                    if (currentMesh && camera && controls) {
                        const box = new THREE.Box3().setFromObject(currentMesh);
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z) || 100;
                        camera.position.set(maxDim, maxDim, maxDim);
                        controls.target.set(0, 0, 0);
                        controls.update();
                    }
                    
                    // Render once immediately after resize
                    if (renderer && scene && camera) {
                        renderer.render(scene, camera);
                    }
                } catch (e) {
                    console.error('‚ùå Resize after showing 3D view failed:', e);
                }
            });
        }

        function processImage() {
            if (!rawUploadedImage) return;

            const processedCanvas = document.getElementById('processed-canvas');
            const processedCtx = processedCanvas.getContext('2d');

            // Set canvas sizes - use container width for full display
            const container = document.getElementById('editor-panel');
            const containerWidth = Math.max(200, container.clientWidth - 48); // padding
            // Use container width to ensure full image is visible
            const side = containerWidth;
            // Set canvas internal resolution (for drawing)
            processedCanvas.width = side;
            processedCanvas.height = side;
            // Set CSS display size to match container width with 1:1 aspect ratio
            processedCanvas.style.width = '100%';
            processedCanvas.style.height = 'auto';
            processedCanvas.style.maxWidth = '100%';
            processedCanvas.style.aspectRatio = '1 / 1';
            processedCanvas.style.display = 'block';

            // Process: Convert to grayscale with luminosity + posterize + pixelate
            const pixelSize = selectedGridSize;
            
            // Create temp canvas at target pixel size
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = pixelSize;
            tempCanvas.height = pixelSize;
            const tempCtx = tempCanvas.getContext('2d');
            
            // If crop coordinates exist, crop from the full original image first
            if (cropCoordinates && cropCoordinates.size > 0) {
                // Create cropped version from full original
                const cropCanvas = document.createElement('canvas');
                cropCanvas.width = cropCoordinates.size;
                cropCanvas.height = cropCoordinates.size;
                const cropCtx = cropCanvas.getContext('2d');
                cropCtx.drawImage(rawUploadedImage, cropCoordinates.x, cropCoordinates.y, cropCoordinates.size, cropCoordinates.size, 0, 0, cropCoordinates.size, cropCoordinates.size);
                
                // Draw cropped image at small size (pixelation effect)
                tempCtx.drawImage(cropCanvas, 0, 0, pixelSize, pixelSize);
            } else {
                // No crop - draw full image at small size (pixelation effect)
                tempCtx.drawImage(rawUploadedImage, 0, 0, pixelSize, pixelSize);
            }
            
            // Get image data
            const imageData = tempCtx.getImageData(0, 0, pixelSize, pixelSize);
            const data = imageData.data;

            // Process each pixel: grayscale + percentile stretch + contrast/brightness + N-tone posterize
            for (let i = 0; i < data.length; i += 4) {
                // Convert to grayscale using luminosity method (perceputal brightness)
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                let gray = 0.299 * r + 0.587 * g + 0.114 * b;

                // Percentile stretch using black/white points
                const bp = editorSettings.blackPoint ?? 0;
                const wp = editorSettings.whitePoint ?? 255;
                gray = (gray - bp) * 255 / Math.max(1, (wp - bp));

                // Apply contrast and brightness
                gray = ((gray / 255 - 0.5) * editorSettings.contrast + 0.5) * 255;
                gray = gray * editorSettings.brightness;
                gray = Math.max(0, Math.min(255, gray));

                // Posterize to N tones based on brightness using base palette [0,85,170,255]
                const base = [0,85,170,255];
                const n = Math.max(2, Math.min(4, editorSettings.tones|0));
                const indices = [];
                for (let k = 0; k < n; k++) {
                    const idx = Math.round((k*(base.length-1))/(n-1));
                    indices.push(base[idx]);
                }
                // thresholds midpoints
                let finalColor = indices[indices.length-1];
                for (let t = 0; t < indices.length-1; t++) {
                    const mid = (indices[t] + indices[t+1]) / 2;
                    if (gray < mid) { finalColor = indices[t]; break; }
                }

                data[i] = finalColor;
                data[i + 1] = finalColor;
                data[i + 2] = finalColor;
            }

            tempCtx.putImageData(imageData, 0, 0);

            // Store the processed image data for pixel editing (at pixel size, not display size)
            const imageDataCopy = tempCtx.getImageData(0, 0, pixelSize, pixelSize);
            processedImageData = imageDataCopy;
            
            // Store a deep copy as the original (for reset functionality)
            originalProcessedImageData = new ImageData(
                new Uint8ClampedArray(imageDataCopy.data),
                imageDataCopy.width,
                imageDataCopy.height
            );

            // Draw pixelated result to processed canvas (scaled up)
            processedCtx.imageSmoothingEnabled = false;
            processedCtx.drawImage(tempCanvas, 0, 0, processedCanvas.width, processedCanvas.height);
            
            // Create a preview version at preview size for general use
            const previewCanvas = document.createElement('canvas');
            const previewMaxSize = 400;
            previewCanvas.width = previewMaxSize;
            previewCanvas.height = previewMaxSize;
            const previewCtx = previewCanvas.getContext('2d');
            previewCtx.imageSmoothingEnabled = false;
            previewCtx.drawImage(tempCanvas, 0, 0, previewMaxSize, previewMaxSize);
            const previewDataURL = previewCanvas.toDataURL();
            
            // IMPORTANT: Only store the full processed preview if cropper is NOT visible
            // Once cropper is visible, this snapshot is FROZEN and must never change
            // This is exclusively for the cropper preview - completely separate from editor updates
            if (!cropperVisible) {
                // Only update when cropper is not visible - this way it captures the full image before cropping
                fullProcessedImageDataURL = previewDataURL;
            }
            // If cropper IS visible, DO NOT overwrite fullProcessedImageDataURL - keep it frozen
            
            // Update preview image to show same processed result (scaled up to match preview size)
            // BUT NEVER update if cropper is visible/fixed - the cropper preview must stay unchanged
            // IMPORTANT: Check cropperVisible FIRST to prevent any updates while cropping
            const previewImg = document.getElementById('png-preview-img');
            const isCropperFixed = previewImg && previewImg.getAttribute('data-cropper-fixed') === 'true';
            // Only update if cropper is NOT visible AND preview is NOT fixed
            if (previewImg && rawUploadedImage && !cropperVisible && !isCropperFixed) {
                previewImg.src = previewDataURL;
            }
            // If cropper is visible, NEVER update the preview - it must stay frozen
            
            // Re-attach paint handlers after processing
            setTimeout(() => {
                setupPaintHandlers();
            }, 100);
        }

        function applyPhotoEdits() {
            // Create the processed image at the selected pixel size
            const pixelSize = selectedGridSize; // Use selectedGridSize
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = pixelSize;
            finalCanvas.height = pixelSize;
            const finalCtx = finalCanvas.getContext('2d');

            // Use painted image data if available, otherwise process from scratch
            let imageData;
            if (processedImageData && processedImageData.width === pixelSize && processedImageData.height === pixelSize) {
                // Use the painted image data (preserve paintings)
                imageData = new ImageData(
                    new Uint8ClampedArray(processedImageData.data),
                    processedImageData.width,
                    processedImageData.height
                );
            } else {
                // Draw and process from original
                finalCtx.drawImage(rawUploadedImage, 0, 0, pixelSize, pixelSize);
                imageData = finalCtx.getImageData(0, 0, pixelSize, pixelSize);
                const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                let gray = 0.299 * r + 0.587 * g + 0.114 * b;

                const bp = editorSettings.blackPoint ?? 0;
                const wp = editorSettings.whitePoint ?? 255;
                gray = (gray - bp) * 255 / Math.max(1, (wp - bp));

                gray = ((gray / 255 - 0.5) * editorSettings.contrast + 0.5) * 255;
                gray = gray * editorSettings.brightness;
                gray = Math.max(0, Math.min(255, gray));

                const base = [0,85,170,255];
                const n = Math.max(2, Math.min(4, editorSettings.tones|0));
                const indices = [];
                for (let k = 0; k < n; k++) {
                    const idx = Math.round((k*(base.length-1))/(n-1));
                    indices.push(base[idx]);
                }
                let finalColor = indices[indices.length-1];
                for (let t = 0; t < indices.length-1; t++) {
                    const mid = (indices[t] + indices[t+1]) / 2;
                    if (gray < mid) { finalColor = indices[t]; break; }
                }

                data[i] = finalColor;
                data[i + 1] = finalColor;
                data[i + 2] = finalColor;
            }
            
                // Store for future editing
                processedImageData = imageData;
                
                // Store a deep copy as the original (for reset functionality)
                originalProcessedImageData = new ImageData(
                    new Uint8ClampedArray(imageData.data),
                    imageData.width,
                    imageData.height
                );
            }

            finalCtx.putImageData(imageData, 0, 0);

            // Convert to image and use as PNG
            finalCanvas.toBlob((blob) => {
                const processedFile = new File([blob], 'processed.png', { type: 'image/png' });
                pngFile = processedFile;

                const img = new Image();
                img.onload = () => {
                    pngImage = img;
                    // Don't set preview here - it's already set to processed version in processImage()
                    // document.getElementById('png-preview-img').src = img.src;
                    // Show crop buttons when image is processed
                    document.getElementById('crop-buttons').style.display = 'block';
                    // Don't show preview automatically - only show when "Show Cropper" is clicked
                    // document.getElementById('png-preview').style.display = 'block';
                    document.getElementById('png-upload-area').classList.add('has-file');
                    document.getElementById('png-upload-text').textContent = 'Processed image';

                    // Apply colors to 3D mesh if STL is loaded
                    if (currentMesh) {
                        applyColorsToMesh();
                    }
                    // Automatically switch to 3D view after applying
                    show3DView();
                };
                img.src = URL.createObjectURL(blob);

                // Persist processed PNG for current grid size
                saveFileToDB(dbKey('png'), processedFile);
            }, 'image/png');
        }

        // Crop Functions - Simple cropper with blue dotted line
        function showCropper() {
            console.log('Show cropper clicked');
            
            const previewImg = document.getElementById('png-preview-img');
            const cropCanvas = document.getElementById('crop-canvas');
            const container = document.getElementById('crop-container');
            
            if (!previewImg || !cropCanvas || !container) {
                console.error('Cropper elements not found');
                return;
            }
            
            // User is manually showing the cropper, so clear the manually hidden flag
            cropperManuallyHidden = false;
            
            // Make upload panel visible but hide the upload area and label - only show cropper
            const uploadPanel = document.getElementById('upload-panel');
            if (uploadPanel) {
                uploadPanel.style.display = 'block';
                // Hide upload area and label, keep only cropper visible
                const uploadArea = document.getElementById('png-upload-area');
                const sectionLabel = uploadPanel.querySelector('.section-label');
                if (uploadArea) uploadArea.style.display = 'none';
                if (sectionLabel) sectionLabel.style.display = 'none';
            }
            
            // Make sure preview image is visible
            document.getElementById('png-preview').style.display = 'block';
            
            // Show the original photo in the cropper (not the processed image)
            if (rawUploadedImage) {
                // Create a snapshot from the original uploaded image
                const snapshotCanvas = document.createElement('canvas');
                const previewMaxSize = 400;
                snapshotCanvas.width = previewMaxSize;
                snapshotCanvas.height = previewMaxSize;
                const snapshotCtx = snapshotCanvas.getContext('2d');
                snapshotCtx.imageSmoothingEnabled = true; // Use smoothing for original photo
                
                // Calculate aspect ratio to maintain it
                const aspectRatio = rawUploadedImage.width / rawUploadedImage.height;
                let drawWidth = previewMaxSize;
                let drawHeight = previewMaxSize;
                let offsetX = 0;
                let offsetY = 0;
                
                if (aspectRatio > 1) {
                    // Image is wider than tall
                    drawHeight = previewMaxSize / aspectRatio;
                    offsetY = (previewMaxSize - drawHeight) / 2;
                } else {
                    // Image is taller than wide
                    drawWidth = previewMaxSize * aspectRatio;
                    offsetX = (previewMaxSize - drawWidth) / 2;
                }
                
                // Draw the original image centered
                snapshotCtx.drawImage(rawUploadedImage, offsetX, offsetY, drawWidth, drawHeight);
                
                fullProcessedImageDataURL = snapshotCanvas.toDataURL();
                previewImg.src = fullProcessedImageDataURL;
                previewImg.setAttribute('data-cropper-fixed', 'true');
            } else if (pngImage && pngImage.src) {
                // Fallback: use pngImage if rawUploadedImage not available
                const tempCanvas = document.createElement('canvas');
                const previewMaxSize = 400;
                tempCanvas.width = previewMaxSize;
                tempCanvas.height = previewMaxSize;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.imageSmoothingEnabled = true;
                
                const aspectRatio = pngImage.width / pngImage.height;
                let drawWidth = previewMaxSize;
                let drawHeight = previewMaxSize;
                let offsetX = 0;
                let offsetY = 0;
                
                if (aspectRatio > 1) {
                    drawHeight = previewMaxSize / aspectRatio;
                    offsetY = (previewMaxSize - drawHeight) / 2;
                } else {
                    drawWidth = previewMaxSize * aspectRatio;
                    offsetX = (previewMaxSize - drawWidth) / 2;
                }
                
                const tempImg = new Image();
                tempImg.onload = () => {
                    tempCtx.drawImage(tempImg, offsetX, offsetY, drawWidth, drawHeight);
                    const snapshotDataURL = tempCanvas.toDataURL();
                    fullProcessedImageDataURL = snapshotDataURL;
                    previewImg.src = snapshotDataURL;
                    previewImg.setAttribute('data-cropper-fixed', 'true');
                    // Wait for image to load before initializing cropper
                    if (previewImg.complete && previewImg.naturalWidth > 0) {
                        setTimeout(initCropper, 50);
                    } else {
                        previewImg.onload = function() {
                            setTimeout(initCropper, 50);
                        };
                    }
                };
                tempImg.src = pngImage.src;
                return; // Exit early, will continue after image loads
            } else {
                alert('Please upload an image first');
                return;
            }
            
            // Wait for image to load if needed
            if (previewImg.complete && previewImg.naturalWidth > 0) {
                setTimeout(initCropper, 50);
            } else {
                previewImg.onload = function() {
                    setTimeout(initCropper, 50);
                };
                // If image is already loading, trigger onload manually
                if (previewImg.src) {
                    previewImg.load();
                }
            }
            
            function initCropper() {
                // Reset zoom/pan when showing cropper
                cropperZoom = 1.0;
                cropperPanX = 0;
                cropperPanY = 0;
                updateCropperTransform();
                
                // Get actual displayed image dimensions
                const imgDisplayWidth = previewImg.offsetWidth || previewImg.clientWidth || 400;
                const imgDisplayHeight = previewImg.offsetHeight || previewImg.clientHeight || 400;
                
                // Set canvas display size to match actual image size
                cropCanvas.style.width = imgDisplayWidth + 'px';
                cropCanvas.style.height = imgDisplayHeight + 'px';
                cropCanvas.style.left = '0px';
                cropCanvas.style.top = '0px';
                cropCanvas.style.display = 'block';
                cropCanvas.style.pointerEvents = 'auto';
                cropCanvas.style.cursor = 'move';
                cropCanvas.style.zIndex = '10';
                
                // Set canvas internal resolution (device pixel ratio for crisp lines)
                const dpr = window.devicePixelRatio || 1;
                cropCanvas.width = imgDisplayWidth * dpr;
                cropCanvas.height = imgDisplayHeight * dpr;
                
                // Initialize crop area - ONLY if never initialized before (preserve position forever after first use)
                if (!cropInitialized) {
                    // First time - center it, 80% of image size, snapped to grid
                    const gridSize = selectedGridSize;
                    const cellSize = imgDisplayWidth / gridSize;
                    
                    let initialSize = Math.min(imgDisplayWidth, imgDisplayHeight) * 0.8;
                    const numCells = Math.round(initialSize / cellSize);
                    cropSize = Math.max(1, numCells) * cellSize;
                    
                    // Precise center calculation with snapping
                    const centerX = (imgDisplayWidth - cropSize) / 2;
                    const centerY = (imgDisplayHeight - cropSize) / 2;
                    const centerCellX = Math.round(centerX / cellSize);
                    const centerCellY = Math.round(centerY / cellSize);
                    cropX = centerCellX * cellSize;
                    cropY = centerCellY * cellSize;
                    
                    // Ensure crop box stays within image bounds
                    cropX = Math.max(0, Math.min(cropX, imgDisplayWidth - cropSize));
                    cropY = Math.max(0, Math.min(cropY, imgDisplayHeight - cropSize));
                    
                    cropInitialized = true; // Mark as initialized - never reset again
                }
                // If crop position already exists, keep it exactly where it is (don't reset to center)
                
                cropperVisible = true;
                document.getElementById('show-cropper-btn').style.display = 'none';
                document.getElementById('hide-cropper-btn').style.display = 'block';
                // Show the preview image
                document.getElementById('png-preview').style.display = 'block';
                
                drawCropBox();
            }
        }
        
        function drawCropBox() {
            if (!cropperVisible) return;
            
            const cropCanvas = document.getElementById('crop-canvas');
            if (!cropCanvas) return;
            
            // Use FIXED dimensions - always 400x400px when cropper is visible
            // This ensures the crop box always matches the fixed preview size
            const imgDisplayWidth = 400;
            const imgDisplayHeight = 400;
            
            const ctx = cropCanvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            
            // Clear canvas completely
            ctx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
            
            // Reset transform to identity first
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            // Scale to device pixel ratio for crisp rendering
            ctx.scale(dpr, dpr);
            
            // Draw blue dotted square border
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 3; // Make it slightly thicker to be more visible
            ctx.setLineDash([8, 4]); // Dash pattern: 8px dash, 4px gap
            ctx.lineDashOffset = 0;
            
            // Ensure crop coordinates are within bounds
            const maxX = Math.min(cropX + cropSize, imgDisplayWidth);
            const maxY = Math.min(cropY + cropSize, imgDisplayHeight);
            const clampedX = Math.max(0, Math.min(cropX, imgDisplayWidth));
            const clampedY = Math.max(0, Math.min(cropY, imgDisplayHeight));
            const clampedSizeX = Math.max(1, maxX - clampedX);
            const clampedSizeY = Math.max(1, maxY - clampedY);
            
            // Draw the rectangle
            ctx.beginPath();
            ctx.rect(clampedX, clampedY, clampedSizeX, clampedSizeY);
            ctx.stroke();
            
            // Reset line dash
            ctx.setLineDash([]);
            
            console.log('Drew crop box at:', clampedX, clampedY, clampedSizeX, clampedSizeY);
        }
        
        // Make the canvas interactive
        document.getElementById('crop-canvas').addEventListener('mousedown', (e) => {
            if (!cropperVisible) return;
            
            const cropCanvas = document.getElementById('crop-canvas');
            const rect = cropCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Check if clicking on edge (for resize) or center (for drag)
            const edgeThreshold = 15;
            const onLeftEdge = Math.abs(mouseX - cropX) < edgeThreshold;
            const onRightEdge = Math.abs(mouseX - (cropX + cropSize)) < edgeThreshold;
            const onTopEdge = Math.abs(mouseY - cropY) < edgeThreshold;
            const onBottomEdge = Math.abs(mouseY - (cropY + cropSize)) < edgeThreshold;
            
            // Check corners first
            const onTopLeft = onTopEdge && onLeftEdge;
            const onTopRight = onTopEdge && onRightEdge;
            const onBottomLeft = onBottomEdge && onLeftEdge;
            const onBottomRight = onBottomEdge && onRightEdge;
            
            if (onTopLeft || onTopRight || onBottomLeft || onBottomRight) {
                // Resize from corner
                isResizingCrop = true;
                if (onTopLeft) resizeEdge = 'topleft';
                else if (onTopRight) resizeEdge = 'topright';
                else if (onBottomLeft) resizeEdge = 'bottomleft';
                else if (onBottomRight) resizeEdge = 'bottomright';
                cropStartX = cropX;
                cropStartY = cropY;
                cropStartSize = cropSize;
                dragStartX = mouseX;
                dragStartY = mouseY;
                cropCanvas.style.cursor = 'nwse-resize';
            } else if (onLeftEdge || onRightEdge || onTopEdge || onBottomEdge) {
                // Resize from edge
                isResizingCrop = true;
                if (onLeftEdge) resizeEdge = 'left';
                else if (onRightEdge) resizeEdge = 'right';
                else if (onTopEdge) resizeEdge = 'top';
                else if (onBottomEdge) resizeEdge = 'bottom';
                cropStartX = cropX;
                cropStartY = cropY;
                cropStartSize = cropSize;
                dragStartX = mouseX;
                dragStartY = mouseY;
                cropCanvas.style.cursor = onLeftEdge || onRightEdge ? 'ew-resize' : 'ns-resize';
            } else if (isPanningCropper) {
                // Start panning
                panStartX = mouseX;
                panStartY = mouseY;
            } else if (mouseX >= cropX && mouseX <= cropX + cropSize &&
                      mouseY >= cropY && mouseY <= cropY + cropSize) {
                // Drag from center (only if not panning)
                isDraggingCrop = true;
                dragStartX = mouseX - cropX * cropperZoom;
                dragStartY = mouseY - cropY * cropperZoom;
                cropCanvas.style.cursor = 'move';
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!cropperVisible && !isDraggingCrop && !isResizingCrop && !isPanningCropper) return;
            
            const cropCanvas = document.getElementById('crop-canvas');
            const rect = cropCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            if (isPanningCropper) {
                // Pan the cropper view
                const deltaX = mouseX - panStartX;
                const deltaY = mouseY - panStartY;
                cropperPanX += deltaX;
                cropperPanY += deltaY;
                panStartX = mouseX;
                panStartY = mouseY;
                updateCropperTransform();
            } else if (isDraggingCrop) {
                // Move crop box - need to convert mouse coordinates to image coordinates
                // Account for zoom/pan transform
                const cropCanvas = document.getElementById('crop-canvas');
                const rect = cropCanvas.getBoundingClientRect();
                const canvasMouseX = (e.clientX - rect.left) / cropperZoom - cropperPanX / cropperZoom;
                const canvasMouseY = (e.clientY - rect.top) / cropperZoom - cropperPanY / cropperZoom;
                
                let newX = canvasMouseX - dragStartX;
                let newY = canvasMouseY - dragStartY;
                
                // Use FIXED dimensions - always 400x400px when cropper is visible
                const imgWidth = 400;
                const imgHeight = 400;
                
                newX = Math.max(0, Math.min(newX, imgWidth - cropSize));
                newY = Math.max(0, Math.min(newY, imgHeight - cropSize));
                
                // Snap to pixel grid
                const gridSize = selectedGridSize;
                const cellSize = imgWidth / gridSize;
                
                // Snap position to grid cell boundaries
                const cellX = Math.round(newX / cellSize);
                const cellY = Math.round(newY / cellSize);
                cropX = cellX * cellSize;
                cropY = cellY * cellSize;
                
                // Ensure it stays within bounds
                const maxCellX = Math.floor((imgWidth - cropSize) / cellSize);
                const maxCellY = Math.floor((imgHeight - cropSize) / cellSize);
                cropX = Math.max(0, Math.min(cropX, maxCellX * cellSize));
                cropY = Math.max(0, Math.min(cropY, maxCellY * cellSize));
                
                // Ensure final bounds check
                cropX = Math.max(0, Math.min(cropX, imgWidth - cropSize));
                cropY = Math.max(0, Math.min(cropY, imgHeight - cropSize));
                
                // Update the crop box visual position
                drawCropBox();
                
                // Update editor section in real-time as you drag (like the reference)
                applyCropFromBox(true);
            } else if (isResizingCrop) {
                // Resize crop box (keep square) based on which edge/corner
                // Use FIXED dimensions - always 400x400px when cropper is visible
                const imgWidth = 400;
                const imgHeight = 400;
                const gridSize = selectedGridSize;
                const cellSize = imgWidth / gridSize; // Each cell size in screen pixels
                
                // Calculate resize direction - fix inverted logic
                let deltaX = mouseX - dragStartX;
                let deltaY = mouseY - dragStartY;
                
                // For corners, use the dominant direction
                let delta = 0;
                if (resizeEdge.includes('left') && resizeEdge.includes('top')) {
                    // Top-left: dragging right/down = larger, left/up = smaller
                    delta = Math.max(-deltaX, -deltaY);
                } else if (resizeEdge.includes('right') && resizeEdge.includes('top')) {
                    // Top-right: dragging right/down = larger, left/up = smaller
                    delta = Math.max(deltaX, -deltaY);
                } else if (resizeEdge.includes('left') && resizeEdge.includes('bottom')) {
                    // Bottom-left: dragging right/down = larger, left/up = smaller
                    delta = Math.max(-deltaX, deltaY);
                } else if (resizeEdge.includes('right') && resizeEdge.includes('bottom')) {
                    // Bottom-right: dragging right/down = larger, left/up = smaller
                    delta = Math.max(deltaX, deltaY);
                } else if (resizeEdge === 'left') {
                    // Left edge: dragging right = larger, left = smaller
                    delta = -deltaX;
                } else if (resizeEdge === 'right') {
                    // Right edge: dragging right = larger, left = smaller
                    delta = deltaX;
                } else if (resizeEdge === 'top') {
                    // Top edge: dragging down = larger, up = smaller
                    delta = -deltaY;
                } else if (resizeEdge === 'bottom') {
                    // Bottom edge: dragging down = larger, up = smaller
                    delta = deltaY;
                }
                
                // Calculate new size (delta > 0 means larger, delta < 0 means smaller)
                let newSize = cropStartSize + delta;
                
                // Constrain size
                newSize = Math.max(cellSize, Math.min(newSize, imgWidth, imgHeight));
                
                // Snap size to grid cells (must be multiple of cellSize) - use precise calculation
                const numCells = Math.round(newSize / cellSize);
                newSize = Math.max(1, numCells) * cellSize;
                
                // Calculate new position based on which edge is being resized
                let newX = cropStartX;
                let newY = cropStartY;
                
                if (resizeEdge.includes('left')) {
                    newX = cropStartX + cropStartSize - newSize;
                    newX = Math.max(0, Math.min(newX, imgWidth - newSize));
                }
                if (resizeEdge.includes('top')) {
                    newY = cropStartY + cropStartSize - newSize;
                    newY = Math.max(0, Math.min(newY, imgHeight - newSize));
                }
                if (resizeEdge.includes('right')) {
                    newX = cropStartX;
                }
                if (resizeEdge.includes('bottom')) {
                    newY = cropStartY;
                }
                
                // Snap position to grid with better precision
                const cellX = Math.round(newX / cellSize);
                const cellY = Math.round(newY / cellSize);
                newX = cellX * cellSize;
                newY = cellY * cellSize;
                
                // Adjust size if needed after snapping position - with precise snapping
                if (resizeEdge.includes('left')) {
                    const actualX = Math.max(0, Math.min(newX, imgWidth - newSize));
                    let adjustedSize = cropStartX + cropStartSize - actualX;
                    const numCells2 = Math.round(adjustedSize / cellSize);
                    adjustedSize = Math.max(1, numCells2) * cellSize;
                    const adjustedX = cropStartX + cropStartSize - adjustedSize;
                    const cellX2 = Math.round(adjustedX / cellSize);
                    newX = cellX2 * cellSize;
                    newSize = cropStartX + cropStartSize - newX;
                    const numCells3 = Math.round(newSize / cellSize);
                    newSize = Math.max(1, numCells3) * cellSize;
                    newX = cropStartX + cropStartSize - newSize;
                    const cellX3 = Math.round(newX / cellSize);
                    newX = Math.max(0, Math.min(cellX3 * cellSize, imgWidth - newSize));
                }
                if (resizeEdge.includes('top')) {
                    const actualY = Math.max(0, Math.min(newY, imgHeight - newSize));
                    let adjustedSize = cropStartY + cropStartSize - actualY;
                    const numCells2 = Math.round(adjustedSize / cellSize);
                    adjustedSize = Math.max(1, numCells2) * cellSize;
                    const adjustedY = cropStartY + cropStartSize - adjustedSize;
                    const cellY2 = Math.round(adjustedY / cellSize);
                    newY = cellY2 * cellSize;
                    newSize = cropStartY + cropStartSize - newY;
                    const numCells3 = Math.round(newSize / cellSize);
                    newSize = Math.max(1, numCells3) * cellSize;
                    newY = cropStartY + cropStartSize - newSize;
                    const cellY3 = Math.round(newY / cellSize);
                    newY = Math.max(0, Math.min(cellY3 * cellSize, imgHeight - newSize));
                }
                
                // Final constraints with precise snapping
                newSize = Math.max(cellSize, Math.min(newSize, imgWidth - newX, imgHeight - newY));
                const finalNumCells = Math.round(newSize / cellSize);
                newSize = Math.max(1, finalNumCells) * cellSize;
                
                // Final position snap
                const finalCellX = Math.round(newX / cellSize);
                const finalCellY = Math.round(newY / cellSize);
                cropX = Math.max(0, Math.min(finalCellX * cellSize, imgWidth - newSize));
                cropY = Math.max(0, Math.min(finalCellY * cellSize, imgHeight - newSize));
                cropSize = newSize;
                
                // Update the crop box visual position
                drawCropBox();
                
                // Update editor section in real-time as you resize (like the reference)
                applyCropFromBox(true);
            } else if (cropperVisible) {
                // Update cursor when hovering
                const edgeThreshold = 15;
                const onLeftEdge = Math.abs(mouseX - cropX) < edgeThreshold;
                const onRightEdge = Math.abs(mouseX - (cropX + cropSize)) < edgeThreshold;
                const onTopEdge = Math.abs(mouseY - cropY) < edgeThreshold;
                const onBottomEdge = Math.abs(mouseY - (cropY + cropSize)) < edgeThreshold;
                
                if ((onTopEdge && onLeftEdge) || (onBottomEdge && onRightEdge)) {
                    cropCanvas.style.cursor = 'nwse-resize';
                } else if ((onTopEdge && onRightEdge) || (onBottomEdge && onLeftEdge)) {
                    cropCanvas.style.cursor = 'nesw-resize';
                } else if (onLeftEdge || onRightEdge) {
                    cropCanvas.style.cursor = 'ew-resize';
                } else if (onTopEdge || onBottomEdge) {
                    cropCanvas.style.cursor = 'ns-resize';
                } else if (mouseX >= cropX && mouseX <= cropX + cropSize &&
                          mouseY >= cropY && mouseY <= cropY + cropSize) {
                    cropCanvas.style.cursor = 'move';
                } else {
                    cropCanvas.style.cursor = 'default';
                }
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (isDraggingCrop || isResizingCrop) {
                // Redraw crop box
                drawCropBox();
                // Auto-apply crop when done dragging/resizing to update editor section
                setTimeout(() => {
                    applyCropFromBox(true);
                }, 50);
            }
            isDraggingCrop = false;
            isResizingCrop = false;
            isPanningCropper = false;
            resizeEdge = '';
            const cropCanvas = document.getElementById('crop-canvas');
            if (cropCanvas) {
                cropCanvas.style.cursor = isPanningCropper ? 'grab' : 'move';
            }
        });
        
        // Hide cropper and image preview
        function hideCropper() {
            // Hide the cropper overlay and the entire preview image
            cropperVisible = false;
            cropperManuallyHidden = true; // Mark that user manually hid it
            isPanningCropper = false;
            document.getElementById('crop-canvas').style.display = 'none';
            document.getElementById('png-preview').style.display = 'none';
            document.getElementById('show-cropper-btn').style.display = 'block';
            document.getElementById('hide-cropper-btn').style.display = 'none';
            // Keep upload panel visible so user can show cropper again via button
        }
        
        // Cropper zoom/pan functions
        function cropperZoomIn() {
            cropperZoom = Math.min(cropperZoom * 1.5, 5.0);
            updateCropperTransform();
        }
        
        function cropperZoomOut() {
            cropperZoom = Math.max(cropperZoom / 1.5, 0.5);
            updateCropperTransform();
        }
        
        function cropperResetView() {
            cropperZoom = 1.0;
            cropperPanX = 0;
            cropperPanY = 0;
            updateCropperTransform();
        }
        
        function cropperTogglePan() {
            const btn = document.getElementById('cropper-pan-btn');
            const cropCanvas = document.getElementById('crop-canvas');
            if (isPanningCropper) {
                isPanningCropper = false;
                btn.style.background = 'white';
                if (cropCanvas) cropCanvas.style.cursor = 'move';
            } else {
                isPanningCropper = true;
                btn.style.background = '#e0e0e0';
                if (cropCanvas) cropCanvas.style.cursor = 'grab';
            }
        }
        
        function updateCropperTransform() {
            const previewImg = document.getElementById('png-preview-img');
            if (previewImg) {
                const transform = `translate(${cropperPanX}px, ${cropperPanY}px) scale(${cropperZoom})`;
                previewImg.style.transform = transform;
                
                // Also update crop canvas to match
                const cropCanvas = document.getElementById('crop-canvas');
                if (cropCanvas) {
                    cropCanvas.style.transform = transform;
                }
                
                // Redraw crop box with new transform
                drawCropBox();
            }
        }
        
        function applyCropFromBox(skipVisibilityCheck = false) {
            // Only proceed if we have the full original image
            if (!fullOriginalImage) {
                // If no fullOriginalImage but we have rawUploadedImage, use that
                if (!rawUploadedImage || (!cropperVisible && !skipVisibilityCheck)) return;
            } else if (!cropperVisible && !skipVisibilityCheck) {
                return;
            }
            
            // IMPORTANT: While cropper is visible, we need to use the stored full processed image dimensions
            // NOT the cropper preview image dimensions (which might change)
            const previewImg = document.getElementById('png-preview-img');
            if (!previewImg) return;
            
            // Use fullOriginalImage if available, otherwise fall back to rawUploadedImage
            const sourceImage = fullOriginalImage || rawUploadedImage;
            
            // If cropper is visible, use fixed dimensions based on fullProcessedImageDataURL
            // This prevents any changes to the cropper preview image
            let imgDisplayWidth, imgDisplayHeight;
            if (cropperVisible && fullProcessedImageDataURL) {
                // Use fixed dimensions - preview is always 400px max with aspect ratio 1:1
                imgDisplayWidth = 400;
                imgDisplayHeight = 400;
            } else {
                // Normal case: get dimensions from preview image
                const imgRect = previewImg.getBoundingClientRect();
                if (imgRect.width === 0 || imgRect.height === 0) return;
                imgDisplayWidth = imgRect.width;
                imgDisplayHeight = imgRect.height;
            }
            
            // Calculate scale from preview display size to actual image size
            const scale = sourceImage.width / imgDisplayWidth;
            
            // Check if crop covers the entire displayed image (within a small threshold)
            // Check in displayed coordinates first, before converting to source coordinates
            const threshold = 10; // pixels tolerance in displayed coordinates
            const coversFullWidth = Math.abs(cropX) < threshold && Math.abs(cropX + cropSize - imgDisplayWidth) < threshold;
            const coversFullHeight = Math.abs(cropY) < threshold && Math.abs(cropY + cropSize - imgDisplayHeight) < threshold;
            const isFullSize = Math.abs(cropSize - imgDisplayWidth) < threshold && Math.abs(cropSize - imgDisplayHeight) < threshold;
            
            // If crop covers the full displayed image, reset crop coordinates to null (no crop)
            if (coversFullWidth && coversFullHeight && isFullSize) {
                cropCoordinates = null;
            } else {
                // Calculate actual pixel coordinates in the full original image
                const x = cropX * scale;
                const y = cropY * scale;
                const size = cropSize * scale;
                
                // Snap to grid cells
                const gridSize = selectedGridSize;
                const cellSize = size / gridSize;
                const snappedSize = Math.floor(size / cellSize) * cellSize;
                
                // Ensure we have valid crop dimensions
                if (snappedSize <= 0 || x < 0 || y < 0 || x + snappedSize > sourceImage.width || y + snappedSize > sourceImage.height) {
                    return;
                }
                
                // Store crop coordinates for use in processImage
                // DO NOT modify rawUploadedImage - keep it as the full original always
                cropCoordinates = { x, y, size: snappedSize };
            }
            
            // IMPORTANT: Prevent fullProcessedImageDataURL from being overwritten during cropping
            const savedFullProcessedImageDataURL = fullProcessedImageDataURL;
            
            // Process image with current crop settings
            processImage();
            
            // Restore fullProcessedImageDataURL after processing
            fullProcessedImageDataURL = savedFullProcessedImageDataURL;
            
            // Update preview image if needed (but don't modify rawUploadedImage)
            const img = new Image();
            img.onload = () => {
                // Don't update rawUploadedImage - keep it as full original
                // rawUploadedImage stays as the full original image
                
                // Keep the full original image visible (don't update it)
                // Processed image is shown in the canvas
                // IMPORTANT: Do NOT update the cropper preview image here!
                // The cropper preview should always stay showing the FULL processed image at fixed size
                // Only the editor panel (processed-canvas) will show the cropped/zoomed version
                
                // IMPORTANT: Prevent fullProcessedImageDataURL from being overwritten during cropping
                // Save it temporarily and restore it after processing
                const savedFullProcessedImageDataURL = fullProcessedImageDataURL;
                
                // Reprocess image with cropped version - this will update processed view in editor only
                processImage();
                
                // Restore the frozen cropper preview snapshot - it must NEVER change
                fullProcessedImageDataURL = savedFullProcessedImageDataURL;
                // Also update the processed canvas in the left editor
                const processedCanvas = document.getElementById('processed-canvas');
                if (processedCanvas) {
                    const ctx = processedCanvas.getContext('2d');
                    // Draw the cropped image processed at the selected grid size
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = selectedGridSize;
                    tempCanvas.height = selectedGridSize;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(img, 0, 0, selectedGridSize, selectedGridSize);
                    
                    // Apply same processing as processImage
                    const imageData = tempCtx.getImageData(0, 0, selectedGridSize, selectedGridSize);
                    const data = imageData.data;
                    
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        let gray = 0.299 * r + 0.587 * g + 0.114 * b;

                        const bp = editorSettings.blackPoint ?? 0;
                        const wp = editorSettings.whitePoint ?? 255;
                        gray = (gray - bp) * 255 / Math.max(1, (wp - bp));

                        gray = ((gray / 255 - 0.5) * editorSettings.contrast + 0.5) * 255;
                        gray = gray * editorSettings.brightness;
                        gray = Math.max(0, Math.min(255, gray));

                        const base = [0,85,170,255];
                        const n = Math.max(2, Math.min(4, editorSettings.tones|0));
                        const indices = [];
                        for (let k = 0; k < n; k++) {
                            const idx = Math.round((k*(base.length-1))/(n-1));
                            indices.push(base[idx]);
                        }
                        let finalColor = indices[indices.length-1];
                        for (let t = 0; t < indices.length-1; t++) {
                            const mid = (indices[t] + indices[t+1]) / 2;
                            if (gray < mid) { finalColor = indices[t]; break; }
                        }

                        data[i] = finalColor;
                        data[i + 1] = finalColor;
                        data[i + 2] = finalColor;
                    }
                    
                    tempCtx.putImageData(imageData, 0, 0);
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(tempCanvas, 0, 0, processedCanvas.width, processedCanvas.height);
                }
                // Redraw crop box with new image
                setTimeout(() => {
                    if (cropperVisible) {
                        showCropper(); // Reinitialize cropper
                    }
                }, 100);
            };
            img.src = newCanvas.toDataURL();
        }

        // Paint Functions
        function selectPaintColor(r, g, b, element) {
            selectedPaintColor = { r, g, b };
            // Update selected state
            document.querySelectorAll('.color-swatch').forEach(swatch => {
                swatch.classList.remove('selected');
            });
            element.classList.add('selected');
            console.log('Selected paint color:', selectedPaintColor);
        }

        function zoomInProcessed() {
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas) return;
            
            // Zoom in at the center of the canvas
            const w = processedCanvas.width;
            const h = processedCanvas.height;
            const centerX = w / 2;
            const centerY = h / 2;
            
            // Zoom factor
            const zoomFactor = 1.5;
            const newZoom = Math.min(processedZoom * zoomFactor, 10);
            
            // Calculate new offset so center stays at center
            const imageX = (centerX - w/2 - processedZoomOffsetX) / processedZoom;
            const imageY = (centerY - h/2 - processedZoomOffsetY) / processedZoom;
            const newOffsetX = centerX - w/2 - imageX * newZoom;
            const newOffsetY = centerY - h/2 - imageY * newZoom;
            
            processedZoom = newZoom;
            processedZoomOffsetX = newOffsetX;
            processedZoomOffsetY = newOffsetY;
            
            constrainPanBounds(processedZoom);
            redrawProcessedCanvas();
            
            // Deactivate any modes
            zoomMode = null;
            if (processedCanvas) processedCanvas.style.cursor = 'crosshair';
            
            const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
            const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
            if (zoomInBtn) zoomInBtn.style.background = '#E0E0E0';
            if (zoomOutBtn) zoomOutBtn.style.background = '#E0E0E0';
        }

        function zoomOutProcessed() {
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas) return;
            
            // Zoom out at the center of the canvas
            const w = processedCanvas.width;
            const h = processedCanvas.height;
            const centerX = w / 2;
            const centerY = h / 2;
            
            // Zoom factor
            const zoomFactor = 1.5;
            const minZoom = 1.0;
            const newZoom = Math.max(processedZoom / zoomFactor, minZoom);
            
            // Calculate new offset so center stays at center
            const imageX = (centerX - w/2 - processedZoomOffsetX) / processedZoom;
            const imageY = (centerY - h/2 - processedZoomOffsetY) / processedZoom;
            const newOffsetX = centerX - w/2 - imageX * newZoom;
            const newOffsetY = centerY - h/2 - imageY * newZoom;
            
            processedZoom = newZoom;
            processedZoomOffsetX = newOffsetX;
            processedZoomOffsetY = newOffsetY;
            
            constrainPanBounds(processedZoom);
            redrawProcessedCanvas();
            
            // Deactivate any modes
            zoomMode = null;
            if (processedCanvas) processedCanvas.style.cursor = 'crosshair';
            
            const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
            const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
            if (zoomInBtn) zoomInBtn.style.background = '#E0E0E0';
            if (zoomOutBtn) zoomOutBtn.style.background = '#E0E0E0';
        }

        function resetZoomProcessed() {
            processedZoom = 1.0;
            processedZoomOffsetX = 0;
            processedZoomOffsetY = 0;
            zoomMode = null;
            
            const processedCanvas = document.getElementById('processed-canvas');
            const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
            const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
            const resetBtn = document.getElementById('processed-reset-btn');
            
            if (processedCanvas) processedCanvas.style.cursor = 'crosshair';
            if (zoomInBtn) zoomInBtn.style.background = '#E0E0E0';
            if (zoomOutBtn) zoomOutBtn.style.background = '#E0E0E0';
            if (resetBtn) resetBtn.style.background = '#E0E0E0';
            
            redrawProcessedCanvas();
        }
        
        // Function to deactivate all zoom/pan modes
        function deactivateZoomPanModes() {
            zoomMode = null;
            
            const processedCanvas = document.getElementById('processed-canvas');
            const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
            const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
            
            if (processedCanvas) processedCanvas.style.cursor = 'crosshair';
            if (zoomInBtn) zoomInBtn.style.background = '#E0E0E0';
            if (zoomOutBtn) zoomOutBtn.style.background = '#E0E0E0';
        }
        
        function zoomToPoint(x, y, zoomFactor) {
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas) return;
            
            const rect = processedCanvas.getBoundingClientRect();
            const w = processedCanvas.width;
            const h = processedCanvas.height;
            
            // Convert click position to canvas coordinates (absolute, not relative to center)
            const canvasX = x - rect.left;
            const canvasY = y - rect.top;
            
            // Calculate the point in image space that corresponds to this canvas click
            // In redrawProcessedCanvas, transforms are:
            // 1. translate(w/2, h/2) - center
            // 2. translate(offsetX, offsetY) - pan
            // 3. scale(zoom, zoom)
            // 4. draw at (-w/2, -h/2)
            // So: canvasX = imageX * zoom + offsetX + w/2
            // Therefore: imageX = (canvasX - w/2 - offsetX) / zoom
            const imageX = (canvasX - w/2 - processedZoomOffsetX) / processedZoom;
            const imageY = (canvasY - h/2 - processedZoomOffsetY) / processedZoom;
            
            // Calculate new zoom level
            // For zoom out, limit to minimum zoom that doesn't show whitespace (image should fill at least the canvas)
            const minZoom = 1.0; // Don't zoom out past original size
            const newZoom = zoomMode === 'zoom-in' 
                ? Math.min(processedZoom * zoomFactor, 10)
                : Math.max(processedZoom / zoomFactor, minZoom);
            
            // Calculate new offset so the clicked image point stays at the same canvas position
            // After zoom: canvasX = imageX * newZoom + newOffsetX + w/2
            // So: newOffsetX = canvasX - w/2 - imageX * newZoom
            const newOffsetX = canvasX - w/2 - imageX * newZoom;
            const newOffsetY = canvasY - h/2 - imageY * newZoom;
            
            // Constrain offsets to prevent showing whitespace
            constrainPanBounds(newZoom);
            
            // Update zoom and offset
            processedZoom = newZoom;
            processedZoomOffsetX = newOffsetX;
            processedZoomOffsetY = newOffsetY;
            
            // Apply bounds again after setting
            constrainPanBounds(processedZoom);
            
            redrawProcessedCanvas();
        }
        
        function constrainPanBounds(zoom) {
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas) return;
            
            const w = processedCanvas.width;
            const h = processedCanvas.height;
            
            // Calculate the maximum allowed offset to keep image within bounds
            // When zoomed, the image is scaled, so we need to prevent panning too far
            // Image is drawn at (-w/2, -h/2) with size (w, h) before transforms
            // After scale(zoom), the visible image size becomes w*zoom, h*zoom
            // We want to constrain so that image edges stay within canvas bounds
            
            // Maximum offset should keep the image edges visible
            // If zoom >= 1, we can pan more freely
            // If zoom < 1, we should limit panning to keep image centered
            if (zoom >= 1.0) {
                // When zoomed in, allow more panning
                const maxOffset = (w * zoom - w) / 2;
                processedZoomOffsetX = Math.max(-maxOffset, Math.min(maxOffset, processedZoomOffsetX));
                processedZoomOffsetY = Math.max(-maxOffset, Math.min(maxOffset, processedZoomOffsetY));
            } else {
                // When zoomed out, limit panning to keep image visible
                // At zoom 1.0, offset should be 0
                const maxOffset = w * (1 - zoom) / 2;
                processedZoomOffsetX = Math.max(-maxOffset, Math.min(maxOffset, processedZoomOffsetX));
                processedZoomOffsetY = Math.max(-maxOffset, Math.min(maxOffset, processedZoomOffsetY));
            }
        }

        function redrawProcessedCanvas() {
            if (!processedImageData) return;
            
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas) return;
            const processedCtx = processedCanvas.getContext('2d');
            const pixelSize = selectedGridSize;
            
            // Create temp canvas at pixel size with current data
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = pixelSize;
            tempCanvas.height = pixelSize;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(processedImageData, 0, 0);
            
            // Get display size (may be different from canvas internal size)
            const displayWidth = processedCanvas.width;
            const displayHeight = processedCanvas.height;
            
            // Clear and redraw with zoom
            processedCtx.clearRect(0, 0, displayWidth, displayHeight);
            
            if (processedZoom === 1.0 && processedZoomOffsetX === 0 && processedZoomOffsetY === 0) {
                // No zoom, just draw normally
                processedCtx.imageSmoothingEnabled = false;
                processedCtx.drawImage(tempCanvas, 0, 0, displayWidth, displayHeight);
            } else {
                // Draw with zoom and offset
                // The image is drawn centered, then scaled and translated
                processedCtx.save();
                // Translate to center, then apply offset, then scale
                processedCtx.translate(displayWidth / 2, displayHeight / 2);
                processedCtx.translate(processedZoomOffsetX, processedZoomOffsetY);
                processedCtx.scale(processedZoom, processedZoom);
                processedCtx.imageSmoothingEnabled = false;
                // Draw image centered at origin (before transforms)
                processedCtx.drawImage(tempCanvas, -displayWidth / 2, -displayHeight / 2, displayWidth, displayHeight);
                processedCtx.restore();
            }
        }

        // Paint pixel function with brush size support
        function paintPixelAt(clickX, clickY, processedCanvas) {
            if (!processedImageData) return false;
            
            const pixelSize = selectedGridSize;
            
            // Convert to pixel coordinates
            const pixelX = Math.floor((clickX / processedCanvas.width) * pixelSize);
            const pixelY = Math.floor((clickY / processedCanvas.height) * pixelSize);
            
            // Paint a brush area based on brush size
            // Brush size N paints an NxN square (N pixels wide, N pixels tall)
            // Size 1 = 1x1 (1 pixel), Size 2 = 2x2 (4 pixels), Size 3 = 3x3 (9 pixels), etc.
            let painted = false;
            
            // Calculate the start position (top-left corner of the square)
            // Center the brush on the click position
            const startX = pixelX - Math.floor(brushSize / 2);
            const startY = pixelY - Math.floor(brushSize / 2);
            
            // Paint all pixels in the NxN square
            for (let dy = 0; dy < brushSize; dy++) {
                for (let dx = 0; dx < brushSize; dx++) {
                    const x = startX + dx;
                    const y = startY + dy;
                    
                    // Ensure within bounds
                    if (x >= 0 && x < pixelSize && y >= 0 && y < pixelSize) {
                        // Update pixel color in image data
                        const index = (y * pixelSize + x) * 4;
                        processedImageData.data[index] = selectedPaintColor.r;     // R
                        processedImageData.data[index + 1] = selectedPaintColor.g; // G
                        processedImageData.data[index + 2] = selectedPaintColor.b; // B
                        processedImageData.data[index + 3] = 255;                  // A
                        painted = true;
                    }
                }
            }
            
            return painted;
        }

        // Add click and drag handlers to processed canvas for pixel painting
        let isPainting = false;
        
        // Set up paint event listeners (called after DOM loads and when canvas is recreated)
        function setupPaintHandlers() {
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas) return;
            
            // Use a flag to prevent duplicate listeners
            if (processedCanvas.dataset.paintHandlersSetup === 'true') return;
            processedCanvas.dataset.paintHandlersSetup = 'true';
            
            let isDraggingPan = false;
            
            processedCanvas.addEventListener('mousedown', (e) => {
                if (zoomMode === 'zoom-in') {
                    // Zoom in to the clicked point
                    zoomToPoint(e.clientX, e.clientY, 1.3);
                } else if (zoomMode === 'zoom-out') {
                    // Zoom out from the clicked point
                    zoomToPoint(e.clientX, e.clientY, 1.3);
                } else if (!isPainting && processedZoom > 1.0) {
                    // Start panning when dragging (only if zoomed in and not painting)
                    isDraggingPan = true;
                    processedPanStartX = e.clientX;
                    processedPanStartY = e.clientY;
                    const startOffsetX = processedZoomOffsetX;
                    const startOffsetY = processedZoomOffsetY;
                    
                    // Store start offsets in the event listener closure
                    processedCanvas.dataset.panStartOffsetX = startOffsetX;
                    processedCanvas.dataset.panStartOffsetY = startOffsetY;
                } else if (processedImageData && !isDraggingPan) {
                    // Start painting (only if not in pan mode)
                    // Save state to undo stack before starting to paint
                    if (!isPainting) {
                        savePaintState();
                    }
                    isPainting = true;
                    const rect = processedCanvas.getBoundingClientRect();
                    
                    // Calculate click position in image space accounting for zoom and offset
                    // The image is drawn with transforms: translate(center) -> translate(offset) -> scale(zoom)
                    // So to reverse: get canvas coords, subtract center, subtract offset, divide by zoom
                    const canvasX = e.clientX - rect.left;
                    const canvasY = e.clientY - rect.top;
                    const w = processedCanvas.width;
                    const h = processedCanvas.height;
                    
                    // Convert to coordinates relative to center
                    const centerRelativeX = canvasX - w / 2;
                    const centerRelativeY = canvasY - h / 2;
                    
                    // Apply inverse transform: subtract offset, then divide by zoom
                    const imageSpaceX = (centerRelativeX - processedZoomOffsetX) / processedZoom;
                    const imageSpaceY = (centerRelativeY - processedZoomOffsetY) / processedZoom;
                    
                    // Convert to coordinates where image is drawn at (-w/2, -h/2) with size (w, h)
                    // So add w/2 and h/2 to get coordinates from 0 to w/h
                    const normalizedX = imageSpaceX + w / 2;
                    const normalizedY = imageSpaceY + h / 2;
                    
                    if (paintPixelAt(normalizedX, normalizedY, processedCanvas)) {
                        redrawProcessedCanvas();
                    }
                }
            });
        
            processedCanvas.addEventListener('mousemove', (e) => {
                if (isDraggingPan && !isPainting) {
                    // Pan the view - calculate delta from start position
                    const deltaX = e.clientX - processedPanStartX;
                    const deltaY = e.clientY - processedPanStartY;
                    const startOffsetX = parseFloat(processedCanvas.dataset.panStartOffsetX || 0);
                    const startOffsetY = parseFloat(processedCanvas.dataset.panStartOffsetY || 0);
                    
                    // Update offset based on drag delta
                    processedZoomOffsetX = startOffsetX + deltaX;
                    processedZoomOffsetY = startOffsetY + deltaY;
                    
                    // Constrain to bounds
                    constrainPanBounds(processedZoom);
                    
                    redrawProcessedCanvas();
                } else if (isPainting && processedImageData && !isDraggingPan) {
                    // Continue painting (only if not in pan mode)
                    const rect = processedCanvas.getBoundingClientRect();
                    
                    // Calculate position in image space accounting for zoom and offset
                    const canvasX = e.clientX - rect.left;
                    const canvasY = e.clientY - rect.top;
                    const w = processedCanvas.width;
                    const h = processedCanvas.height;
                    
                    // Convert to coordinates relative to center
                    const centerRelativeX = canvasX - w / 2;
                    const centerRelativeY = canvasY - h / 2;
                    
                    // Apply inverse transform: subtract offset, then divide by zoom
                    const imageSpaceX = (centerRelativeX - processedZoomOffsetX) / processedZoom;
                    const imageSpaceY = (centerRelativeY - processedZoomOffsetY) / processedZoom;
                    
                    // Convert to coordinates where image is drawn at (-w/2, -h/2) with size (w, h)
                    const normalizedX = imageSpaceX + w / 2;
                    const normalizedY = imageSpaceY + h / 2;
                    
                    if (paintPixelAt(normalizedX, normalizedY, processedCanvas)) {
                        redrawProcessedCanvas();
                    }
                }
            });
            
            processedCanvas.addEventListener('mouseup', () => {
                if (isPainting) {
                    // Paint stroke finished - update undo/redo buttons
                    updateUndoRedoButtons();
                }
                isPainting = false;
                isDraggingPan = false;
            });
            
            processedCanvas.addEventListener('mouseleave', () => {
                if (isPainting) {
                    // Paint stroke finished - update undo/redo buttons
                    updateUndoRedoButtons();
                }
                isPainting = false;
                isDraggingPan = false;
            });
        }
        
        // Call setup when page loads
        window.addEventListener('load', () => {
            setupPaintHandlers();
            
            // Deactivate zoom modes when clicking outside the canvas or buttons
            document.addEventListener('click', (e) => {
                const processedCanvas = document.getElementById('processed-canvas');
                const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
                const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
                const resetBtn = document.getElementById('processed-reset-btn');
                
                // Check if click is outside canvas and outside all zoom buttons
                const isClickOnCanvas = processedCanvas && processedCanvas.contains(e.target);
                const isClickOnZoomIn = zoomInBtn && (zoomInBtn.contains(e.target) || zoomInBtn === e.target);
                const isClickOnZoomOut = zoomOutBtn && (zoomOutBtn.contains(e.target) || zoomOutBtn === e.target);
                const isClickOnReset = resetBtn && (resetBtn.contains(e.target) || resetBtn === e.target);
                
                // If click is outside all these elements, deactivate modes
                if (!isClickOnCanvas && !isClickOnZoomIn && !isClickOnZoomOut && !isClickOnReset) {
                    deactivateZoomPanModes();
                }
            });
            
            // Reset dragging when mouse is released
            processedCanvas.addEventListener('mouseup', () => {
                isDraggingPan = false;
            });
            
            processedCanvas.addEventListener('mouseleave', () => {
                isDraggingPan = false;
            });
        });

        // Brush size slider
        document.getElementById('brush-size-slider').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brush-size-value').textContent = brushSize;
        });

        // Reset processed image to original state
        function resetProcessedImage() {
            if (!originalProcessedImageData) {
                console.log('No original image data to reset to');
                return;
            }
            
            // Restore the original image data
            processedImageData = new ImageData(
                new Uint8ClampedArray(originalProcessedImageData.data),
                originalProcessedImageData.width,
                originalProcessedImageData.height
            );
            
            // Redraw the canvas
            redrawProcessedCanvas();
            
            // Clear undo/redo stacks on reset
            undoStack = [];
            redoStack = [];
            updateUndoRedoButtons();
            
            console.log('‚úÖ Image reset to original state');
        }

        // Save current paint state to undo stack
        function savePaintState() {
            if (!processedImageData) return;
            
            // Create a deep copy of the current image data
            const stateCopy = new ImageData(
                new Uint8ClampedArray(processedImageData.data),
                processedImageData.width,
                processedImageData.height
            );
            
            // Save to undo stack
            undoStack.push(stateCopy);
            
            // Clear redo stack when new paint happens
            redoStack = [];
            
            // Limit undo stack size to prevent memory issues (keep last 50 states)
            if (undoStack.length > 50) {
                undoStack.shift();
            }
            
            // Show undo/redo buttons
            document.getElementById('undo-redo-buttons').style.display = 'flex';
            updateUndoRedoButtons();
        }

        // Update undo/redo button states
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const undoRedoContainer = document.getElementById('undo-redo-buttons');
            
            if (!undoBtn || !redoBtn || !undoRedoContainer) return;
            
            if (undoStack.length === 0 && redoStack.length === 0) {
                // Hide buttons if no history
                undoRedoContainer.style.display = 'none';
            } else {
                // Show buttons if there's history
                undoRedoContainer.style.display = 'flex';
                undoBtn.disabled = undoStack.length === 0;
                redoBtn.disabled = redoStack.length === 0;
            }
        }

        // Undo last paint operation
        function undoPaint() {
            if (undoStack.length === 0 || !processedImageData) return;
            
            // Save current state to redo stack before undoing
            const currentState = new ImageData(
                new Uint8ClampedArray(processedImageData.data),
                processedImageData.width,
                processedImageData.height
            );
            redoStack.push(currentState);
            
            // Restore previous state from undo stack
            const previousState = undoStack.pop();
            processedImageData = new ImageData(
                new Uint8ClampedArray(previousState.data),
                previousState.width,
                previousState.height
            );
            
            // Redraw canvas
            redrawProcessedCanvas();
            
            // Update button states
            updateUndoRedoButtons();
        }

        // Redo last undone paint operation
        function redoPaint() {
            if (redoStack.length === 0 || !processedImageData) return;
            
            // Save current state to undo stack before redoing
            const currentState = new ImageData(
                new Uint8ClampedArray(processedImageData.data),
                processedImageData.width,
                processedImageData.height
            );
            undoStack.push(currentState);
            
            // Restore next state from redo stack
            const nextState = redoStack.pop();
            processedImageData = new ImageData(
                new Uint8ClampedArray(nextState.data),
                nextState.width,
                nextState.height
            );
            
            // Redraw canvas
            redrawProcessedCanvas();
            
            // Update button states
            updateUndoRedoButtons();
        }

        // Keyboard shortcuts for undo/redo
        document.addEventListener('keydown', (e) => {
            // Check if we're in the editor panel (painting is active)
            const editorPanel = document.getElementById('editor-panel');
            if (!editorPanel || editorPanel.style.display === 'none') return;
            
            // Check if user is typing in an input field (don't intercept)
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
                return;
            }
            
            // Cmd+Z (Mac) or Ctrl+Z (Windows/Linux) for undo
            if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undoPaint();
            }
            
            // Cmd+Shift+Z (Mac) or Ctrl+Y (Windows/Linux) for redo
            if ((e.metaKey && e.shiftKey && e.key === 'z') || (e.ctrlKey && e.key === 'y')) {
                e.preventDefault();
                redoPaint();
            }
        });

        // Slider event listeners
        document.getElementById('contrast-slider').addEventListener('input', (e) => {
            editorSettings.contrast = parseFloat(e.target.value);
            document.getElementById('contrast-value').textContent = e.target.value;
            processImage();
        });

        document.getElementById('brightness-slider').addEventListener('input', (e) => {
            editorSettings.brightness = parseFloat(e.target.value);
            document.getElementById('brightness-value').textContent = e.target.value;
            processImage();
        });

        document.getElementById('tones-slider').addEventListener('input', (e) => {
            editorSettings.tones = parseInt(e.target.value);
            document.getElementById('tones-value').textContent = `${editorSettings.tones}`;
            processImage();
        });

        // Initialize Three.js
        function initThree() {
            // Don't reinitialize if already initialized
            if (scene && camera && renderer) {
                console.log('Three.js already initialized');
                return;
            }
            
            const container = document.getElementById('canvas-container');
            if (!container) {
                console.error('‚ùå canvas-container not found');
                return;
            }
            
            const width = container.clientWidth || window.innerWidth;
            const height = container.clientHeight || window.innerHeight;

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xfafafa);
            
            // Add lights to show geometry details and textures
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Soft overall lighting
            scene.add(ambientLight);
            
            // Main directional light from above-left
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(50, 100, 50);
            directionalLight1.castShadow = false;
            scene.add(directionalLight1);
            
            // Secondary directional light from opposite side for fill
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-50, 50, -50);
            directionalLight2.castShadow = false;
            scene.add(directionalLight2);

            // Camera
            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.set(100, 100, 100);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width || window.innerWidth, height || 600, true);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Grid
            const gridHelper = new THREE.GridHelper(200, 20, 0xcccccc, 0xe0e0e0);
            scene.add(gridHelper);

            // Animate
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            // Handle resize
            window.addEventListener('resize', () => {
                const w = container.clientWidth || window.innerWidth;
                const h = container.clientHeight || window.innerHeight - 200;
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h, true);
            });
        }

        // Auto tune contrast/brightness using percentile stretch (P5..P95)
        function autoTuneSettingsFromImage(img) {
            try {
                const tmp = document.createElement('canvas');
                const s = 128;
                tmp.width = s; tmp.height = s;
                const ctx = tmp.getContext('2d');
                ctx.drawImage(img, 0, 0, s, s);
                const d = ctx.getImageData(0, 0, s, s).data;
                const values = [];
                for (let i = 0; i < d.length; i += 4) {
                    values.push(0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2]);
                }
                values.sort((a,b)=>a-b);
                const q = (p)=> values[Math.max(0, Math.min(values.length-1, Math.floor(p*(values.length-1))))];
                const p5 = q(0.05);
                const p95 = q(0.95);
                editorSettings.blackPoint = Math.max(0, Math.min(254, Math.round(p5)));
                editorSettings.whitePoint = Math.max(editorSettings.blackPoint+1, Math.min(255, Math.round(p95)));
                // Keep C/B neutral post stretch
                editorSettings.contrast = 1.0;
                editorSettings.brightness = 1.0;
                saveSimpleState();
            } catch (e) {
                editorSettings.blackPoint = 0;
                editorSettings.whitePoint = 255;
                editorSettings.contrast = 1.0;
                editorSettings.brightness = 1.0;
            }
        }

        // Load STL file (returns Promise)
        function loadSTL(file) {
            return new Promise((resolve, reject) => {
                if (!file) {
                    reject(new Error('No STL file provided'));
                    return;
                }
                
                // Ensure Three.js is initialized before loading STL
                if (!scene || !camera || !renderer) {
                    console.log('‚ö†Ô∏è Three.js not initialized yet, initializing now...');
                    try {
                        initThree();
                    } catch (error) {
                        console.error('‚ùå Failed to initialize Three.js:', error);
                        reject(new Error('Failed to initialize Three.js: ' + error.message));
                        return;
                    }
                }
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const loader = new THREE.STLLoader();
                        let geometry = loader.parse(event.target.result);

                        // Ensure per-triangle unique vertices so colors don't bleed across shared vertices
                        if (geometry.index) {
                            geometry = geometry.toNonIndexed();
                        }

                        // Store original geometry
                        originalGeometry = geometry.clone();

                        // Remove old mesh
                        if (currentMesh && scene) {
                            scene.remove(currentMesh);
                        }

                        // Create new mesh with lit material to show geometry details (bumps, cubes, textures)
                        // Use MeshStandardMaterial for realistic lighting that shows surface details
                        const material = new THREE.MeshStandardMaterial({
                            color: 0xffffff, // base white so vertex colors show true values
                            vertexColors: true, // Enable vertex colors for the painted image
                            side: THREE.DoubleSide,
                            flatShading: false, // Use smooth shading to show geometry details
                            metalness: 0.1, // Slight metalness for better detail visibility
                            roughness: 0.7 // Moderate roughness to catch light on surface details
                        });
                        currentMesh = new THREE.Mesh(geometry, material);

                        // Center the mesh
                        geometry.computeBoundingBox();
                        const center = new THREE.Vector3();
                        geometry.boundingBox.getCenter(center);
                        currentMesh.position.sub(center);

                        if (!scene) {
                            reject(new Error('Scene not initialized'));
                            return;
                        }
                        
                        scene.add(currentMesh);

                        // Hide placeholder
                        const placeholder = document.getElementById('three-placeholder');
                        if (placeholder) {
                            placeholder.style.display = 'none';
                        }

                        // Fit camera
                        if (camera && controls) {
                            const box = new THREE.Box3().setFromObject(currentMesh);
                            const size = box.getSize(new THREE.Vector3());
                            const maxDim = Math.max(size.x, size.y, size.z);
                            camera.position.set(maxDim, maxDim, maxDim);
                            controls.target.set(0, 0, 0);
                            controls.update();
                        }

                        // Apply colors if PNG is already loaded
                        if (pngImage) {
                            applyColorsToMesh();
                        }
                        
                        console.log('‚úÖ STL mesh loaded and displayed successfully');
                        resolve(currentMesh);
                    } catch (error) {
                        console.error('‚ùå Error parsing STL file:', error);
                        reject(error);
                    }
                };
                reader.onerror = function(error) {
                    console.error('‚ùå Error reading STL file:', error);
                    reject(error);
                };
                reader.readAsArrayBuffer(file);
            });
        }

        // Apply PNG colors to the 3D mesh
        function applyColorsToMesh() {
            if (!currentMesh || !pngImage || !originalGeometry) return;

            console.log('Applying colors to mesh...');

            const geometry = currentMesh.geometry;
            const positions = geometry.attributes.position;
            const vertices = [];
            
            // Get all vertices
            for (let i = 0; i < positions.count; i++) {
                vertices.push(new THREE.Vector3(
                    positions.getX(i),
                    positions.getY(i),
                    positions.getZ(i)
                ));
            }

            // Compute XY bounds based ONLY on near-horizontal (top) faces to avoid side thickness skew
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            const faceCount = positions.count / 3;
            for (let f = 0; f < faceCount; f++) {
                const a = f * 3, b = a + 1, c = a + 2;
                const v0 = vertices[a], v1 = vertices[b], v2 = vertices[c];
                // Face normal
                const abx = v1.x - v0.x, aby = v1.y - v0.y, abz = v1.z - v0.z;
                const acx = v2.x - v0.x, acy = v2.y - v0.y, acz = v2.z - v0.z;
                const nx = aby * acz - abz * acy;
                const ny = abz * acx - abx * acz;
                const nz = abx * acy - aby * acx;
                const len = Math.hypot(nx, ny, nz) || 1;
                const nzUnit = nz / len;
                if (nzUnit > 0.5) { // top-ish
                    minX = Math.min(minX, v0.x, v1.x, v2.x);
                    minY = Math.min(minY, v0.y, v1.y, v2.y);
                    maxX = Math.max(maxX, v0.x, v1.x, v2.x);
                    maxY = Math.max(maxY, v0.y, v1.y, v2.y);
                }
            }
            if (!isFinite(minX) || !isFinite(minY)) {
                // Fallback to bbox if no top faces detected
                geometry.computeBoundingBox();
                const bbox = geometry.boundingBox;
                minX = bbox.min.x; minY = bbox.min.y; maxX = bbox.max.x; maxY = bbox.max.y;
            }
            const sizeX = Math.max(1e-9, maxX - minX);
            const sizeY = Math.max(1e-9, maxY - minY);

            // Create canvas to read pixel data
            const canvas = document.createElement('canvas');
            canvas.width = pngImage.width;
            canvas.height = pngImage.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(pngImage, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            // Create color array for each face (triangle)
            const numFaces = positions.count / 3;
            const colors = new Float32Array(positions.count * 3);

            for (let faceIndex = 0; faceIndex < numFaces; faceIndex++) {
                const i0 = faceIndex * 3;
                const i1 = faceIndex * 3 + 1;
                const i2 = faceIndex * 3 + 2;

                // Get triangle centroid
                const v0 = vertices[i0];
                const v1 = vertices[i1];
                const v2 = vertices[i2];
                
                const cx = (v0.x + v1.x + v2.x) / 3;
                const cy = (v0.y + v1.y + v2.y) / 3;
                // Snap by selected grid cells to reduce tiny drift across adjacent triangles
                const u = Math.max(0, Math.min(0.999999, (cx - minX) / sizeX));
                const v = Math.max(0, Math.min(0.999999, (cy - minY) / sizeY));
                const grid = selectedGridSize || pngImage?.width || 75;
                const cellU = Math.floor(u * grid) + 0.5; // center of cell
                const cellV = Math.floor(v * grid) + 0.5;
                const snappedU = cellU / grid;
                const snappedV = cellV / grid;
                // Map to image coordinates
                const px = Math.floor(snappedU * (pngImage.width - 1));
                const py = Math.floor((1 - snappedV) * (pngImage.height - 1)); // Flip Y

                // Get pixel color
                const pixelIndex = (py * pngImage.width + px) * 4;
                const r = imageData.data[pixelIndex] / 255;
                const g = imageData.data[pixelIndex + 1] / 255;
                const b = imageData.data[pixelIndex + 2] / 255;

                // Apply color to all 3 vertices of this triangle
                for (let j = 0; j < 3; j++) {
                    const vertexIndex = (i0 + j) * 3;
                    colors[vertexIndex] = r;
                    colors[vertexIndex + 1] = g;
                    colors[vertexIndex + 2] = b;
                }
            }

            // Apply colors to geometry
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Update material to use vertex colors
            currentMesh.material.vertexColors = true;
            currentMesh.material.needsUpdate = true;
            // Keep smooth shading to show geometry details (bumps, cubes, textures)
            // The geometry itself has the detail - lighting will show it naturally
            if ('flatShading' in currentMesh.material) {
                currentMesh.material.flatShading = false; // Smooth shading shows surface details better
            }
            // Ensure normals are computed for proper lighting
            geometry.computeVertexNormals();
            geometry.attributes.color.needsUpdate = true;

            console.log('Colors applied successfully!');
        }

        function resetCamera() {
            if (currentMesh) {
                const box = new THREE.Box3().setFromObject(currentMesh);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                camera.position.set(maxDim, maxDim, maxDim);
                controls.target.set(0, 0, 0);
                controls.update();
            }
        }

        function toggleWireframe() {
            if (currentMesh) {
                currentMesh.material.wireframe = !currentMesh.material.wireframe;
            }
        }

        // File upload handlers
        // Load STL from server based on grid size (auto-load from admin)
        // STL files are uploaded via admin page at /admin and stored in stl_files/{size}x{size}_grid.stl
        async function loadSTLFromServer(size) {
            try {
                console.log(`üì¶ Loading STL for ${size}√ó${size} grid from admin server...`);
                const response = await fetch(`/get-stl/${size}`);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`‚ùå Failed to load STL for size ${size}: ${response.status} ${response.statusText}`);
                    console.error(`Error details: ${errorText}`);
                    stlFile = null;
                    // Show placeholder if STL fails to load
                    const placeholder = document.getElementById('three-placeholder');
                    if (placeholder) {
                        placeholder.style.display = 'block';
                        placeholder.querySelector('div:last-child').textContent = `STL file not found for ${size}√ó${size} grid. Please upload via admin.`;
                    }
                    return;
                }
                
                const blob = await response.blob();
                if (blob.size === 0) {
                    console.error(`‚ùå Received empty STL file for size ${size}`);
                    stlFile = null;
                    return;
                }
                
                stlFile = new File([blob], `${size}x${size}_grid.stl`, { type: 'application/octet-stream' });
                console.log(`‚úÖ Received STL file: ${stlFile.name} (${(blob.size / 1024).toFixed(2)} KB)`);
                
                // Save to IndexedDB for caching
                await saveFileToDB(dbKey('stl', size), stlFile);
                
                // Load the STL file (this will hide the placeholder automatically)
                await loadSTL(stlFile);
                console.log(`‚úÖ Successfully loaded and displayed STL for ${size}√ó${size} grid from admin`);
            } catch (error) {
                console.error('‚ùå Error loading STL from admin:', error);
                stlFile = null;
                // Show placeholder if STL fails to load
                const placeholder = document.getElementById('three-placeholder');
                if (placeholder) {
                    placeholder.style.display = 'block';
                    placeholder.querySelector('div:last-child').textContent = `Error loading STL: ${error.message}`;
                }
            }
        }

        // STL files are now pre-uploaded and auto-loaded from server
        // No manual upload needed

        document.getElementById('png-input').addEventListener('change', async (e) => {
            // Show upload section when file is selected
            // Upload panel is shown/hidden via togglePanel, don't force show here
            pngFile = e.target.files[0];
            if (pngFile) {
                document.getElementById('png-upload-area').classList.add('has-file');
                document.getElementById('png-upload-text').textContent = pngFile.name;
                
                let fileToProcess = pngFile;
                
                // Check if file is HEIC/HEIF and convert it
                const fileExtension = pngFile.name.toLowerCase().split('.').pop();
                const isHeic = fileExtension === 'heic' || fileExtension === 'heif' || 
                               pngFile.type === 'image/heic' || pngFile.type === 'image/heif';
                
                if (isHeic && typeof heic2any !== 'undefined') {
                    try {
                        showStatus('loading', 'Converting HEIC image...');
                        // Convert HEIC to JPEG
                        const convertedBlob = await heic2any({
                            blob: pngFile,
                            toType: 'image/jpeg',
                            quality: 0.92
                        });
                        // heic2any returns an array, take the first element
                        const convertedFile = convertedBlob instanceof Array ? convertedBlob[0] : convertedBlob;
                        // Create a new File object with the converted blob
                        fileToProcess = new File([convertedFile], pngFile.name.replace(/\.(heic|heif)$/i, '.jpg'), { 
                            type: 'image/jpeg' 
                        });
                        showStatus('success', 'HEIC image converted successfully');
                    } catch (error) {
                        console.error('HEIC conversion error:', error);
                        showStatus('error', 'Failed to convert HEIC image. Please try a different format.');
                        return;
                    }
                }
                
                // Load image and show preview
                const reader = new FileReader();
                reader.onload = async (event) => {
                    const img = new Image();
                    img.onload = async () => {
                        rawUploadedImage = img; // Store raw image for editor
                        fullOriginalImage = img; // Store full original uncropped image
                        cropCoordinates = null; // Reset crop coordinates when new image is uploaded
                        
                        // Reset cropper state when new image is uploaded
                        fullProcessedImageDataURL = null;
                        cropperVisible = false;
                        cropperManuallyHidden = false; // Reset flag for new image
                        cropInitialized = false;
                        const previewImg = document.getElementById('png-preview-img');
                        if (previewImg) {
                            previewImg.removeAttribute('data-cropper-fixed');
                        }
                        document.getElementById('png-preview').style.display = 'none';
                        document.getElementById('crop-canvas').style.display = 'none';
                        document.getElementById('show-cropper-btn').style.display = 'block';
                        document.getElementById('hide-cropper-btn').style.display = 'none';
                        
                        // Auto-tune settings per new image
                        autoTuneSettingsFromImage(img);
                        // Update sliders/labels
                        document.getElementById('contrast-slider').value = String(editorSettings.contrast);
                        document.getElementById('brightness-slider').value = String(editorSettings.brightness);
                        document.getElementById('contrast-value').textContent = editorSettings.contrast.toFixed(1);
                        document.getElementById('brightness-value').textContent = editorSettings.brightness.toFixed(1);
                        // Don't set preview image here - it will be set to processed version after processImage() runs
                        // document.getElementById('png-preview-img').src = event.target.result;
                        // Show crop buttons when image is uploaded
                        document.getElementById('crop-buttons').style.display = 'block';
                        // Don't show preview automatically - only show when "Show Cropper" is clicked
                        // document.getElementById('png-preview').style.display = 'block';
                        
                        // Hide initial upload box and show all controls
                        const initialUploadBox = document.getElementById('initial-upload-box');
                        if (initialUploadBox) {
                            initialUploadBox.style.display = 'none';
                        }
                        
                        // Show action buttons
                        const actionButtonsContainer = document.getElementById('action-buttons-container');
                        if (actionButtonsContainer) {
                            actionButtonsContainer.style.display = 'flex';
                        }
                        
                        // Show price section
                        const priceSection = document.getElementById('price-display-section');
                        if (priceSection) {
                            priceSection.style.display = 'block';
                            // Update price immediately when section becomes visible
                            updatePriceDisplay();
                        }
                        
                        // Load STL for the selected grid size
                        await loadSTLFromServer(selectedGridSize);
                        
                        // Ensure editor is visible so user can adjust before mapping
                        showEditorPanel();
                        processImage();
                        
                        // Open size panel and show cropper when image is first uploaded
                        setTimeout(() => {
                            // Open size panel
                            document.getElementById('adjust-panel').classList.remove('active');
                            document.getElementById('size-panel').classList.add('active');
                            document.getElementById('paint-panel').classList.remove('active');
                            document.getElementById('adjust-btn').classList.remove('active');
                            document.getElementById('size-btn').classList.add('active');
                            document.getElementById('paint-btn').classList.remove('active');
                            
                            // Make sure upload panel is visible for cropper
                            const uploadPanel = document.getElementById('upload-panel');
                            if (uploadPanel) {
                                uploadPanel.style.display = 'block';
                                // Hide upload area and label, keep only cropper visible
                                const uploadArea = document.getElementById('png-upload-area');
                                const sectionLabel = uploadPanel.querySelector('.section-label');
                                if (uploadArea) uploadArea.style.display = 'none';
                                if (sectionLabel) sectionLabel.style.display = 'none';
                                // Show crop buttons
                                const cropButtons = document.getElementById('crop-buttons');
                                if (cropButtons) {
                                    cropButtons.style.display = 'block';
                                }
                            }
                            
                            // Show cropper
                            if (!cropperManuallyHidden) {
                                showCropper();
                            }
                        }, 200);

                        // Persist converted file to IndexedDB for current grid size
                        saveFileToDB(dbKey('png'), fileToProcess);
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(fileToProcess);
            }
        });


        // TEST: Add to Cart / Purchase button - Creates order without redirecting
        document.getElementById('add-to-cart-btn').addEventListener('click', async () => {
            if (!stlFile || !pngFile) {
                alert('Please upload both STL and PNG files first');
                return;
            }

            console.log('TEST: Creating order...');
            const btn = document.getElementById('add-to-cart-btn');
            btn.disabled = true;
            btn.textContent = 'Processing...';

            try {
                // Get the processed image from the canvas (matches what user sees)
                let processedPngFile = pngFile;
                const processedCanvas = document.getElementById('processed-canvas');
                if (processedCanvas && processedCanvas.width > 0) {
                    // Create a canvas at the exact grid size
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = selectedGridSize;
                    tempCanvas.height = selectedGridSize;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // Draw the processed canvas to the temp canvas at exact size
                    tempCtx.imageSmoothingEnabled = false;
                    tempCtx.drawImage(processedCanvas, 0, 0, selectedGridSize, selectedGridSize);
                    
                    // Convert to blob/file
                    await new Promise((resolve) => {
                        tempCanvas.toBlob((blob) => {
                            if (blob) {
                                processedPngFile = new File([blob], 'processed.png', { type: 'image/png' });
                            }
                            resolve();
                        }, 'image/png');
                    });
                }
                
                // Generate and upload file for checkout
                const formData = new FormData();
                formData.append('stl', stlFile);
                formData.append('png', processedPngFile);
                formData.append('grid_size', String(selectedGridSize));
                formData.append('stand_selected', String(standSelected));
                formData.append('mounting_selected', String(selectedAddons.mounting));
                
                // Calculate total price
                let totalPrice = 0;
                if (prices && prices[`${selectedGridSize}x${selectedGridSize}`]) {
                    totalPrice += prices[`${selectedGridSize}x${selectedGridSize}`];
                }
                if (standSelected && prices && prices.stand) {
                    totalPrice += prices.stand;
                }
                if (selectedAddons.mounting && prices && prices.wall_mounting_dots) {
                    totalPrice += prices.wall_mounting_dots;
                }
                formData.append('total_price', String(totalPrice));

                const response = await fetch('/upload-for-checkout', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const error = await response.json().catch(() => ({ error: 'Failed to create order' }));
                    throw new Error(error.error || 'Failed to create order');
                }

                const result = await response.json();
                const orderId = result.order_id;
                
                console.log('TEST: Order created:', orderId);
                alert(`‚úÖ TEST ORDER CREATED!\n\nOrder ID: ${orderId.substring(0, 8)}\nTotal: $${totalPrice.toFixed(2)}\n\nCheck the Admin Orders tab to see it!`);
                
                btn.textContent = 'ADD TO CART';
                btn.disabled = false;

            } catch (error) {
                console.error('TEST: Order creation error:', error);
                alert(`‚ùå Error: ${error.message}`);
                btn.textContent = 'ADD TO CART';
                btn.disabled = false;
            }
        });

        // Buy Now - Generate file and redirect to Shopify
        document.getElementById('buy-now-btn').addEventListener('click', async () => {
            if (!stlFile || !pngFile) return;

            console.log('Proceeding to checkout...');
            showStatus('loading', '<span class="spinner"></span>Preparing your order...');
            document.getElementById('buy-now-btn').disabled = true;

            try {
                // Get the processed image from the canvas (matches what user sees)
                let processedPngFile = pngFile;
                const processedCanvas = document.getElementById('processed-canvas');
                if (processedCanvas && processedCanvas.width > 0) {
                    // Create a canvas at the exact grid size
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = selectedGridSize;
                    tempCanvas.height = selectedGridSize;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // Draw the processed canvas to the temp canvas at exact size
                    tempCtx.imageSmoothingEnabled = false;
                    tempCtx.drawImage(processedCanvas, 0, 0, selectedGridSize, selectedGridSize);
                    
                    // Convert to blob/file
                    await new Promise((resolve) => {
                        tempCanvas.toBlob((blob) => {
                            if (blob) {
                                processedPngFile = new File([blob], 'processed.png', { type: 'image/png' });
                            }
                            resolve();
                        }, 'image/png');
                    });
                }
                
                // Generate and upload file for checkout
                const formData = new FormData();
                formData.append('stl', stlFile);
                formData.append('png', processedPngFile);
                formData.append('grid_size', String(selectedGridSize));
                formData.append('stand_selected', String(standSelected));
                formData.append('mounting_selected', String(selectedAddons.mounting));
                
                // Calculate total price
                let totalPrice = 0;
                if (prices && prices[`${selectedGridSize}x${selectedGridSize}`]) {
                    totalPrice += prices[`${selectedGridSize}x${selectedGridSize}`];
                }
                if (standSelected && prices && prices.stand) {
                    totalPrice += prices.stand;
                }
                if (selectedAddons.mounting && prices && prices.wall_mounting_dots) {
                    totalPrice += prices.wall_mounting_dots;
                }
                formData.append('total_price', String(totalPrice));

                const response = await fetch('/upload-for-checkout', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const error = await response.json().catch(() => ({ error: 'Failed to prepare order' }));
                    throw new Error(error.error || 'Failed to prepare order');
                }

                const result = await response.json();
                const orderId = result.order_id;
                
                console.log('Order ID:', orderId);
                
                // Redirect to Shopify with order ID as parameter
                const shopifyUrl = `${SHOPIFY_PRODUCT_URL}?order_id=${orderId}`;
                window.location.href = shopifyUrl;

            } catch (error) {
                console.error('Checkout error:', error);
                showStatus('error', `‚ùå Error: ${error.message}`);
                document.getElementById('buy-now-btn').disabled = false;
            }
        });

        function showStatus(type, message) {
            const statusMessage = document.getElementById('status-message');
            statusMessage.className = `status-message ${type}`;
            statusMessage.innerHTML = message;
            statusMessage.style.display = 'block';

            if (type === 'success') {
                setTimeout(() => {
                    statusMessage.style.display = 'none';
                }, 5000);
            }
        }

        // Initialize Three.js when page loads
        window.addEventListener('load', initThree);
        
        // Ensure page starts at top on initial load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                window.scrollTo(0, 0);
                document.documentElement.scrollTop = 0;
                document.body.scrollTop = 0;
            });
        } else {
            window.scrollTo(0, 0);
            document.documentElement.scrollTop = 0;
            document.body.scrollTop = 0;
        }

        // Restore state and files on load; start with editor visible
        window.addEventListener('load', async () => {
            // Ensure page starts at the top
            window.scrollTo(0, 0);
            document.documentElement.scrollTop = 0;
            document.body.scrollTop = 0;
            
            loadSimpleState();

            // Reflect selected grid size buttons
            document.querySelectorAll('.grid-btn').forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.dataset.size) === selectedGridSize) {
                    btn.classList.add('active');
                }
            });
            document.getElementById('png-upload-subtext').textContent = `Will be resized to ${selectedGridSize}√ó${selectedGridSize} pixels`;

            // Load prices from API first
            await loadPrices();
            
            // Reload images again after prices load to ensure they're displayed
            setTimeout(() => {
                loadImages().then(() => {
                    updateProductImages();
                });
            }, 200);
            
            // Automatically select 75√ó75 and update price
            selectGridSize(75);
            
            // Force multiple price updates to ensure it displays
            setTimeout(() => updatePriceDisplay(), 50);
            setTimeout(() => updatePriceDisplay(), 200);
            setTimeout(() => updatePriceDisplay(), 500);

            // Restore any files for the selected size
            await restoreForSize(selectedGridSize);
            
            // Only show editor and controls if image was already uploaded
            if (rawUploadedImage) {
                // Hide initial upload box and show all controls
                const initialUploadBox = document.getElementById('initial-upload-box');
                if (initialUploadBox) {
                    initialUploadBox.style.display = 'none';
                }
                
                // Show action buttons
                const actionButtonsContainer = document.getElementById('action-buttons-container');
                if (actionButtonsContainer) {
                    actionButtonsContainer.style.display = 'flex';
                }
                
                // Show price section
                const priceSection = document.getElementById('price-display-section');
                if (priceSection) {
                    priceSection.style.display = 'block';
                }
                
                showEditorPanel();
            } else {
                // Ensure initial upload box is visible
                const initialUploadBox = document.getElementById('initial-upload-box');
                if (initialUploadBox) {
                    initialUploadBox.style.display = 'block';
                }
                
                // Ensure action buttons are hidden
                const actionButtonsContainer = document.getElementById('action-buttons-container');
                if (actionButtonsContainer) {
                    actionButtonsContainer.style.display = 'none';
                }
                
                // Ensure price section is hidden
                const priceSection = document.getElementById('price-display-section');
                if (priceSection) {
                    priceSection.style.display = 'none';
                }
            }
            
            // Load STL for selected grid size
            await loadSTLFromServer(selectedGridSize);
            
            // Only show panels if image is uploaded
            if (rawUploadedImage) {
                // Hide all panels by default
                document.getElementById('adjust-panel').classList.remove('active');
                document.getElementById('size-panel').classList.remove('active');
                document.getElementById('paint-panel').classList.remove('active');
                document.getElementById('adjust-btn').classList.remove('active');
                document.getElementById('size-btn').classList.remove('active');
                document.getElementById('paint-btn').classList.remove('active');
                
                // Open size panel by default
                document.getElementById('size-panel').classList.add('active');
                document.getElementById('size-btn').classList.add('active');
                
                // Show cropper if image is uploaded (always show when size panel is open)
                setTimeout(() => {
                    // Make sure upload panel is visible for cropper
                    const uploadPanel = document.getElementById('upload-panel');
                    if (uploadPanel) {
                        uploadPanel.style.display = 'block';
                        // Hide upload area and label, keep only cropper visible
                        const uploadArea = document.getElementById('png-upload-area');
                        const sectionLabel = uploadPanel.querySelector('.section-label');
                        if (uploadArea) uploadArea.style.display = 'none';
                        if (sectionLabel) sectionLabel.style.display = 'none';
                        // Show crop buttons
                        const cropButtons = document.getElementById('crop-buttons');
                        if (cropButtons) {
                            cropButtons.style.display = 'block';
                        }
                        
                        // Show cropper
                        if (!cropperManuallyHidden) {
                            showCropper();
                        }
                    }
                }, 200);
            }
            
            // Setup paint handlers after everything is loaded
            setTimeout(() => {
                setupPaintHandlers();
            }, 500);
        });
    </script>
</body>
</html>
