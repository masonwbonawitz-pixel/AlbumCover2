<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Album Cover Mosaic Builder</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
            background: #FFFBF5;
            min-height: 100vh;
            overflow-x: hidden;
            margin: 0;
            padding: 0;
        }

        html {
            overflow-x: hidden;
        }

        .main-container {
            display: flex;
            height: 100vh;
            max-width: 100vw;
            overflow-x: hidden;
            margin: 0 auto;
        }

        /* Left Panel - 3D Viewer */
        .viewer-panel {
            flex: 1;
            min-width: 0;
            background: #FFFBF5;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        @media (max-width: 1024px) {
            .viewer-panel.hidden-on-mobile {
                display: none !important;
            }
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: #FFF8F0;
            border-right: 1px solid #e0e0e0;
            min-height: 600px; /* ensure visible height when shown */
        }

        #canvas-container canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        /* Inline editor panel that replaces the 3D view initially */
        #editor-panel {
            flex: 1;
            padding: 20px 24px;
            overflow-y: auto;
            overflow-x: hidden;
            background: #FFFBF5;
            min-width: 0;
            max-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        @media (max-width: 1024px) {
            #editor-panel {
                max-height: none !important;
                overflow-y: visible !important;
                overflow-x: visible !important;
                height: auto !important;
                flex: none !important;
                position: relative !important;
            }
            
            .viewer-panel {
                overflow: visible !important;
                height: auto !important;
                max-height: none !important;
                position: relative !important;
            }
            
            .main-container {
                overflow: visible !important;
                height: auto !important;
            }
        }

        .viewer-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .viewer-btn {
            background: #E0E0E0;
            border: 1px solid #333333;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            box-shadow: none;
            font-size: 14px;
            transition: all 0.2s;
            font-weight: normal;
            color: #333333;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .viewer-btn:hover {
            background: #d0d0d0;
        }

        .viewer-btn.icon-only {
            padding: 10px;
            font-size: 18px;
        }

        .placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #333333;
            font-size: 16px;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .placeholder-icon {
            font-size: 80px;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        /* Right Panel - Controls */
        .control-panel {
            flex: 0 0 450px;
            min-width: 450px;
            background: #FFFBF5;
            padding: 40px;
            overflow-y: auto;
            overflow-x: hidden;
            border-left: 1px solid #e0e0e0;
        }

        .title {
            font-size: 32px;
            font-weight: normal;
            margin-bottom: 10px;
            color: #E87D3E;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .price {
            font-size: 20px;
            color: #333333;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e0e0e0;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .section {
            margin-bottom: 30px;
        }

        .section-label {
            font-size: 13px;
            font-weight: normal;
            color: #FF6B35;
            margin-bottom: 12px;
            text-transform: none;
            letter-spacing: 0;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .upload-area {
            border: 2px dashed #ddd;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #fafafa;
            margin-bottom: 15px;
        }

        .upload-area:hover {
            border-color: #999;
            background: #f5f5f5;
        }

        .upload-area.has-file {
            border-color: #999;
            background: #f5f5f5;
        }

        .upload-icon {
            font-size: 40px;
            margin-bottom: 10px;
            opacity: 0.5;
        }

        .upload-text {
            font-size: 14px;
            color: #333333;
            margin-bottom: 5px;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .upload-subtext {
            font-size: 12px;
            color: #333333;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .file-input {
            display: none;
        }

        .grid-options {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .grid-btn {
            flex: 1;
            padding: 12px;
            border: 1px solid #333333;
            background: #E0E0E0;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: normal;
            color: #333333;
            transition: all 0.2s;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .grid-btn.active {
            background: #333333;
            color: #FFFFFF;
            border-color: #333333;
        }

        .grid-btn:hover:not(.active) {
            background: #d0d0d0;
        }

        .color-palette {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .color-swatch {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: transform 0.2s;
            position: relative;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .color-swatch.selected {
            border: 3px solid #333333;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #333333;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 30px;
        }

        .btn {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid #333333;
            border-radius: 6px;
            font-size: 14px;
            font-weight: normal;
            cursor: pointer;
            transition: all 0.2s;
            background: #E0E0E0;
            color: #333333;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .btn-primary {
            background: #333333;
            color: #FFFFFF;
            border: 1px solid #333333;
        }

        .btn-primary:hover:not(:disabled) {
            background: #444444;
        }

        .btn-secondary {
            background: #333333;
            color: #FFFFFF;
            border: 1px solid #333333;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #444444;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .status-message {
            margin-top: 20px;
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            display: none;
        }

        .status-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-message.loading {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 3px solid rgba(0,0,0,0.1);
            border-radius: 50%;
            border-top-color: #0c5460;
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .info-box {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            font-size: 13px;
            color: #856404;
        }

        .info-box strong {
            display: block;
            margin-bottom: 5px;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            flex-shrink: 0;
        }

        .panel-title {
            font-size: 24px;
            font-weight: normal;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
            color: #E87D3E;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #999;
        }

        .close-btn:hover {
            color: #333;
        }

        .editor-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 20px;
        }

        .canvas-wrapper {
            text-align: center;
            flex-shrink: 0;
            margin-bottom: 20px;
        }

        .canvas-label {
            font-size: 14px;
            font-weight: normal;
            margin-bottom: 10px;
            color: #E87D3E;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .editor-canvas {
            max-width: 100%;
            width: 100%;
            aspect-ratio: 1 / 1; /* keep preview perfectly square */
            height: auto;
            border-radius: 10px;
            border: 2px solid #ddd;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            background: #ffffff !important;
            display: block;
            margin: 0 auto;
        }

        #png-preview img { background: #ffffff !important; }

        .slider-control {
            margin-bottom: 20px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: normal;
            color: #333333;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: black;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: black;
            cursor: pointer;
            border: none;
        }

        .editor-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            flex-shrink: 0;
            margin-top: auto;
        }
        
        .editor-actions .btn {
            flex: 0 0 auto;
            width: auto;
            min-width: auto;
            padding: 12px 20px;
        }

        @media (max-width: 1024px) {
            body {
                background: #FFFBF5;
                overflow-x: hidden;
            }

            .main-container {
                flex-direction: column;
                height: auto;
                min-height: 100vh;
                display: block !important;
                position: relative !important;
            }
            
            .viewer-panel.hidden-on-mobile {
                display: none !important;
            }
            
            .viewer-panel:not(.hidden-on-mobile) {
                position: static !important;
                height: auto !important;
                overflow: visible !important;
                max-height: none !important;
            }
            
            /* Move editor panel content to control panel flow - break out of viewer-panel */
            .viewer-panel #editor-panel {
                display: block !important;
                position: static !important;
                width: 100% !important;
                padding: 20px !important;
                margin: 0 !important;
                visibility: visible !important;
            }
            

            .control-panel {
                width: 100%;
                background: #FFFBF5;
                overflow-y: visible;
                overflow-x: hidden;
                height: auto;
                scroll-behavior: smooth;
            }
            
            /* Ensure smooth continuous scrolling without stopping */
            body, html {
                scroll-behavior: smooth;
                -webkit-overflow-scrolling: touch;
            }
            
            /* Remove any scroll snap that might cause stopping */
            * {
                scroll-snap-type: none;
                scroll-padding: 0;
                scroll-margin: 0;
            }

            #canvas-container {
                height: 400px;
            }

            .editor-grid {
                grid-template-columns: 1fr;
            }

            /* Ensure image preview stays with upload area */
            #png-preview {
                position: relative !important;
                margin-top: 20px;
            }
            
            /* Hide png-preview when crop panel is active */
            #crop-panel:not([style*="display: none"]) ~ * #png-preview,
            body:has(#crop-panel:not([style*="display: none"])) #png-preview {
                display: none !important;
                visibility: hidden !important;
            }

            #crop-container {
                position: relative !important;
                width: 100% !important;
                max-width: 100% !important;
            }

            #png-preview-img {
                position: relative !important;
                width: 100% !important;
                max-width: 100% !important;
            }

            /* Hide viewer panel initially on mobile - show only upload section */
            .viewer-panel.hidden-on-mobile {
                display: none !important;
            }

            /* Bottom Navigation Bar */
            .bottom-nav {
                position: relative;
                background: #FFFBF5;
                border-top: 1px solid #e0e0e0;
                border-bottom: 1px solid #e0e0e0;
                display: flex;
                justify-content: space-around;
                align-items: center;
                padding: 12px 0;
                margin-top: 20px;
                box-shadow: none;
                height: auto;
                min-height: 60px;
            }

            .nav-btn {
                flex: 1;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                gap: 6px;
                padding: 8px 4px;
                background: none;
                border: none;
                cursor: pointer;
                color: #999;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                font-size: 12px;
                transition: all 0.2s;
                position: relative;
            }

            .nav-btn.active {
                color: #333;
                font-weight: 500;
            }

            .nav-btn.active::after {
                content: '';
                position: absolute;
                bottom: 0;
                left: 50%;
                transform: translateX(-50%);
                width: 30px;
                height: 2px;
                background: #333;
                border-radius: 1px;
            }

            .nav-btn.active .nav-icon {
                color: #333;
            }

            .nav-icon {
                font-size: 22px;
                line-height: 1;
                color: #999;
                font-weight: normal;
            }

            .nav-btn.active .nav-icon {
                color: #333;
            }

            .nav-label {
                font-size: 11px;
                font-weight: normal;
                color: inherit;
            }

            /* No extra padding needed since nav is now in flow */
            .control-panel {
                padding-bottom: 20px;
            }

            /* Toggle Switch Styling */
            #stand-toggle + span,
            #addon-mounting-toggle + span {
                background-color: #ccc;
            }

            #stand-toggle:checked + span,
            #addon-mounting-toggle:checked + span {
                background-color: #2d5016;
            }

            #stand-toggle + span:before,
            #addon-mounting-toggle + span:before {
                content: "";
                position: absolute;
                height: 18px;
                width: 18px;
                left: 3px;
                bottom: 3px;
                background-color: white;
                border-radius: 50%;
                transition: .4s;
            }

            #stand-toggle:checked + span:before,
            #addon-mounting-toggle:checked + span:before {
                content: "";
                position: absolute;
                height: 18px;
                width: 18px;
                left: 3px;
                bottom: 3px;
                background-color: white;
                border-radius: 50%;
                transition: .4s;
                transform: translateX(20px);
            }

            /* Mobile panel styling - Appears below image in normal flow */
            .mobile-panel {
                position: relative;
                width: 100%;
                background: #FFFBF5;
                padding: 0px 20px 15px 20px;
                margin-top: -40px;
                border-top: 1px solid #e0e0e0;
                margin-bottom: 10px;
                clear: both;
            }
            
            /* Ensure image preview has proper spacing */
            #png-preview {
                margin-bottom: 0;
            }
            
            /* Reduce spacing between button and panels */
            .canvas-wrapper {
                margin-bottom: 0 !important;
            }
            
            /* Target the gap between editor panel and mobile panels */
            #editor-panel {
                margin-bottom: 0 !important;
                padding-bottom: 0 !important;
            }
            
            #editor-panel .editor-grid {
                margin-bottom: 0 !important;
            }
            
            #editor-panel .canvas-wrapper {
                margin-bottom: 0 !important;
            }
            
            /* Ensure smooth scrolling */
            html {
                scroll-behavior: smooth;
            }
            
            /* Prevent content from hiding under bottom nav */
            body {
                padding-bottom: 0;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Left Panel: Editor (initial) and 3D Viewer -->
        <div class="viewer-panel hidden-on-mobile">
            <!-- Inline Editor Panel (hidden initially on mobile) -->
            <div id="editor-panel" style="display: none;">
                <div class="panel-header">
                    <h2 class="panel-title">Edit Your Photo</h2>
                    <button class="viewer-btn" onclick="show3DView()">View in 3D</button>
                </div>
                <div class="editor-grid" style="margin-top:8px;">
                    <div class="canvas-wrapper">
                        <div class="canvas-label">Processed (Posterized)</div>
                        <div style="position: relative; display: inline-block; width: 100%;">
                            <canvas id="processed-canvas" class="editor-canvas" style="max-width:100%; width:100%; aspect-ratio:1/1; cursor: crosshair;"></canvas>
                            <div style="position: absolute; top: 10px; right: 10px; display: flex; flex-direction: column; gap: 5px; z-index: 20;">
                                <button class="btn" onclick="zoomInProcessed()" style="padding: 8px 12px; font-size: 14px; background: #E0E0E0; border: 1px solid #333333; border-radius: 6px; cursor: pointer; box-shadow: none; color: #333333;" title="Zoom In">+</button>
                                <button class="btn" onclick="zoomOutProcessed()" style="padding: 8px 12px; font-size: 14px; background: #E0E0E0; border: 1px solid #333333; border-radius: 6px; cursor: pointer; box-shadow: none; color: #333333;" title="Zoom Out">‚àí</button>
                                <button class="btn" onclick="resetZoomProcessed()" style="padding: 8px 12px; font-size: 14px; background: #E0E0E0; border: 1px solid #333333; border-radius: 6px; cursor: pointer; box-shadow: none; color: #333333;" title="Reset View">‚ñ°</button>
                                <button class="btn" onclick="togglePanProcessed()" id="processed-pan-btn" style="padding: 8px 12px; font-size: 14px; background: #E0E0E0; border: 1px solid #333333; border-radius: 6px; cursor: pointer; box-shadow: none; color: #333333;" title="Pan">‚§°</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 3D Viewer (hidden initially) -->
            <div id="canvas-container" style="display:none;">
                <div class="viewer-controls">
                    <button class="viewer-btn" onclick="showEditorPanel()" id="edit-photo-btn">Edit Photo</button>
                    <button class="viewer-btn icon-only" onclick="resetCamera()" title="Reset View">‚Ü∫</button>
                    <button class="viewer-btn icon-only" onclick="toggleWireframe()" title="Toggle Wireframe">‚ñ°</button>
                </div>
                <div id="three-placeholder" class="placeholder">
                    <div class="placeholder-icon">‚ñ°</div>
                    <div>Upload an STL file to preview your 3D model</div>
                </div>
            </div>
        </div>

        <!-- Right Panel: Controls -->
        <div class="control-panel">
            <h1 class="title">Custom Mosaic Builder</h1>
            
            <!-- Upload PNG - Simple and Prominent -->
            <div class="section" style="margin-top: 30px;">
                <div class="upload-area" id="png-upload-area" onclick="document.getElementById('png-input').click()" style="padding: 60px 30px; min-height: 200px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                    <div class="upload-icon" style="font-size: 60px; margin-bottom: 20px;">‚¨ÜÔ∏è</div>
                    <div class="upload-text" id="png-upload-text" style="font-size: 18px; font-weight: 500; margin-bottom: 10px;">Upload an image to convert to brick art</div>
                    <div class="upload-subtext" id="png-upload-subtext" style="font-size: 14px; color: #999;">Will be initially set to 75√ó75</div>
                </div>
                <input type="file" id="png-input" class="file-input" accept=".png,.jpg,.jpeg,.heic,.heif" />
                
                <!-- PNG Preview with Crop Tool - Right below upload area -->
                <div id="png-preview" style="display: none; text-align: center; margin-top: 20px; width: 100%;">
                    <div id="crop-container" style="position: relative; display: inline-block; max-width: 100%; width: 100%;">
                        <img id="png-preview-img" style="width: 100%; max-width: 100%; height: auto; aspect-ratio: 1 / 1; object-fit: contain; border-radius: 8px; border: 2px solid #ddd; display: block;" />
                        <canvas id="crop-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: auto; display: none; border: none; background: transparent; z-index: 10;"></canvas>
                    </div>
                </div>
        </div>

            <!-- Panel: Crop - Moved to bottom panels -->
            <div id="crop-panel" class="mobile-panel" style="display: none;">
                <div class="section">
                    <div class="section-label">Crop Image</div>
                    <!-- Cropper tool in crop panel -->
                    <div id="crop-panel-preview" style="display: none; text-align: center; margin-top: 20px; width: 100%;">
                        <div id="crop-panel-container" style="position: relative; display: inline-block; max-width: 100%; width: 100%;">
                            <img id="crop-panel-img" style="width: 100%; max-width: 100%; height: auto; aspect-ratio: 1 / 1; object-fit: contain; border-radius: 8px; border: 2px solid #ddd; display: block;" />
                            <canvas id="crop-panel-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: auto; display: block; border: none; background: transparent; z-index: 10;"></canvas>
                        </div>
                    </div>
                    <div id="crop-panel-placeholder" style="text-align: center; color: #666; margin-top: 20px; font-size: 14px;">
                        Upload an image first to use the cropper
                    </div>
                </div>
            </div>

            <!-- Panel: Size (includes cropper) -->
            <div id="size-panel" class="mobile-panel" style="display: none;">
                <div class="section">
                    <div class="section-label" style="display: flex; justify-content: space-between; align-items: center;">
                        <span>Crop Image</span>
                        <div id="size-panel-crop-buttons" style="display: none;">
                            <button class="btn" onclick="hideSizePanelCropper()" id="size-panel-hide-btn" style="padding: 6px 12px; font-size: 12px; margin-left: 10px;">Hide Cropper</button>
                            <button class="btn" onclick="showSizePanelCropper()" id="size-panel-show-btn" style="padding: 6px 12px; font-size: 12px; margin-left: 10px; display: none;">Show Cropper</button>
                        </div>
                    </div>
                    <!-- Cropper tool in size panel -->
                    <div id="size-panel-preview" style="display: none; text-align: center; margin-top: 20px; width: 100%;">
                        <div id="size-panel-container" style="position: relative; display: inline-block; width: 400px; max-width: 100%;">
                            <img id="size-panel-img" style="width: 400px; height: 400px; max-width: 100%; object-fit: contain; border-radius: 8px; border: 2px solid #ddd; display: block;" />
                            <canvas id="size-panel-canvas" style="position: absolute; top: 0; left: 0; width: 400px; height: 400px; max-width: 100%; pointer-events: auto; display: block; border: none; background: transparent; z-index: 10;"></canvas>
                        </div>
                    </div>
                    <div id="size-panel-placeholder" style="text-align: center; color: #666; margin-top: 20px; font-size: 14px;">
                        Upload an image first to use the cropper
                    </div>
                </div>
                <div class="section" style="margin-top: 20px;">
                    <div class="section-label">Select Grid Size</div>
                    <div class="grid-options">
                        <button class="grid-btn" data-size="48" onclick="selectGridSize(48)">48 √ó 48</button>
                        <button class="grid-btn active" data-size="75" onclick="selectGridSize(75)">75 √ó 75</button>
                        <button class="grid-btn" data-size="96" onclick="selectGridSize(96)">96 √ó 96</button>
                    </div>
                </div>
            </div>
            
            <!-- Panel: Upload -->
            <div id="upload-panel" class="mobile-panel" style="display: none;">
                <div class="section">
                    <div class="section-label">Upload Image</div>
                    <div class="upload-area" id="upload-panel-upload-area" onclick="document.getElementById('png-input').click()" style="padding: 60px 30px; min-height: 200px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                        <div class="upload-icon" style="font-size: 60px; margin-bottom: 20px;">‚¨ÜÔ∏è</div>
                        <div class="upload-text" style="font-size: 18px; font-weight: 500; margin-bottom: 10px;">Upload an image to convert to brick art</div>
                        <div class="upload-subtext" style="font-size: 14px; color: #999;">Will be initially set to 75√ó75</div>
                    </div>
                </div>
            </div>

            <!-- STL Model - Shown when auto-load fails or always visible as fallback -->
            <div class="section" id="stl-section" style="display: block;">
                <div class="section-label">STL Model</div>
                <div class="upload-area" id="stl-upload-area" onclick="document.getElementById('stl-input').click()">
                    <div class="upload-icon">üì¶</div>
                    <div class="upload-text" id="stl-upload-text">Choose STL file...</div>
                    <div class="upload-subtext" id="stl-upload-subtext">Upload your grid STL file (48√ó48, 75√ó75, or 96√ó96)</div>
                </div>
                <input type="file" id="stl-input" class="file-input" accept=".stl" style="display: none;" />
            </div>

            <!-- Panel: Adjust -->
            <div id="adjust-panel" class="mobile-panel" style="display: none;">
                <div class="section">
                    <div class="section-label">Image Adjustments</div>
                    <div class="slider-control">
                        <div class="slider-label">
                            <span>Contrast</span>
                            <span id="contrast-value">1.2</span>
                        </div>
                        <input type="range" class="slider" id="contrast-slider" min="0.5" max="2" step="0.1" value="1.2" />
                    </div>
                    <div class="slider-control">
                        <div class="slider-label">
                            <span>Brightness</span>
                            <span id="brightness-value">1.0</span>
                        </div>
                        <input type="range" class="slider" id="brightness-slider" min="0.5" max="1.5" step="0.1" value="1.0" />
                    </div>
                    <div class="slider-control">
                        <div class="slider-label">
                            <span>Tones</span>
                            <span id="tones-value">4</span>
                        </div>
                        <input type="range" class="slider" id="tones-slider" min="2" max="4" step="1" value="4" />
                    </div>
                </div>
            </div>

            <!-- Panel: Paint -->
            <div id="paint-panel" class="mobile-panel" style="display: none;">
                <div class="section">
                    <div class="section-label">Painting</div>
                    <div class="color-palette">
                        <div class="color-swatch selected" data-color="0,0,0" style="background: rgb(0,0,0);" title="Black" onclick="selectPaintColor(0, 0, 0, this)"></div>
                        <div class="color-swatch" data-color="85,85,85" style="background: rgb(85,85,85);" title="Dark Gray" onclick="selectPaintColor(85, 85, 85, this)"></div>
                        <div class="color-swatch" data-color="170,170,170" style="background: rgb(170,170,170);" title="Light Gray" onclick="selectPaintColor(170, 170, 170, this)"></div>
                        <div class="color-swatch" data-color="255,255,255" style="background: rgb(255,255,255);" title="White" onclick="selectPaintColor(255, 255, 255, this)"></div>
                    </div>
                    <div class="slider-control" style="margin-top: 15px;">
                        <div class="slider-label">
                            <span>Brush Size</span>
                            <span id="brush-size-value">1</span>
                        </div>
                        <input type="range" class="slider" id="brush-size-slider" min="1" max="10" step="1" value="1" />
                    </div>
                    <div id="undo-redo-buttons" style="display: none; margin-top: 15px; gap: 10px;" class="action-buttons">
                        <button class="btn" id="undo-btn" onclick="undoPaint()" style="flex: 1; background: #E0E0E0; color: #333333; border: 1px solid #333333;" disabled>‚Üê Undo</button>
                        <button class="btn" id="redo-btn" onclick="redoPaint()" style="flex: 1; background: #E0E0E0; color: #333333; border: 1px solid #333333;" disabled>Redo ‚Üí</button>
                    </div>
                    <button class="btn" onclick="resetProcessedImage()" style="width: 100%; margin-top: 10px; background: #E0E0E0; color: #333333; border: 1px solid #333333;">
                        Reset Image
                    </button>
                </div>
            </div>

            <!-- Action Buttons - Hidden initially, shown after image upload -->

            <!-- Status Message -->
        <div class="status-message" id="status-message"></div>

        <!-- Bottom Navigation Bar (Mobile) - Now in scrollable content flow -->
        <div id="bottom-nav" class="bottom-nav">
            <button class="nav-btn" onclick="showMobilePanel('upload')" id="nav-upload">
                <span class="nav-icon">‚Üë</span>
                <span class="nav-label">Upload</span>
            </button>
            <button class="nav-btn" onclick="showMobilePanel('size')" id="nav-size">
                <span class="nav-icon">‚ñ¢</span>
                <span class="nav-label">Size</span>
            </button>
            <button class="nav-btn" onclick="showMobilePanel('adjust')" id="nav-adjust">
                <span class="nav-icon">‚â°</span>
                <span class="nav-label">Adjust</span>
            </button>
            <button class="nav-btn" onclick="showMobilePanel('paint')" id="nav-paint">
                <span class="nav-icon">‚úé</span>
                <span class="nav-label">Paint</span>
            </button>
        </div>

        <!-- Price Display Section -->
        <div id="price-display-section" style="padding: 20px; margin-top: 20px; background: transparent;">
            <div style="margin-bottom: 15px;">
                <div id="main-price" style="font-size: 24px; font-weight: 600; color: #333; margin-bottom: 5px;">$119.99</div>
                <div id="price-details" style="font-size: 12px; color: #666; line-height: 1.5;">
                    <div>Dimensions: <span id="price-dimensions">75 √ó 75</span></div>
                    <div>Addons: <span id="breakdown-addons">Stand</span></div>
                </div>
            </div>
            
            <!-- Stand Toggle -->
            <div id="stand-section" style="margin-top: 20px;">
                <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: #f9f9f9; border-radius: 6px;">
                    <div style="display: flex; align-items: center; flex: 1;">
                        <img id="stand-image" src="" alt="Stand" style="width: 40px; height: 40px; object-fit: cover; border-radius: 4px; margin-right: 12px; display: none;">
                        <div style="flex: 1;">
                            <div style="font-size: 14px; font-weight: 500; color: #333;">Stand</div>
                            <div id="stand-price-display" style="font-size: 12px; color: #666;">$10.00</div>
                        </div>
                    </div>
                    <label style="position: relative; display: inline-block; width: 44px; height: 24px;">
                        <input type="checkbox" id="stand-toggle" checked style="opacity: 0; width: 0; height: 0;" onchange="updateStandAndPrice()">
                        <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; border-radius: 24px; transition: .4s;"></span>
                    </label>
                </div>
            </div>
            
            <!-- Add-ons Section -->
            <div id="addons-section" style="margin-top: 20px;">
                <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: #f9f9f9; border-radius: 6px;">
                    <div style="display: flex; align-items: center; flex: 1;">
                        <img id="mounting-image" src="" alt="Wall Mounting Dots" style="width: 40px; height: 40px; object-fit: cover; border-radius: 4px; margin-right: 12px; display: none;">
                        <div style="flex: 1;">
                            <div style="font-size: 14px; font-weight: 500; color: #333;">Nano Wall Mounting Dots (Pack of 8)</div>
                            <div id="addon-mounting-price" style="font-size: 12px; color: #666;">$5.99</div>
                        </div>
                    </div>
                    <label style="position: relative; display: inline-block; width: 44px; height: 24px;">
                        <input type="checkbox" id="addon-mounting-toggle" style="opacity: 0; width: 0; height: 0;" onchange="updateTotalPrice()">
                        <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; border-radius: 24px; transition: .4s;"></span>
                    </label>
                </div>
            </div>
            
            <!-- Add to Cart Button -->
            <button id="add-to-cart-btn" style="width: 100%; padding: 16px; margin-top: 20px; background: #2d5016; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer; text-transform: uppercase;">ADD TO CART</button>
            <button id="buy-now-btn" style="width: 100%; padding: 16px; margin-top: 10px; background: #2d5016; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer; text-transform: uppercase;">BUY NOW</button>
        </div>

        <!-- Info Box - Simplified (Below navigation buttons) -->
        <div class="info-box" style="background: transparent; border: none; padding: 20px 0; margin-top: 20px;">
            <div style="font-size: 16px; font-weight: 500; margin-bottom: 15px; color: #333;">Custom Brick Mosaic Designer</div>
            <div style="font-size: 14px; line-height: 1.6; color: #666; margin-bottom: 15px;">
                Turn your favourite photos into stunning brick art‚Äîmade by you!
            </div>
            <div style="font-size: 14px; line-height: 1.6; color: #666;">
                Bring your memories to life, one brick at a time. With our Custom Brick Mosaic Designer you can transform any image into a beautiful 3D printable mosaic.
            </div>
        </div>

        <!-- Directions Section -->
        <div style="padding: 20px; margin-top: 20px; background: transparent;">
            <div style="font-size: 18px; font-weight: 600; margin-bottom: 20px; color: #333;">How to Use</div>
            <div style="font-size: 14px; line-height: 1.8; color: #666;">
                <div style="margin-bottom: 16px;">
                    <strong style="color: #333; display: block; margin-bottom: 4px;">1. Upload Your Image</strong>
                    Click the "Upload" button and select a photo from your device. The image will be automatically processed.
                </div>
                <div style="margin-bottom: 16px;">
                    <strong style="color: #333; display: block; margin-bottom: 4px;">2. Adjust Size & Crop</strong>
                    Use the "Size" button to crop your image and choose your grid size (48√ó48, 75√ó75, or 96√ó96). Drag the blue crop box to select the area you want to use.
                </div>
                <div style="margin-bottom: 16px;">
                    <strong style="color: #333; display: block; margin-bottom: 4px;">3. Fine-Tune Adjustments</strong>
                    Click "Adjust" to modify brightness, contrast, and other settings to get the perfect look for your mosaic.
                </div>
                <div style="margin-bottom: 16px;">
                    <strong style="color: #333; display: block; margin-bottom: 4px;">4. Paint & Customize (Optional)</strong>
                    Use the "Paint" button to manually adjust individual colors and add your personal touch to the design.
                </div>
                <div style="margin-bottom: 16px;">
                    <strong style="color: #333; display: block; margin-bottom: 4px;">5. View in 3D</strong>
                    Click "View in 3D" to see your custom brick mosaic come to life. Rotate and zoom to explore your creation.
                </div>
                <div>
                    <strong style="color: #333; display: block; margin-bottom: 4px;">6. Proceed to Checkout</strong>
                    Once you're happy with your design, click "Proceed to Checkout" to order your custom brick mosaic.
                </div>
            </div>
        </div>
        </div>
    </div>

    <script>
        // Shopify Configuration - UPDATE THIS WITH YOUR SHOPIFY STORE URL
        const SHOPIFY_PRODUCT_URL = 'https://your-store.myshopify.com/products/3d-album-mosaic'; // UPDATE THIS

        // Price management
        let prices = {};
        let productImages = {};
        let textContent = {};
        let selectedAddons = {
            mounting: false
        };
        let standSelected = true; // Default to stand

        // Load prices from API
        async function loadPrices() {
            try {
                const response = await fetch('/api/prices');
                prices = await response.json();
                await loadImages();
                await loadTextContent();
                updatePriceDisplay();
            } catch (error) {
                console.error('Failed to load prices:', error);
            }
        }

        // Load text content from API
        async function loadTextContent() {
            try {
                const response = await fetch('/api/content');
                textContent = await response.json();
                updateTextContent();
            } catch (error) {
                console.error('Failed to load text content:', error);
            }
        }

        // Update text content on page
        function updateTextContent() {
            // Upload area text
            if (textContent.upload_image_text) {
                const uploadTexts = document.querySelectorAll('#png-upload-text, #upload-panel-upload-area .upload-text');
                uploadTexts.forEach(el => {
                    if (el && el.textContent.includes('Upload an image') || el.textContent.includes('Choose image')) {
                        el.textContent = textContent.upload_image_text;
                    }
                });
            }
            if (textContent.upload_subtext) {
                const uploadSubtexts = document.querySelectorAll('#png-upload-subtext, #upload-panel-upload-area .upload-subtext');
                uploadSubtexts.forEach(el => {
                    if (el) el.textContent = textContent.upload_subtext;
                });
            }
            
            // STL upload text
            if (textContent.stl_upload_text) {
                const stlTexts = document.querySelectorAll('#stl-upload-text');
                stlTexts.forEach(el => {
                    if (el) el.textContent = textContent.stl_upload_text;
                });
            }
            if (textContent.stl_subtext) {
                const stlSubtexts = document.querySelectorAll('#stl-upload-subtext');
                stlSubtexts.forEach(el => {
                    if (el) el.textContent = textContent.stl_subtext;
                });
            }
            
            // Info box content
            const infoBox = document.querySelector('.info-box');
            if (infoBox && textContent.info_title) {
                const titleEl = infoBox.querySelector('div:first-child');
                if (titleEl) titleEl.textContent = textContent.info_title;
            }
            if (infoBox && textContent.info_description) {
                const descEl = infoBox.querySelector('div:nth-child(2)');
                if (descEl) descEl.textContent = textContent.info_description;
            }
            if (infoBox && textContent.info_additional) {
                const addEl = infoBox.querySelector('div:nth-child(3)');
                if (addEl) addEl.textContent = textContent.info_additional;
            }
            
            // How to Use section
            if (textContent.howto_title) {
                const howtoTitle = document.querySelector('[style*="How to Use"]');
                if (howtoTitle && howtoTitle.textContent.includes('How to Use')) {
                    howtoTitle.textContent = textContent.howto_title;
                }
            }
        }

        // Load product images from API
        async function loadImages() {
            try {
                const response = await fetch('/api/images');
                productImages = await response.json();
                updateProductImages();
            } catch (error) {
                console.error('Failed to load images:', error);
            }
        }

        // Update product images display
        function updateProductImages() {
            // Stand image
            const standImage = document.getElementById('stand-image');
            if (standImage && productImages.stand) {
                standImage.src = productImages.stand;
                standImage.style.display = 'block';
            }
            
            // Mounting dots image
            const mountingImage = document.getElementById('mounting-image');
            if (mountingImage && productImages.wall_mounting_dots) {
                mountingImage.src = productImages.wall_mounting_dots;
                mountingImage.style.display = 'block';
            }
        }

        // Update price display based on selected grid size, stand, and addons
        function updatePriceDisplay() {
            const gridSize = selectedGridSize || 75;
            const priceKey = `${gridSize}x${gridSize}`;
            const basePrice = prices[priceKey] || 0;
            
            // Calculate total with stand and addons
            let total = basePrice;
            
            // Add stand price if selected
            if (standSelected) {
                total += prices.stand || 0;
            }
            
            // Add addons
            if (selectedAddons.mounting) {
                total += prices.wall_mounting_dots || 0;
            }
            
            // Update main price
            const mainPriceEl = document.getElementById('main-price');
            if (mainPriceEl) {
                mainPriceEl.textContent = `$${total.toFixed(2)}`;
            }
            
            // Update dimensions
            const dimensionsEl = document.getElementById('price-dimensions');
            if (dimensionsEl) {
                dimensionsEl.textContent = `${gridSize} √ó ${gridSize}`;
            }
            
            // Update stand price display
            const standPriceEl = document.getElementById('stand-price-display');
            if (standPriceEl) {
                const standPrice = prices.stand || 0;
                standPriceEl.textContent = `$${standPrice.toFixed(2)}`;
            }
            
            // Update addons breakdown
            updateOrderBreakdown();
            
            // Update addon prices
            const mountingPriceEl = document.getElementById('addon-mounting-price');
            if (mountingPriceEl && prices.wall_mounting_dots !== undefined) {
                mountingPriceEl.textContent = `$${prices.wall_mounting_dots.toFixed(2)}`;
            }
        }

        // Update stand selection and total price
        function updateStandAndPrice() {
            const standToggle = document.getElementById('stand-toggle');
            standSelected = standToggle ? standToggle.checked : true;
            updatePriceDisplay();
        }

        // Update total price when addons change
        function updateTotalPrice() {
            const mountingToggle = document.getElementById('addon-mounting-toggle');
            
            selectedAddons.mounting = mountingToggle ? mountingToggle.checked : false;
            
            updatePriceDisplay();
        }

        // Update order breakdown display
        function updateOrderBreakdown() {
            const breakdownAddons = document.getElementById('breakdown-addons');
            
            if (breakdownAddons) {
                const addons = [];
                if (standSelected) {
                    addons.push('Stand');
                }
                if (selectedAddons.mounting) {
                    addons.push('Nano');
                }
                
                if (addons.length > 0) {
                    breakdownAddons.textContent = addons.join(', ');
                } else {
                    breakdownAddons.textContent = 'None';
                }
            }
        }

        let stlFile = null;
        let pngFile = null;
        let pngImage = null;
        let scene, camera, renderer, controls, currentMesh;
        let originalGeometry = null;
        let selectedGridSize = 75;
        let rawUploadedImage = null;
        let editorSettings = {
            contrast: 1.2,
            brightness: 1.0,
            pixelSize: 75,
            tones: 4,
            blackPoint: 0,
            whitePoint: 255
        };
        // Crop variables
        let cropperVisible = false;
        let cropperManuallyHidden = false; // Track if user manually hid the cropper
        let cropX = 0, cropY = 0, cropSize = 0;
        let cropInitialized = false; // Track if crop has ever been initialized
        let isDraggingCrop = false;
        let isResizingCrop = false;
        let resizeEdge = ''; // 'left', 'right', 'top', 'bottom', 'topleft', 'topright', 'bottomleft', 'bottomright'
        let dragStartX = 0, dragStartY = 0;
        let cropStartX = 0, cropStartY = 0, cropStartSize = 0;
        // Cropper zoom/pan variables
        let cropperZoom = 1.0;
        let cropperPanX = 0;
        let cropperPanY = 0;
        let isPanningCropper = false;
        let panStartX = 0, panStartY = 0;
        
        // Paint variables
        let selectedPaintColor = { r: 0, g: 0, b: 0 }; // Default to black
        let brushSize = 1; // Brush size in pixels (1 = single pixel, larger = area)
        let processedImageData = null; // Store the processed image data for pixel editing
        let originalProcessedImageData = null; // Store the original processed image data (before painting)
        let undoStack = []; // Stack for undo history
        let redoStack = []; // Stack for redo history
        let lastPaintState = null; // Store state before current paint stroke starts
        let processedZoom = 1.0; // Zoom level for processed canvas
        let processedZoomOffsetX = 0;
        let processedZoomOffsetY = 0;
        let paintingEnabled = false; // Track if Paint panel is active
        let isPanningProcessed = false;
        let processedPanStartX = 0, processedPanStartY = 0;
        let zoomMode = null; // 'zoom-in', 'zoom-out', or null
        let fullOriginalImage = null; // Store the full original uncropped image
        let fullProcessedImageDataURL = null; // Store the full processed image snapshot for cropper preview
        let cropCoordinates = null; // Store crop coordinates {x, y, size} for processing

        const pixelSizes = [48, 75, 96];

        // IndexedDB persistence for files
        let dbPromise = null;
        function openDB() {
            if (dbPromise) return dbPromise;
            dbPromise = new Promise((resolve, reject) => {
                const req = indexedDB.open('albumCoverDB', 1);
                req.onupgradeneeded = () => {
                    const db = req.result;
                    if (!db.objectStoreNames.contains('files')) {
                        db.createObjectStore('files');
                    }
                };
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
            return dbPromise;
        }

        // Key helper for per-size storage
        function dbKey(type, size = selectedGridSize) {
            return `${type}_${size}`;
        }

        async function saveFileToDB(key, file) {
            try {
                const db = await openDB();
                await new Promise((resolve, reject) => {
                    const tx = db.transaction('files', 'readwrite');
                    const store = tx.objectStore('files');
                    const value = { name: file.name, type: file.type, blob: file };
                    const req = store.put(value, key);
                    req.onsuccess = () => resolve();
                    req.onerror = () => reject(req.error);
                });
            } catch (e) {
                console.warn('Failed to save file to IndexedDB', e);
            }
        }

        async function loadFileFromDB(key) {
            try {
                const db = await openDB();
                return await new Promise((resolve, reject) => {
                    const tx = db.transaction('files', 'readonly');
                    const store = tx.objectStore('files');
                    const req = store.get(key);
                    req.onsuccess = () => resolve(req.result || null);
                    req.onerror = () => reject(req.error);
                });
            } catch (e) {
                console.warn('Failed to load file from IndexedDB', e);
                return null;
            }
        }

        // Persist simple state in localStorage
        function saveSimpleState() {
            localStorage.setItem('selectedGridSize', String(selectedGridSize));
            localStorage.setItem('editorSettings', JSON.stringify(editorSettings));
        }

        function loadSimpleState() {
            const sizeStr = localStorage.getItem('selectedGridSize');
            if (sizeStr) {
                const s = parseInt(sizeStr);
                if ([32,48,75,96].includes(s)) {
                    selectedGridSize = s;
                }
            }
            const es = localStorage.getItem('editorSettings');
            if (es) {
                try {
                    const parsed = JSON.parse(es);
                    editorSettings = { ...editorSettings, ...parsed };
                } catch {}
            }
        }

        async function restoreForSize(size) {
            // PNG
            const pngEntry = await loadFileFromDB(dbKey('png', size));
            if (pngEntry && pngEntry.blob) {
                const restoredPNG = new File([pngEntry.blob], pngEntry.name || 'image.png', { type: pngEntry.type || 'image/png' });
                pngFile = restoredPNG;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.onload = () => {
                        rawUploadedImage = img; // ALWAYS keep as full original
                        fullOriginalImage = img; // Store full original uncropped image
                        cropCoordinates = null; // Reset crop coordinates when restoring image
                        pngImage = img;
                        
                        // Reset cropper state when restoring image
                        fullProcessedImageDataURL = null;
                        cropperVisible = false;
                        cropperManuallyHidden = false; // Reset flag when restoring
                        cropInitialized = false;
                        const previewImg = document.getElementById('png-preview-img');
                        if (previewImg) {
                            previewImg.removeAttribute('data-cropper-fixed');
                        }
                        document.getElementById('png-preview').style.display = 'none';
                        document.getElementById('crop-canvas').style.display = 'none';
                        
                        // Auto-tune per restored image
                        autoTuneSettingsFromImage(img);
                        document.getElementById('contrast-slider').value = String(editorSettings.contrast);
                        document.getElementById('brightness-slider').value = String(editorSettings.brightness);
                        document.getElementById('contrast-value').textContent = editorSettings.contrast.toFixed(1);
                        document.getElementById('brightness-value').textContent = editorSettings.brightness.toFixed(1);
                        // Hide upload area when image is restored
                        document.getElementById('png-upload-area').style.display = 'none';
                        document.getElementById('png-upload-area').classList.add('has-file');
                        document.getElementById('png-upload-text').textContent = restoredPNG.name;
                        // Show image preview when restored
                        document.getElementById('png-preview').style.display = 'block';
                        // Show STL section and action buttons when image is restored
                        document.getElementById('stl-section').style.display = 'block';
                        if (currentMesh) applyColorsToMesh();
                        processImage();
                        // Automatically show cropper after image is processed (with small delay to ensure processed canvas is ready)
                        // Only auto-show if user hasn't manually hidden it
                        if (!cropperManuallyHidden) {
                            setTimeout(() => {
                                showCropper();
                            }, 100);
                        }
                    };
                    img.src = ev.target.result;
                };
                reader.readAsDataURL(restoredPNG);
            } else {
                // Clear preview if no PNG for this size
                document.getElementById('png-preview').style.display = 'none';
                // Show upload area when no image
                document.getElementById('png-upload-area').style.display = 'flex';
                document.getElementById('png-upload-area').classList.remove('has-file');
                document.getElementById('png-upload-text').textContent = 'Upload an image to convert to brick art';
                // Hide STL section and action buttons when no image
                document.getElementById('stl-section').style.display = 'none';
                document.getElementById('action-buttons-section').style.display = 'none';
                pngFile = null;
            }

            // STL - Try to restore from IndexedDB first, then fall back to server
            const stlEntry = await loadFileFromDB(dbKey('stl', size));
            if (stlEntry && stlEntry.blob) {
                const restoredSTL = new File([stlEntry.blob], stlEntry.name || `${size}x${size}_grid.stl`, { type: stlEntry.type || 'application/octet-stream' });
                stlFile = restoredSTL;
                document.getElementById('stl-upload-area').classList.add('has-file');
                document.getElementById('stl-upload-text').textContent = `${size}√ó${size} grid loaded`;
                document.getElementById('stl-upload-subtext').textContent = `${size}√ó${size} cube grid`;
                loadSTL(restoredSTL);
                console.log(`‚úÖ Restored STL for ${size}√ó${size} grid from cache`);
            } else {
                // No STL in IndexedDB, load from server
                await loadSTLFromServer(size);
            }
        }

        // Helper function to create processed image at a specific size
        function createProcessedImageAtSize(image, targetSize, callback) {
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = targetSize;
            finalCanvas.height = targetSize;
            const finalCtx = finalCanvas.getContext('2d');

            // If crop coordinates exist, crop from the full original image first
            let imageToProcess = image;
            if (cropCoordinates && cropCoordinates.size > 0) {
                // Create cropped version from full original
                const cropCanvas = document.createElement('canvas');
                cropCanvas.width = cropCoordinates.size;
                cropCanvas.height = cropCoordinates.size;
                const cropCtx = cropCanvas.getContext('2d');
                cropCtx.drawImage(image, cropCoordinates.x, cropCoordinates.y, cropCoordinates.size, cropCoordinates.size, 0, 0, cropCoordinates.size, cropCoordinates.size);
                imageToProcess = cropCanvas;
            }

            // Draw and process (cropped image if crop exists, otherwise full image)
            finalCtx.drawImage(imageToProcess, 0, 0, targetSize, targetSize);
            const imageData = finalCtx.getImageData(0, 0, targetSize, targetSize);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                let gray = 0.299 * r + 0.587 * g + 0.114 * b;

                const bp = editorSettings.blackPoint ?? 0;
                const wp = editorSettings.whitePoint ?? 255;
                gray = (gray - bp) * 255 / Math.max(1, (wp - bp));

                gray = ((gray / 255 - 0.5) * editorSettings.contrast + 0.5) * 255;
                gray = gray * editorSettings.brightness;
                gray = Math.max(0, Math.min(255, gray));

                const base = [0,85,170,255];
                const n = Math.max(2, Math.min(4, editorSettings.tones|0));
                const indices = [];
                for (let k = 0; k < n; k++) {
                    const idx = Math.round((k*(base.length-1))/(n-1));
                    indices.push(base[idx]);
                }
                let finalColor = indices[indices.length-1];
                for (let t = 0; t < indices.length-1; t++) {
                    const mid = (indices[t] + indices[t+1]) / 2;
                    if (gray < mid) { finalColor = indices[t]; break; }
                }

                data[i] = finalColor;
                data[i + 1] = finalColor;
                data[i + 2] = finalColor;
            }

            finalCtx.putImageData(imageData, 0, 0);

            // Convert to image
            finalCanvas.toBlob((blob) => {
                const processedFile = new File([blob], 'processed.png', { type: 'image/png' });
                const img = new Image();
                img.onload = () => {
                    if (callback) callback(processedFile, img);
                };
                img.src = URL.createObjectURL(blob);
            });
        }

        // Handle grid size selection
        async function selectGridSize(size) {
            selectedGridSize = size;
            saveSimpleState();
            
            // Update button states
            document.querySelectorAll('.grid-btn').forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.dataset.size) === size) {
                    btn.classList.add('active');
                }
            });
            
            // Update text to show selected grid size
            document.getElementById('png-upload-subtext').textContent = `Will be resized to ${size}√ó${size} pixels`;
            document.getElementById('stl-upload-subtext').textContent = `${size}√ó${size} cube grid`;
            
            // Update price display
            updatePriceDisplay();
            
            console.log(`Grid size selected: ${size}√ó${size}`);

            // Clear current STL to allow restore
            stlFile = null;

            // If there's a current image loaded, reprocess it with the new size
            // Otherwise, restore saved files for this size
            if (rawUploadedImage) {
                // Reprocess current image with new grid size
                processImage(); // Update preview canvas
                // Also create new processed image for 3D view
                createProcessedImageAtSize(rawUploadedImage, size, (file, img) => {
                    pngFile = file;
                    pngImage = img;
                    // Save to IndexedDB for this size
                    saveFileToDB(dbKey('png', size), file);
                    // Apply colors to 3D mesh if loaded
                    if (currentMesh) {
                        applyColorsToMesh();
                    }
                });
                
                // Load STL for this size (from IndexedDB cache or server)
                const stlEntry = await loadFileFromDB(dbKey('stl', size));
                if (stlEntry && stlEntry.blob) {
                    const restoredSTL = new File([stlEntry.blob], stlEntry.name || `${size}x${size}_grid.stl`, { type: stlEntry.type || 'application/octet-stream' });
                    stlFile = restoredSTL;
                    document.getElementById('stl-upload-area').classList.add('has-file');
                    document.getElementById('stl-upload-text').textContent = `${size}√ó${size} grid loaded`;
                    document.getElementById('stl-upload-subtext').textContent = `${size}√ó${size} cube grid`;
                    loadSTL(restoredSTL);
                    console.log(`‚úÖ Restored STL for ${size}√ó${size} grid from cache`);
                } else {
                    // No cached STL, load from server
                    await loadSTLFromServer(size);
                }
            } else if (pngFile) {
                // If we have a processed PNG file, reload the original if possible
                // Otherwise, just restore saved files for this size
                await restoreForSize(size);
            } else {
                // No current image, restore saved PNG for this size
                await restoreForSize(size);
            }
        }

        // Mobile Panel Navigation Functions
        function showMobilePanel(panelName) {
            // Hide cropper when any panel button is clicked (except size panel which has cropper)
            // But keep cropper visible if size panel is active
            if (panelName !== 'size') {
                if (cropperVisible) {
                    hideCropper();
                }
                // Hide overlay canvas when not in size panel
                const overlayCanvas = document.getElementById('processed-crop-overlay');
                if (overlayCanvas) {
                    overlayCanvas.style.display = 'none';
                }
                // Hide size panel canvas when not in size panel
                const sizePanelCanvas = document.getElementById('size-panel-canvas');
                if (sizePanelCanvas) {
                    sizePanelCanvas.style.display = 'none';
                    sizePanelCanvas.removeAttribute('data-size-panel-active');
                }
                // Hide crop panel canvas when not in size panel
                const cropPanelCanvas = document.getElementById('crop-panel-canvas');
                if (cropPanelCanvas) {
                    cropPanelCanvas.style.display = 'none';
                    cropPanelCanvas.removeAttribute('data-crop-panel-active');
                }
            }
            
            // Enable/disable painting based on panel
            paintingEnabled = (panelName === 'paint');
            
            // Show editor panel with processed canvas when Paint panel is active
            if (paintingEnabled) {
                showEditorPanel();
            }
            
            // Handle upload panel
            if (panelName === 'upload') {
                // Scroll to upload area
                const uploadArea = document.getElementById('png-upload-area');
                if (uploadArea) {
                    uploadArea.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }
            
            // Handle size panel - show original image with cropper + size selection
            if (panelName === 'size') {
                // Show editor panel with processed canvas
                showEditorPanel();
                
                // Force hide png-preview to avoid showing duplicate processed image
                const pngPreview = document.getElementById('png-preview');
                if (pngPreview) {
                    pngPreview.style.display = 'none !important';
                    pngPreview.style.visibility = 'hidden';
                }
                const pngPreviewImg = document.getElementById('png-preview-img');
                if (pngPreviewImg) {
                    pngPreviewImg.style.display = 'none';
                }
                
                // Check if image is available
                const hasImage = rawUploadedImage || (pngFile && pngImage);
                
                if (hasImage) {
                    // Show size panel preview with original image
                    const sizePanelPreview = document.getElementById('size-panel-preview');
                    const sizePanelPlaceholder = document.getElementById('size-panel-placeholder');
                    const sizePanelImg = document.getElementById('size-panel-img');
                    const sizePanelCanvas = document.getElementById('size-panel-canvas');
                    
                    if (sizePanelPreview && sizePanelImg && sizePanelCanvas) {
                        sizePanelPreview.style.display = 'block';
                        if (sizePanelPlaceholder) sizePanelPlaceholder.style.display = 'none';
                        
                        // Show crop buttons
                        const cropButtons = document.getElementById('size-panel-crop-buttons');
                        const hideBtn = document.getElementById('size-panel-hide-btn');
                        const showBtn = document.getElementById('size-panel-show-btn');
                        if (cropButtons) cropButtons.style.display = 'flex';
                        if (hideBtn) hideBtn.style.display = 'block';
                        if (showBtn) showBtn.style.display = 'none';
                        
                        // ALWAYS show the full original uploaded image (never cropped)
                        // Use rawUploadedImage which should always be the full original
                        if (rawUploadedImage && rawUploadedImage.src) {
                            sizePanelImg.src = rawUploadedImage.src;
                        } else if (fullOriginalImage && fullOriginalImage.src) {
                            // Fallback to fullOriginalImage if rawUploadedImage is not available
                            sizePanelImg.src = fullOriginalImage.src;
                        } else if (pngFile) {
                            // If we have pngFile but no rawUploadedImage, create a new image from the file
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                sizePanelImg.src = e.target.result;
                            };
                            reader.readAsDataURL(pngFile);
                        }
                        
                        // Show and initialize cropper on the original image
                        sizePanelCanvas.style.display = 'block';
                        cropperVisible = true;
                        sizePanelCanvas.setAttribute('data-size-panel-active', 'true');
                        
                        // Initialize cropper on the size panel canvas
                        setTimeout(() => {
                            initSizePanelCropper(sizePanelImg, sizePanelCanvas);
                            // Ensure it stays visible after initialization
                            sizePanelCanvas.style.display = 'block';
                            cropperVisible = true;
                        }, 100);
                    }
                } else {
                    // No image uploaded
                    const sizePanelPreview = document.getElementById('size-panel-preview');
                    const sizePanelPlaceholder = document.getElementById('size-panel-placeholder');
                    if (sizePanelPreview) sizePanelPreview.style.display = 'none';
                    if (sizePanelPlaceholder) sizePanelPlaceholder.style.display = 'block';
                }
            }
            
            // Update canvas cursor based on painting state
            const processedCanvas = document.getElementById('processed-canvas');
            if (processedCanvas) {
                if (paintingEnabled) {
                    processedCanvas.style.cursor = 'crosshair';
                } else {
                    processedCanvas.style.cursor = 'default';
                }
            }
            
            // Hide all panels first
            document.querySelectorAll('.mobile-panel').forEach(panel => {
                panel.style.display = 'none';
            });
            
            // Hide image preview completely when panel is shown (except for size panel which shows its own preview)
            if (panelName !== 'size') {
                const pngPreview = document.getElementById('png-preview');
                if (pngPreview) {
                    pngPreview.style.display = 'none';
                }
            }
            
            // Hide other sections
            document.getElementById('png-upload-area').style.display = pngFile ? 'none' : 'flex';
            document.getElementById('stl-section').style.display = 'none';
            document.getElementById('action-buttons-section').style.display = 'none';
            document.querySelector('.info-box').style.display = 'none';
            document.querySelector('.title').style.display = 'none';
            
            // Remove active class from all nav buttons
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected panel (will appear below image)
            const panel = document.getElementById(panelName + '-panel');
            if (panel) {
                panel.style.display = 'block';
                // Smooth scroll to show panel below image
                setTimeout(() => {
                    // Scroll so panel is visible, accounting for bottom nav
                    const panelTop = panel.getBoundingClientRect().top + window.pageYOffset;
                    const scrollPosition = panelTop - 20; // Small offset from top
                    window.scrollTo({ top: scrollPosition, behavior: 'smooth' });
                }, 50);
            }
            
            // Add active class to clicked button
            const navBtn = document.getElementById('nav-' + panelName);
            if (navBtn) {
                navBtn.classList.add('active');
            }
        }
        
        // Function to show main content (when no panel is active)
        function showMainContent() {
            // Disable painting when no panel is active
            paintingEnabled = false;
            
            // Update canvas cursor
            const processedCanvas = document.getElementById('processed-canvas');
            if (processedCanvas) {
                processedCanvas.style.cursor = 'default';
            }
            
            // Show all main content
            document.getElementById('png-upload-area').style.display = 'flex';
            if (pngFile) {
                document.getElementById('png-preview').style.display = 'block';
            }
            document.getElementById('stl-section').style.display = pngFile ? 'block' : 'none';
            document.getElementById('action-buttons-section').style.display = pngFile ? 'flex' : 'none';
            document.querySelector('.info-box').style.display = 'block';
            document.querySelector('.title').style.display = 'block';
            
            // Hide all panels
            document.querySelectorAll('.mobile-panel').forEach(panel => {
                panel.style.display = 'none';
            });
            
            // Remove active class from all nav buttons
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });
        }

        // Photo Editor Functions
        function showEditorPanel() {
            // On mobile, show viewer-panel but with proper flow styles
            if (window.innerWidth <= 1024) {
                const viewerPanel = document.querySelector('.viewer-panel');
                viewerPanel.classList.remove('hidden-on-mobile');
                viewerPanel.style.display = 'block';
                viewerPanel.style.position = 'static';
                viewerPanel.style.height = 'auto';
                viewerPanel.style.overflow = 'visible';
                document.getElementById('editor-panel').style.display = 'block';
                document.getElementById('canvas-container').style.display = 'none';
            } else {
                // Desktop: Remove hidden class to show viewer panel
                document.querySelector('.viewer-panel').classList.remove('hidden-on-mobile');
                document.getElementById('editor-panel').style.display = 'block';
                document.getElementById('canvas-container').style.display = 'none';
            }
            // Show processed canvas when editing
            const processedCanvas = document.getElementById('processed-canvas');
            if (processedCanvas) {
                processedCanvas.style.display = 'block';
            }
            if (rawUploadedImage) {
                // If we have painted image data, just redraw it instead of reprocessing
                if (processedImageData && processedImageData.width === selectedGridSize && processedImageData.height === selectedGridSize) {
                    redrawProcessedCanvas();
                } else {
                    // No painted data, process from scratch
                    processImage();
                }
            }
        }

        function show3DView() {
            // Ensure STL matches selected grid size before showing 3D view
            if (stlFile) {
                // Check if current STL matches selected grid size
                const stlFileName = stlFile.name.toLowerCase();
                const expectedSize = selectedGridSize;
                const sizeMatch = stlFileName.includes(`${expectedSize}x${expectedSize}`) || 
                                 stlFileName.includes(`${expectedSize}√ó${expectedSize}`);
                
                if (!sizeMatch) {
                    // STL doesn't match selected size, reload it
                    console.log(`STL size mismatch. Reloading STL for ${expectedSize}√ó${expectedSize}...`);
                    loadSTLFromServer(expectedSize).then(() => {
                        // After STL is loaded, regenerate PNG and show 3D view
                        if (rawUploadedImage && currentMesh) {
                            createProcessedImageAtSize(rawUploadedImage, selectedGridSize, (file, img) => {
                                pngFile = file;
                                pngImage = img;
                                applyColorsToMesh();
                            });
                        }
                    });
                } else {
                    // STL matches, just regenerate PNG
                    if (rawUploadedImage && currentMesh) {
                        createProcessedImageAtSize(rawUploadedImage, selectedGridSize, (file, img) => {
                            pngFile = file;
                            pngImage = img;
                            applyColorsToMesh();
                        });
                    }
                }
            } else {
                // No STL loaded, load it first
                loadSTLFromServer(selectedGridSize).then(() => {
                    if (rawUploadedImage && currentMesh) {
                        createProcessedImageAtSize(rawUploadedImage, selectedGridSize, (file, img) => {
                            pngFile = file;
                            pngImage = img;
                            applyColorsToMesh();
                        });
                    }
                });
            }
            
            // Remove hidden class to show viewer panel on mobile
            document.querySelector('.viewer-panel').classList.remove('hidden-on-mobile');
            // Hide editor panel (processed/posterized view) completely
            document.getElementById('editor-panel').style.display = 'none';
            // Hide processed canvas and preview as well
            const processedCanvas = document.getElementById('processed-canvas');
            if (processedCanvas) {
                processedCanvas.style.display = 'none';
            }
            const pngPreview = document.getElementById('png-preview');
            if (pngPreview) {
                pngPreview.style.display = 'none';
            }
            // Show 3D canvas container
            document.getElementById('canvas-container').style.display = 'block';
            // Ensure Three.js canvas resizes correctly after becoming visible (wait a frame)
            requestAnimationFrame(() => {
                try {
                    const container = document.getElementById('canvas-container');
                    let w = container.clientWidth || container.offsetWidth;
                    let h = container.clientHeight || container.offsetHeight;
                    if (!w || !h) {
                        w = window.innerWidth;
                        h = window.innerHeight;
                    }
                    // Ensure renderer DOM is attached
                    if (renderer && container && renderer.domElement && renderer.domElement.parentNode !== container) {
                        container.appendChild(renderer.domElement);
                    }
                    if (renderer && camera) {
                        renderer.setSize(w, h, true);
                        camera.aspect = w / h;
                        camera.updateProjectionMatrix();
                    }
                    // Fit camera to current mesh if available
                    if (currentMesh) {
                        const box = new THREE.Box3().setFromObject(currentMesh);
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z) || 100;
                        camera.position.set(maxDim, maxDim, maxDim);
                        controls.target.set(0, 0, 0);
                        controls.update();
                    }
                    // Render once immediately after resize
                    if (renderer && scene && camera) {
                        renderer.render(scene, camera);
                    }
                } catch (e) {
                    console.warn('Resize after showing 3D view failed:', e);
                }
            });
        }

        function processImage() {
            if (!rawUploadedImage) return;

            const processedCanvas = document.getElementById('processed-canvas');
            const processedCtx = processedCanvas.getContext('2d');

            // Set canvas sizes - ensure it fits within available space without scrolling
            const container = document.getElementById('editor-panel');
            const containerWidth = Math.max(200, container.clientWidth - 48); // padding
            // Reserve space for header (~60px), label (~30px), buttons (~70px), and padding (~40px)
            const reservedHeight = 250;
            const availableHeight = window.innerHeight - reservedHeight;
            // Cap at 400px max to ensure it fits comfortably without scrolling
            const maxSize = 400;
            const side = Math.min(containerWidth, availableHeight, maxSize);
            // Set both canvas dimensions and CSS style for display
            processedCanvas.width = side;
            processedCanvas.height = side;
            processedCanvas.style.width = side + 'px';
            processedCanvas.style.height = side + 'px';
            processedCanvas.style.maxWidth = side + 'px';

            // Process: Convert to grayscale with luminosity + posterize + pixelate
            const pixelSize = selectedGridSize;
            
            // Create temp canvas at target pixel size
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = pixelSize;
            tempCanvas.height = pixelSize;
            const tempCtx = tempCanvas.getContext('2d');
            
            // If crop coordinates exist, crop from the full original image first
            if (cropCoordinates && cropCoordinates.size > 0) {
                // Create cropped version from full original
                const cropCanvas = document.createElement('canvas');
                cropCanvas.width = cropCoordinates.size;
                cropCanvas.height = cropCoordinates.size;
                const cropCtx = cropCanvas.getContext('2d');
                cropCtx.drawImage(rawUploadedImage, cropCoordinates.x, cropCoordinates.y, cropCoordinates.size, cropCoordinates.size, 0, 0, cropCoordinates.size, cropCoordinates.size);
                
                // Draw cropped image at small size (pixelation effect)
                tempCtx.drawImage(cropCanvas, 0, 0, pixelSize, pixelSize);
            } else {
                // No crop - draw full image at small size (pixelation effect)
                tempCtx.drawImage(rawUploadedImage, 0, 0, pixelSize, pixelSize);
            }
            
            // Get image data
            const imageData = tempCtx.getImageData(0, 0, pixelSize, pixelSize);
            const data = imageData.data;

            // Process each pixel: grayscale + percentile stretch + contrast/brightness + N-tone posterize
            for (let i = 0; i < data.length; i += 4) {
                // Convert to grayscale using luminosity method (perceputal brightness)
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                let gray = 0.299 * r + 0.587 * g + 0.114 * b;

                // Percentile stretch using black/white points
                const bp = editorSettings.blackPoint ?? 0;
                const wp = editorSettings.whitePoint ?? 255;
                gray = (gray - bp) * 255 / Math.max(1, (wp - bp));

                // Apply contrast and brightness
                gray = ((gray / 255 - 0.5) * editorSettings.contrast + 0.5) * 255;
                gray = gray * editorSettings.brightness;
                gray = Math.max(0, Math.min(255, gray));

                // Posterize to N tones based on brightness using base palette [0,85,170,255]
                const base = [0,85,170,255];
                const n = Math.max(2, Math.min(4, editorSettings.tones|0));
                const indices = [];
                for (let k = 0; k < n; k++) {
                    const idx = Math.round((k*(base.length-1))/(n-1));
                    indices.push(base[idx]);
                }
                // thresholds midpoints
                let finalColor = indices[indices.length-1];
                for (let t = 0; t < indices.length-1; t++) {
                    const mid = (indices[t] + indices[t+1]) / 2;
                    if (gray < mid) { finalColor = indices[t]; break; }
                }

                data[i] = finalColor;
                data[i + 1] = finalColor;
                data[i + 2] = finalColor;
            }

            tempCtx.putImageData(imageData, 0, 0);

            // Store the processed image data for pixel editing (at pixel size, not display size)
            const imageDataCopy = tempCtx.getImageData(0, 0, pixelSize, pixelSize);
            processedImageData = imageDataCopy;
            
            // Store a deep copy as the original (for reset functionality)
            originalProcessedImageData = new ImageData(
                new Uint8ClampedArray(imageDataCopy.data),
                imageDataCopy.width,
                imageDataCopy.height
            );

            // Draw pixelated result to processed canvas (scaled up)
            processedCtx.imageSmoothingEnabled = false;
            processedCtx.drawImage(tempCanvas, 0, 0, processedCanvas.width, processedCanvas.height);
            
            // Create a preview version at preview size for general use
            const previewCanvas = document.createElement('canvas');
            const previewMaxSize = 400;
            previewCanvas.width = previewMaxSize;
            previewCanvas.height = previewMaxSize;
            const previewCtx = previewCanvas.getContext('2d');
            previewCtx.imageSmoothingEnabled = false;
            previewCtx.drawImage(tempCanvas, 0, 0, previewMaxSize, previewMaxSize);
            const previewDataURL = previewCanvas.toDataURL();
            
            // IMPORTANT: Only store the full processed preview if cropper is NOT visible
            // Once cropper is visible, this snapshot is FROZEN and must never change
            // This is exclusively for the cropper preview - completely separate from editor updates
            if (!cropperVisible) {
                // Only update when cropper is not visible - this way it captures the full image before cropping
                fullProcessedImageDataURL = previewDataURL;
            }
            // If cropper IS visible, DO NOT overwrite fullProcessedImageDataURL - keep it frozen
            
            // Update preview image to show same processed result (scaled up to match preview size)
            // BUT NEVER update if cropper is visible/fixed - the cropper preview must stay unchanged
            // IMPORTANT: Check cropperVisible FIRST to prevent any updates while cropping
            const previewImg = document.getElementById('png-preview-img');
            const isCropperFixed = previewImg && previewImg.getAttribute('data-cropper-fixed') === 'true';
            // Only update if cropper is NOT visible AND preview is NOT fixed
            if (previewImg && rawUploadedImage && !cropperVisible && !isCropperFixed) {
                previewImg.src = previewDataURL;
            }
            // If cropper is visible, NEVER update the preview - it must stay frozen
            
            // Re-attach paint handlers after processing
            setTimeout(() => {
                setupPaintHandlers();
            }, 100);
        }

        function applyPhotoEdits() {
            // Create the processed image at the selected pixel size
            const pixelSize = selectedGridSize; // Use selectedGridSize
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = pixelSize;
            finalCanvas.height = pixelSize;
            const finalCtx = finalCanvas.getContext('2d');

            // Use painted image data if available, otherwise process from scratch
            let imageData;
            if (processedImageData && processedImageData.width === pixelSize && processedImageData.height === pixelSize) {
                // Use the painted image data (preserve paintings)
                imageData = new ImageData(
                    new Uint8ClampedArray(processedImageData.data),
                    processedImageData.width,
                    processedImageData.height
                );
            } else {
                // Draw and process from original
                finalCtx.drawImage(rawUploadedImage, 0, 0, pixelSize, pixelSize);
                imageData = finalCtx.getImageData(0, 0, pixelSize, pixelSize);
                const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                let gray = 0.299 * r + 0.587 * g + 0.114 * b;

                const bp = editorSettings.blackPoint ?? 0;
                const wp = editorSettings.whitePoint ?? 255;
                gray = (gray - bp) * 255 / Math.max(1, (wp - bp));

                gray = ((gray / 255 - 0.5) * editorSettings.contrast + 0.5) * 255;
                gray = gray * editorSettings.brightness;
                gray = Math.max(0, Math.min(255, gray));

                const base = [0,85,170,255];
                const n = Math.max(2, Math.min(4, editorSettings.tones|0));
                const indices = [];
                for (let k = 0; k < n; k++) {
                    const idx = Math.round((k*(base.length-1))/(n-1));
                    indices.push(base[idx]);
                }
                let finalColor = indices[indices.length-1];
                for (let t = 0; t < indices.length-1; t++) {
                    const mid = (indices[t] + indices[t+1]) / 2;
                    if (gray < mid) { finalColor = indices[t]; break; }
                }

                data[i] = finalColor;
                data[i + 1] = finalColor;
                data[i + 2] = finalColor;
            }
            
                // Store for future editing
                processedImageData = imageData;
                
                // Store a deep copy as the original (for reset functionality)
                originalProcessedImageData = new ImageData(
                    new Uint8ClampedArray(imageData.data),
                    imageData.width,
                    imageData.height
                );
            }

            finalCtx.putImageData(imageData, 0, 0);

            // Convert to image and use as PNG
            finalCanvas.toBlob((blob) => {
                const processedFile = new File([blob], 'processed.png', { type: 'image/png' });
                pngFile = processedFile;

                const img = new Image();
                img.onload = () => {
                    pngImage = img;
                    // Don't set preview here - it's already set to processed version in processImage()
                    // document.getElementById('png-preview-img').src = img.src;
                    // Show crop buttons when image is processed
                    // Don't show preview automatically - only show when "Show Cropper" is clicked
                    // document.getElementById('png-preview').style.display = 'block';
                    document.getElementById('png-upload-area').classList.add('has-file');
                    document.getElementById('png-upload-text').textContent = 'Processed image';

                    // Apply colors to 3D mesh if STL is loaded (with current crop)
                    if (currentMesh) {
                        applyColorsToMesh();
                    }
                    // Keep editor panel visible with processed image (don't switch to 3D view on mobile)
                    // Show the processed image properly
                    showEditorPanel();
                    // Hide the preview/cropper section - show the processed canvas instead
                    document.getElementById('png-preview').style.display = 'none';
                    // Ensure processed canvas is visible
                    const processedCanvas = document.getElementById('processed-canvas');
                    if (processedCanvas) {
                        processedCanvas.style.display = 'block';
                    }
                    // Scroll smoothly to top to show the processed image
                    setTimeout(() => {
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                    }, 100);
                };
                img.src = URL.createObjectURL(blob);

                // Persist processed PNG for current grid size
                saveFileToDB(dbKey('png'), processedFile);
            }, 'image/png');
        }

        // Crop Functions - Simple cropper with blue dotted line
        function showCropper() {
            console.log('Show cropper clicked');
            
            const previewImg = document.getElementById('png-preview-img');
            const cropCanvas = document.getElementById('crop-canvas');
            const container = document.getElementById('crop-container');
            
            if (!previewImg || !cropCanvas || !container) {
                console.error('Cropper elements not found');
                return;
            }
            
            // User is manually showing the cropper, so clear the manually hidden flag
            cropperManuallyHidden = false;
            
            // Make sure preview image is visible
            document.getElementById('png-preview').style.display = 'block';
            
            // Always create a fresh snapshot from the current processed canvas when showing cropper
            // This ensures the cropper always shows the current processed image
            const processedCanvas = document.getElementById('processed-canvas');
            if (processedCanvas && processedCanvas.width > 0) {
                // Create a snapshot from the current processed canvas
                const snapshotCanvas = document.createElement('canvas');
                snapshotCanvas.width = 400;
                snapshotCanvas.height = 400;
                const snapshotCtx = snapshotCanvas.getContext('2d');
                snapshotCtx.imageSmoothingEnabled = false;
                
                // Draw the current processed canvas to create the snapshot
                // Handle zoom/pan by redrawing at 1:1 scale
                if (processedImageData && processedImageData.width === selectedGridSize) {
                    // Draw directly from processedImageData at correct size
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = selectedGridSize;
                    tempCanvas.height = selectedGridSize;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.putImageData(processedImageData, 0, 0);
                    snapshotCtx.drawImage(tempCanvas, 0, 0, 400, 400);
                } else {
                    // Fallback: draw from processed canvas
                    snapshotCtx.drawImage(processedCanvas, 0, 0, 400, 400);
                }
                
                fullProcessedImageDataURL = snapshotCanvas.toDataURL();
                previewImg.src = fullProcessedImageDataURL;
                previewImg.setAttribute('data-cropper-fixed', 'true');
            } else if (fullProcessedImageDataURL) {
                // Use existing snapshot if canvas not ready
                previewImg.src = fullProcessedImageDataURL;
                previewImg.setAttribute('data-cropper-fixed', 'true');
            } else {
                // Fallback: create snapshot from processed canvas (only if no snapshot exists)
                // But make sure to store it so it never changes again
                const processedCanvas = document.getElementById('processed-canvas');
                if (processedCanvas && processedCanvas.width > 0) {
                    const previewCanvas = document.createElement('canvas');
                    const previewMaxSize = 400;
                    previewCanvas.width = previewMaxSize;
                    previewCanvas.height = previewMaxSize;
                    const previewCtx = previewCanvas.getContext('2d');
                    previewCtx.imageSmoothingEnabled = false;
                    previewCtx.drawImage(processedCanvas, 0, 0, previewMaxSize, previewMaxSize);
                    const snapshotDataURL = previewCanvas.toDataURL();
                    fullProcessedImageDataURL = snapshotDataURL; // Store as frozen snapshot
                    previewImg.src = snapshotDataURL;
                    previewImg.setAttribute('data-cropper-fixed', 'true');
                } else if (pngImage && pngImage.src) {
                    // Convert PNG to data URL and store as frozen snapshot
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = 400;
                    tempCanvas.height = 400;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.imageSmoothingEnabled = false;
                    const tempImg = new Image();
                    tempImg.onload = () => {
                        tempCtx.drawImage(tempImg, 0, 0, 400, 400);
                        const snapshotDataURL = tempCanvas.toDataURL();
                        fullProcessedImageDataURL = snapshotDataURL; // Store as frozen snapshot
                        previewImg.src = snapshotDataURL;
                        previewImg.setAttribute('data-cropper-fixed', 'true');
                    };
                    tempImg.src = pngImage.src;
                    return; // Exit early, will continue after image loads
                } else {
                    alert('Please upload and process an image first');
                    return;
                }
            }
            
            // Wait for image to load if needed
            if (previewImg.complete && previewImg.naturalWidth > 0) {
                setTimeout(initCropper, 50);
            } else {
                previewImg.onload = function() {
                    setTimeout(initCropper, 50);
                };
                // If image is already loading, trigger onload manually
                if (previewImg.src) {
                    previewImg.load();
                }
            }
            
            function initCropper() {
                // Reset zoom/pan when showing cropper
                cropperZoom = 1.0;
                cropperPanX = 0;
                cropperPanY = 0;
                updateCropperTransform();
                
                // Use FIXED dimensions for cropper - always 400x400px
                // This ensures the cropper preview never changes size
                const imgDisplayWidth = 400;
                const imgDisplayHeight = 400;
                
                // Set canvas display size to match fixed image size
                cropCanvas.style.width = imgDisplayWidth + 'px';
                cropCanvas.style.height = imgDisplayHeight + 'px';
                cropCanvas.style.left = '0px';
                cropCanvas.style.top = '0px';
                cropCanvas.style.display = 'block';
                cropCanvas.style.pointerEvents = 'auto';
                cropCanvas.style.cursor = 'move';
                cropCanvas.style.zIndex = '10';
                
                // Set canvas internal resolution (device pixel ratio for crisp lines)
                const dpr = window.devicePixelRatio || 1;
                cropCanvas.width = imgDisplayWidth * dpr;
                cropCanvas.height = imgDisplayHeight * dpr;
                
                // Initialize crop area - ONLY if never initialized before (preserve position forever after first use)
                if (!cropInitialized) {
                    // First time - center it, 80% of image size, snapped to grid
                    const gridSize = selectedGridSize;
                    const cellSize = imgDisplayWidth / gridSize;
                    
                    let initialSize = Math.min(imgDisplayWidth, imgDisplayHeight) * 0.8;
                    const numCells = Math.round(initialSize / cellSize);
                    cropSize = Math.max(1, numCells) * cellSize;
                    
                    // Precise center calculation with snapping
                    const centerX = (imgDisplayWidth - cropSize) / 2;
                    const centerY = (imgDisplayHeight - cropSize) / 2;
                    const centerCellX = Math.round(centerX / cellSize);
                    const centerCellY = Math.round(centerY / cellSize);
                    cropX = centerCellX * cellSize;
                    cropY = centerCellY * cellSize;
                    
                    // Ensure crop box stays within image bounds
                    cropX = Math.max(0, Math.min(cropX, imgDisplayWidth - cropSize));
                    cropY = Math.max(0, Math.min(cropY, imgDisplayHeight - cropSize));
                    
                    cropInitialized = true; // Mark as initialized - never reset again
                }
                // If crop position already exists, keep it exactly where it is (don't reset to center)
                
                cropperVisible = true;
                document.getElementById('show-cropper-btn').style.display = 'none';
                document.getElementById('hide-cropper-btn').style.display = 'block';
                // Show the preview image
                document.getElementById('png-preview').style.display = 'block';
                
                drawCropBox();
            }
        }
        
        // Initialize cropper for crop panel
        function initCropPanelCropper(img, canvas) {
            if (!img || !canvas) return;
            
            // Reset zoom/pan
            cropperZoom = 1.0;
            cropperPanX = 0;
            cropperPanY = 0;
            
            // Wait for image to load
            if (img.complete && img.naturalWidth > 0) {
                setupCropPanelCanvas(img, canvas);
            } else {
                img.onload = () => {
                    setupCropPanelCanvas(img, canvas);
                };
            }
        }
        
        // Initialize cropper for size panel (same as crop panel)
        function initSizePanelCropper(img, canvas) {
            if (!img || !canvas) return;
            
            // Reset zoom/pan
            cropperZoom = 1.0;
            cropperPanX = 0;
            cropperPanY = 0;
            
            // Wait for image to load
            if (img.complete && img.naturalWidth > 0) {
                setupCropPanelCanvas(img, canvas);
            } else {
                img.onload = () => {
                    setupCropPanelCanvas(img, canvas);
                };
            }
        }
        
        function setupCropPanelCanvas(img, canvas) {
            // Wait a bit for image to be fully rendered
            setTimeout(() => {
                // Reset zoom/pan when showing cropper
                cropperZoom = 1.0;
                cropperPanX = 0;
                cropperPanY = 0;
                updateCropperTransform();
                
                // Use FIXED dimensions for cropper - always 400x400px
                // This ensures the cropper preview never changes size
                const imgDisplayWidth = 400;
                const imgDisplayHeight = 400;
                
                // Set canvas display size to match fixed image size
                canvas.style.width = imgDisplayWidth + 'px';
                canvas.style.height = imgDisplayHeight + 'px';
                canvas.style.left = '0px';
                canvas.style.top = '0px';
                canvas.style.display = 'block';
                canvas.style.pointerEvents = 'auto';
                canvas.style.cursor = 'move';
                canvas.style.zIndex = '10';
                
                // Set canvas internal resolution (device pixel ratio for crisp lines)
                const dpr = window.devicePixelRatio || 1;
                canvas.width = imgDisplayWidth * dpr;
                canvas.height = imgDisplayHeight * dpr;
                
                // Initialize crop area - ONLY if never initialized before (preserve position forever after first use)
                if (!cropInitialized) {
                    // First time - center it, 80% of image size, snapped to grid
                    const gridSize = selectedGridSize;
                    const cellSize = imgDisplayWidth / gridSize;
                    
                    let initialSize = Math.min(imgDisplayWidth, imgDisplayHeight) * 0.8;
                    const numCells = Math.round(initialSize / cellSize);
                    cropSize = Math.max(1, numCells) * cellSize;
                    
                    // Precise center calculation with snapping
                    const centerX = (imgDisplayWidth - cropSize) / 2;
                    const centerY = (imgDisplayHeight - cropSize) / 2;
                    const centerCellX = Math.round(centerX / cellSize);
                    const centerCellY = Math.round(centerY / cellSize);
                    cropX = centerCellX * cellSize;
                    cropY = centerCellY * cellSize;
                    
                    // Ensure crop box stays within image bounds
                    cropX = Math.max(0, Math.min(cropX, imgDisplayWidth - cropSize));
                    cropY = Math.max(0, Math.min(cropY, imgDisplayHeight - cropSize));
                    
                    cropInitialized = true; // Mark as initialized - never reset again
                }
                // If crop position already exists, keep it exactly where it is (don't reset to center)
                
                cropperVisible = true;
                
                // Set up event listeners for crop panel canvas if not already set up
                if (!canvas.dataset.listenersSetup) {
                    setupCropCanvasListeners(canvas);
                    canvas.dataset.listenersSetup = 'true';
                }
                
                // Draw cropper box
                drawCropBox();
                
                // Redraw after a short delay to ensure everything is rendered
                requestAnimationFrame(() => {
                    drawCropBox();
                });
            }, 50);
        }
        
        // Hide/show cropper in size panel
        function hideSizePanelCropper() {
            const sizePanelPreview = document.getElementById('size-panel-preview');
            const hideBtn = document.getElementById('size-panel-hide-btn');
            const showBtn = document.getElementById('size-panel-show-btn');
            
            if (sizePanelPreview) {
                sizePanelPreview.style.display = 'none';
            }
            if (hideBtn) hideBtn.style.display = 'none';
            if (showBtn) showBtn.style.display = 'block';
            
            cropperVisible = false;
        }
        
        function showSizePanelCropper() {
            const sizePanelPreview = document.getElementById('size-panel-preview');
            const sizePanelCanvas = document.getElementById('size-panel-canvas');
            const hideBtn = document.getElementById('size-panel-hide-btn');
            const showBtn = document.getElementById('size-panel-show-btn');
            
            if (sizePanelPreview) {
                sizePanelPreview.style.display = 'block';
            }
            if (sizePanelCanvas) {
                sizePanelCanvas.style.display = 'block';
                sizePanelCanvas.setAttribute('data-size-panel-active', 'true');
            }
            if (hideBtn) hideBtn.style.display = 'block';
            if (showBtn) showBtn.style.display = 'none';
            
            cropperVisible = true;
            drawCropBox();
        }
        
        // Show cropper overlay on processed canvas
        function showCropperOnProcessedCanvas() {
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas || processedCanvas.width === 0) return;
            
            // Create overlay canvas if it doesn't exist
            let overlayCanvas = document.getElementById('processed-crop-overlay');
            if (!overlayCanvas) {
                overlayCanvas = document.createElement('canvas');
                overlayCanvas.id = 'processed-crop-overlay';
                overlayCanvas.style.position = 'absolute';
                overlayCanvas.style.top = '0';
                overlayCanvas.style.left = '0';
                overlayCanvas.style.width = '100%';
                overlayCanvas.style.height = '100%';
                overlayCanvas.style.pointerEvents = 'auto';
                overlayCanvas.style.cursor = 'move';
                overlayCanvas.style.zIndex = '15';
                overlayCanvas.style.border = 'none';
                overlayCanvas.style.background = 'transparent';
                
                // Insert after processed canvas
                const canvasWrapper = processedCanvas.parentElement;
                if (canvasWrapper) {
                    canvasWrapper.style.position = 'relative';
                    canvasWrapper.appendChild(overlayCanvas);
                }
            }
            
            // Get canvas dimensions
            const rect = processedCanvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            overlayCanvas.style.width = rect.width + 'px';
            overlayCanvas.style.height = rect.height + 'px';
            overlayCanvas.width = rect.width * dpr;
            overlayCanvas.height = rect.height * dpr;
            overlayCanvas.style.display = 'block';
            
            // Initialize crop area if needed
            if (!cropInitialized) {
                const gridSize = selectedGridSize;
                const cellSize = rect.width / gridSize;
                
                let initialSize = Math.min(rect.width, rect.height) * 0.8;
                const numCells = Math.round(initialSize / cellSize);
                cropSize = Math.max(1, numCells) * cellSize;
                
                const centerX = (rect.width - cropSize) / 2;
                const centerY = (rect.height - cropSize) / 2;
                const centerCellX = Math.round(centerX / cellSize);
                const centerCellY = Math.round(centerY / cellSize);
                cropX = centerCellX * cellSize;
                cropY = centerCellY * cellSize;
                
                cropX = Math.max(0, Math.min(cropX, rect.width - cropSize));
                cropY = Math.max(0, Math.min(cropY, rect.height - cropSize));
                
                cropInitialized = true;
            }
            
            cropperVisible = true;
            cropperZoom = 1.0;
            cropperPanX = 0;
            cropperPanY = 0;
            
            // Set up event listeners for overlay canvas
            if (!overlayCanvas.dataset.listenersSetup) {
                setupCropCanvasListeners(overlayCanvas);
                overlayCanvas.dataset.listenersSetup = 'true';
            }
            
            drawCropBoxOnProcessed();
        }
        
        function drawCropBoxOnProcessed() {
            if (!cropperVisible) return;
            
            const overlayCanvas = document.getElementById('processed-crop-overlay');
            if (!overlayCanvas || overlayCanvas.style.display === 'none') return;
            
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas) return;
            
            const rect = processedCanvas.getBoundingClientRect();
            const imgDisplayWidth = rect.width || 400;
            const imgDisplayHeight = rect.height || 400;
            
            const ctx = overlayCanvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            
            // Clear canvas
            ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dpr, dpr);
            
            // Draw blue dotted border
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 3;
            ctx.setLineDash([8, 4]);
            ctx.lineDashOffset = 0;
            
            const maxX = Math.min(cropX + cropSize, imgDisplayWidth);
            const maxY = Math.min(cropY + cropSize, imgDisplayHeight);
            const clampedX = Math.max(0, Math.min(cropX, imgDisplayWidth));
            const clampedY = Math.max(0, Math.min(cropY, imgDisplayHeight));
            const clampedSizeX = Math.max(1, maxX - clampedX);
            const clampedSizeY = Math.max(1, maxY - clampedY);
            
            ctx.beginPath();
            ctx.rect(clampedX, clampedY, clampedSizeX, clampedSizeY);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function drawCropBox() {
            if (!cropperVisible) return;
            
            // Find the active crop canvas (size panel, crop panel, or regular)
            let cropCanvas = document.getElementById('size-panel-canvas');
            if (!cropCanvas || cropCanvas.style.display === 'none') {
                cropCanvas = document.getElementById('crop-panel-canvas');
            }
            if (!cropCanvas || cropCanvas.style.display === 'none') {
                cropCanvas = document.getElementById('crop-canvas');
            }
            if (!cropCanvas) return;
            
            // Use FIXED dimensions - always 400x400px when cropper is visible
            // This ensures the crop box always matches the fixed preview size
            const imgDisplayWidth = 400;
            const imgDisplayHeight = 400;
            
            const ctx = cropCanvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            
            // Clear canvas completely
            ctx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
            
            // Reset transform to identity first
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            // Scale to device pixel ratio for crisp rendering
            ctx.scale(dpr, dpr);
            
            // Draw blue dotted square border
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 3; // Make it slightly thicker to be more visible
            ctx.setLineDash([8, 4]); // Dash pattern: 8px dash, 4px gap
            ctx.lineDashOffset = 0;
            
            // Ensure crop coordinates are within bounds
            const maxX = Math.min(cropX + cropSize, imgDisplayWidth);
            const maxY = Math.min(cropY + cropSize, imgDisplayHeight);
            const clampedX = Math.max(0, Math.min(cropX, imgDisplayWidth));
            const clampedY = Math.max(0, Math.min(cropY, imgDisplayHeight));
            const clampedSizeX = Math.max(1, maxX - clampedX);
            const clampedSizeY = Math.max(1, maxY - clampedY);
            
            // Draw the rectangle
            ctx.beginPath();
            ctx.rect(clampedX, clampedY, clampedSizeX, clampedSizeY);
            ctx.stroke();
            
            // Reset line dash
            ctx.setLineDash([]);
            
            console.log('Drew crop box at:', clampedX, clampedY, clampedSizeX, clampedSizeY);
        }
        
        // Set up event listeners for any crop canvas (size panel, crop panel, or regular)
        function setupCropCanvasListeners(canvas) {
            if (!canvas) return;
            
            // Skip if listeners already set up
            if (canvas.dataset.listenersSetup === 'true') return;
            canvas.dataset.listenersSetup = 'true';
            
            // Helper function to get coordinates from event (works for both mouse and touch)
            function getEventCoords(e) {
                const rect = canvas.getBoundingClientRect();
                if (e.touches && e.touches.length > 0) {
                    return {
                        x: e.touches[0].clientX - rect.left,
                        y: e.touches[0].clientY - rect.top
                    };
                } else {
                    return {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                }
            }
            
            // Handle both mouse and touch events
            function handleStart(e) {
                e.preventDefault();
                if (!cropperVisible) return;
                
                const coords = getEventCoords(e);
                const mouseX = coords.x;
                const mouseY = coords.y;
                
                // Check if clicking on edge (for resize) or center (for drag)
                const edgeThreshold = 15;
                const onLeftEdge = Math.abs(mouseX - cropX) < edgeThreshold;
                const onRightEdge = Math.abs(mouseX - (cropX + cropSize)) < edgeThreshold;
                const onTopEdge = Math.abs(mouseY - cropY) < edgeThreshold;
                const onBottomEdge = Math.abs(mouseY - (cropY + cropSize)) < edgeThreshold;
                
                // Check corners first
                const onTopLeft = onTopEdge && onLeftEdge;
                const onTopRight = onTopEdge && onRightEdge;
                const onBottomLeft = onBottomEdge && onLeftEdge;
                const onBottomRight = onBottomEdge && onRightEdge;
                
                if (onTopLeft || onTopRight || onBottomLeft || onBottomRight) {
                    // Resize from corner
                    isResizingCrop = true;
                    if (onTopLeft) resizeEdge = 'topleft';
                    else if (onTopRight) resizeEdge = 'topright';
                    else if (onBottomLeft) resizeEdge = 'bottomleft';
                    else if (onBottomRight) resizeEdge = 'bottomright';
                    cropStartX = cropX;
                    cropStartY = cropY;
                    cropStartSize = cropSize;
                    dragStartX = mouseX;
                    dragStartY = mouseY;
                    canvas.style.cursor = 'nwse-resize';
                } else if (onLeftEdge || onRightEdge || onTopEdge || onBottomEdge) {
                    // Resize from edge
                    isResizingCrop = true;
                    if (onLeftEdge) resizeEdge = 'left';
                    else if (onRightEdge) resizeEdge = 'right';
                    else if (onTopEdge) resizeEdge = 'top';
                    else if (onBottomEdge) resizeEdge = 'bottom';
                    cropStartX = cropX;
                    cropStartY = cropY;
                    cropStartSize = cropSize;
                    dragStartX = mouseX;
                    dragStartY = mouseY;
                    canvas.style.cursor = onLeftEdge || onRightEdge ? 'ew-resize' : 'ns-resize';
                } else if (isPanningCropper) {
                    // Start panning
                    panStartX = mouseX;
                    panStartY = mouseY;
                } else if (mouseX >= cropX && mouseX <= cropX + cropSize &&
                          mouseY >= cropY && mouseY <= cropY + cropSize) {
                    // Drag from center (only if not panning)
                    isDraggingCrop = true;
                    dragStartX = mouseX - cropX * cropperZoom;
                    dragStartY = mouseY - cropY * cropperZoom;
                    canvas.style.cursor = 'move';
                }
            }
            
            canvas.addEventListener('mousedown', handleStart);
            canvas.addEventListener('touchstart', handleStart, { passive: false });
        }
        
        // Set up event listeners for crop-canvas using the unified function
        // This ensures consistent behavior across all crop canvases
        const cropCanvas = document.getElementById('crop-canvas');
        if (cropCanvas) {
            setupCropCanvasListeners(cropCanvas);
        }
        
        // Handle both mouse and touch move events
        function handleMove(e) {
            if (!cropperVisible && !isDraggingCrop && !isResizingCrop && !isPanningCropper) return;
            
            // Find the active crop canvas (size panel, crop panel, or regular)
            let cropCanvas = document.getElementById('size-panel-canvas');
            if (!cropCanvas || cropCanvas.style.display === 'none') {
                cropCanvas = document.getElementById('crop-panel-canvas');
            }
            if (!cropCanvas || cropCanvas.style.display === 'none') {
                cropCanvas = document.getElementById('crop-canvas');
            }
            if (!cropCanvas) return;
            
            const rect = cropCanvas.getBoundingClientRect();
            let mouseX, mouseY;
            if (e.touches && e.touches.length > 0) {
                mouseX = e.touches[0].clientX - rect.left;
                mouseY = e.touches[0].clientY - rect.top;
            } else {
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
            }
            
            if (isPanningCropper) {
                // Pan the cropper view
                const deltaX = mouseX - panStartX;
                const deltaY = mouseY - panStartY;
                cropperPanX += deltaX;
                cropperPanY += deltaY;
                panStartX = mouseX;
                panStartY = mouseY;
                updateCropperTransform();
            } else if (isDraggingCrop) {
                // Move crop box - need to convert mouse coordinates to image coordinates
                // Account for zoom/pan transform
                const canvasMouseX = mouseX / cropperZoom - cropperPanX / cropperZoom;
                const canvasMouseY = mouseY / cropperZoom - cropperPanY / cropperZoom;
                
                let newX = canvasMouseX - dragStartX;
                let newY = canvasMouseY - dragStartY;
                
                // Use FIXED dimensions - always 400x400px when cropper is visible
                const imgWidth = 400;
                const imgHeight = 400;
                
                newX = Math.max(0, Math.min(newX, imgWidth - cropSize));
                newY = Math.max(0, Math.min(newY, imgHeight - cropSize));
                
                // Snap to pixel grid
                const gridSize = selectedGridSize;
                const cellSize = imgWidth / gridSize;
                
                // Snap position to grid cell boundaries
                const cellX = Math.round(newX / cellSize);
                const cellY = Math.round(newY / cellSize);
                cropX = cellX * cellSize;
                cropY = cellY * cellSize;
                
                // Ensure it stays within bounds
                const maxCellX = Math.floor((imgWidth - cropSize) / cellSize);
                const maxCellY = Math.floor((imgHeight - cropSize) / cellSize);
                cropX = Math.max(0, Math.min(cropX, maxCellX * cellSize));
                cropY = Math.max(0, Math.min(cropY, maxCellY * cellSize));
                
                // Ensure final bounds check
                cropX = Math.max(0, Math.min(cropX, imgWidth - cropSize));
                cropY = Math.max(0, Math.min(cropY, imgHeight - cropSize));
                
                // Update the crop box visual position
                drawCropBox();
                
                // Update editor section in real-time as you drag (like the reference)
                applyCropFromBox(true);
            } else if (isResizingCrop) {
                // Resize crop box (keep square) based on which edge/corner
                // Use FIXED dimensions - always 400x400px when cropper is visible
                const imgWidth = 400;
                const imgHeight = 400;
                const gridSize = selectedGridSize;
                const cellSize = imgWidth / gridSize; // Each cell size in screen pixels
                
                // Calculate resize direction - fix inverted logic
                let deltaX = mouseX - dragStartX;
                let deltaY = mouseY - dragStartY;
                
                // For corners, use the dominant direction
                let delta = 0;
                if (resizeEdge.includes('left') && resizeEdge.includes('top')) {
                    // Top-left: dragging right/down = larger, left/up = smaller
                    delta = Math.max(-deltaX, -deltaY);
                } else if (resizeEdge.includes('right') && resizeEdge.includes('top')) {
                    // Top-right: dragging right/down = larger, left/up = smaller
                    delta = Math.max(deltaX, -deltaY);
                } else if (resizeEdge.includes('left') && resizeEdge.includes('bottom')) {
                    // Bottom-left: dragging right/down = larger, left/up = smaller
                    delta = Math.max(-deltaX, deltaY);
                } else if (resizeEdge.includes('right') && resizeEdge.includes('bottom')) {
                    // Bottom-right: dragging right/down = larger, left/up = smaller
                    delta = Math.max(deltaX, deltaY);
                } else if (resizeEdge === 'left') {
                    // Left edge: dragging right = larger, left = smaller
                    delta = -deltaX;
                } else if (resizeEdge === 'right') {
                    // Right edge: dragging right = larger, left = smaller
                    delta = deltaX;
                } else if (resizeEdge === 'top') {
                    // Top edge: dragging down = larger, up = smaller
                    delta = -deltaY;
                } else if (resizeEdge === 'bottom') {
                    // Bottom edge: dragging down = larger, up = smaller
                    delta = deltaY;
                }
                
                // Calculate new size (delta > 0 means larger, delta < 0 means smaller)
                let newSize = cropStartSize + delta;
                
                // Constrain size
                newSize = Math.max(cellSize, Math.min(newSize, imgWidth, imgHeight));
                
                // Snap size to grid cells (must be multiple of cellSize) - use precise calculation
                const numCells = Math.round(newSize / cellSize);
                newSize = Math.max(1, numCells) * cellSize;
                
                // Calculate new position based on which edge is being resized
                let newX = cropStartX;
                let newY = cropStartY;
                
                if (resizeEdge.includes('left')) {
                    newX = cropStartX + cropStartSize - newSize;
                    newX = Math.max(0, Math.min(newX, imgWidth - newSize));
                }
                if (resizeEdge.includes('top')) {
                    newY = cropStartY + cropStartSize - newSize;
                    newY = Math.max(0, Math.min(newY, imgHeight - newSize));
                }
                if (resizeEdge.includes('right')) {
                    newX = cropStartX;
                }
                if (resizeEdge.includes('bottom')) {
                    newY = cropStartY;
                }
                
                // Snap position to grid with better precision
                const cellX = Math.round(newX / cellSize);
                const cellY = Math.round(newY / cellSize);
                newX = cellX * cellSize;
                newY = cellY * cellSize;
                
                // Adjust size if needed after snapping position - with precise snapping
                if (resizeEdge.includes('left')) {
                    const actualX = Math.max(0, Math.min(newX, imgWidth - newSize));
                    let adjustedSize = cropStartX + cropStartSize - actualX;
                    const numCells2 = Math.round(adjustedSize / cellSize);
                    adjustedSize = Math.max(1, numCells2) * cellSize;
                    const adjustedX = cropStartX + cropStartSize - adjustedSize;
                    const cellX2 = Math.round(adjustedX / cellSize);
                    newX = cellX2 * cellSize;
                    newSize = cropStartX + cropStartSize - newX;
                    const numCells3 = Math.round(newSize / cellSize);
                    newSize = Math.max(1, numCells3) * cellSize;
                    newX = cropStartX + cropStartSize - newSize;
                    const cellX3 = Math.round(newX / cellSize);
                    newX = Math.max(0, Math.min(cellX3 * cellSize, imgWidth - newSize));
                }
                if (resizeEdge.includes('top')) {
                    const actualY = Math.max(0, Math.min(newY, imgHeight - newSize));
                    let adjustedSize = cropStartY + cropStartSize - actualY;
                    const numCells2 = Math.round(adjustedSize / cellSize);
                    adjustedSize = Math.max(1, numCells2) * cellSize;
                    const adjustedY = cropStartY + cropStartSize - adjustedSize;
                    const cellY2 = Math.round(adjustedY / cellSize);
                    newY = cellY2 * cellSize;
                    newSize = cropStartY + cropStartSize - newY;
                    const numCells3 = Math.round(newSize / cellSize);
                    newSize = Math.max(1, numCells3) * cellSize;
                    newY = cropStartY + cropStartSize - newSize;
                    const cellY3 = Math.round(newY / cellSize);
                    newY = Math.max(0, Math.min(cellY3 * cellSize, imgHeight - newSize));
                }
                
                // Final constraints with precise snapping
                newSize = Math.max(cellSize, Math.min(newSize, imgWidth - newX, imgHeight - newY));
                const finalNumCells = Math.round(newSize / cellSize);
                newSize = Math.max(1, finalNumCells) * cellSize;
                
                // Final position snap
                const finalCellX = Math.round(newX / cellSize);
                const finalCellY = Math.round(newY / cellSize);
                cropX = Math.max(0, Math.min(finalCellX * cellSize, imgWidth - newSize));
                cropY = Math.max(0, Math.min(finalCellY * cellSize, imgHeight - newSize));
                cropSize = newSize;
                
                // Update the crop box visual position
                drawCropBox();
                
                // Update editor section in real-time as you resize (like the reference)
                applyCropFromBox(true);
            } else if (cropperVisible) {
                // Update cursor when hovering
                const edgeThreshold = 15;
                const onLeftEdge = Math.abs(mouseX - cropX) < edgeThreshold;
                const onRightEdge = Math.abs(mouseX - (cropX + cropSize)) < edgeThreshold;
                const onTopEdge = Math.abs(mouseY - cropY) < edgeThreshold;
                const onBottomEdge = Math.abs(mouseY - (cropY + cropSize)) < edgeThreshold;
                
                if ((onTopEdge && onLeftEdge) || (onBottomEdge && onRightEdge)) {
                    cropCanvas.style.cursor = 'nwse-resize';
                } else if ((onTopEdge && onRightEdge) || (onBottomEdge && onLeftEdge)) {
                    cropCanvas.style.cursor = 'nesw-resize';
                } else if (onLeftEdge || onRightEdge) {
                    cropCanvas.style.cursor = 'ew-resize';
                } else if (onTopEdge || onBottomEdge) {
                    cropCanvas.style.cursor = 'ns-resize';
                } else if (mouseX >= cropX && mouseX <= cropX + cropSize &&
                          mouseY >= cropY && mouseY <= cropY + cropSize) {
                    cropCanvas.style.cursor = 'move';
                } else {
                    cropCanvas.style.cursor = 'default';
                }
            }
        }
        
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        
        function handleEnd(e) {
            if (e.type === 'touchend') {
                e.preventDefault();
            }
            if (isDraggingCrop || isResizingCrop) {
                // Redraw crop box
                drawCropBox();
                // Auto-apply crop when done dragging/resizing to update editor section
                setTimeout(() => {
                    applyCropFromBox(true);
                }, 50);
            }
            isDraggingCrop = false;
            isResizingCrop = false;
            isPanningCropper = false;
            resizeEdge = '';
            // Find the active crop canvas and update cursor
            let cropCanvas = document.getElementById('size-panel-canvas');
            if (!cropCanvas || cropCanvas.style.display === 'none') {
                cropCanvas = document.getElementById('crop-panel-canvas');
            }
            if (!cropCanvas || cropCanvas.style.display === 'none') {
                cropCanvas = document.getElementById('crop-canvas');
            }
            if (cropCanvas) {
                cropCanvas.style.cursor = isPanningCropper ? 'grab' : 'move';
            }
        }
        
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
        
        // Hide cropper and image preview
        function hideCropper() {
            // Just hide the cropper, don't apply any changes
            cropperVisible = false;
            cropperManuallyHidden = true; // Mark that user manually hid it
            isPanningCropper = false;
            document.getElementById('crop-canvas').style.display = 'none';
            document.getElementById('show-cropper-btn').style.display = 'block';
            document.getElementById('hide-cropper-btn').style.display = 'none';
            // Hide the entire preview section
            document.getElementById('png-preview').style.display = 'none';
        }
        
        // Cropper zoom/pan functions
        function cropperZoomIn() {
            cropperZoom = Math.min(cropperZoom * 1.5, 5.0);
            updateCropperTransform();
        }
        
        function cropperZoomOut() {
            cropperZoom = Math.max(cropperZoom / 1.5, 0.5);
            updateCropperTransform();
        }
        
        function cropperResetView() {
            cropperZoom = 1.0;
            cropperPanX = 0;
            cropperPanY = 0;
            updateCropperTransform();
        }
        
        function cropperTogglePan() {
            const btn = document.getElementById('cropper-pan-btn');
            const cropCanvas = document.getElementById('crop-canvas');
            if (isPanningCropper) {
                isPanningCropper = false;
                btn.style.background = 'white';
                if (cropCanvas) cropCanvas.style.cursor = 'move';
            } else {
                isPanningCropper = true;
                btn.style.background = '#e0e0e0';
                if (cropCanvas) cropCanvas.style.cursor = 'grab';
            }
        }
        
        function updateCropperTransform() {
            // Update preview image (could be png-preview-img or size-panel-img)
            let previewImg = document.getElementById('size-panel-img');
            if (!previewImg || previewImg.style.display === 'none') {
                previewImg = document.getElementById('png-preview-img');
            }
            if (previewImg) {
                const transform = `translate(${cropperPanX}px, ${cropperPanY}px) scale(${cropperZoom})`;
                previewImg.style.transform = transform;
            }
            
            // Also update crop canvas to match (could be size-panel-canvas, crop-panel-canvas, or crop-canvas)
            let cropCanvas = document.getElementById('size-panel-canvas');
            if (!cropCanvas || cropCanvas.style.display === 'none') {
                cropCanvas = document.getElementById('crop-panel-canvas');
            }
            if (!cropCanvas || cropCanvas.style.display === 'none') {
                cropCanvas = document.getElementById('crop-canvas');
            }
            if (cropCanvas) {
                const transform = `translate(${cropperPanX}px, ${cropperPanY}px) scale(${cropperZoom})`;
                cropCanvas.style.transform = transform;
            }
            
            // Redraw crop box with new transform
            drawCropBox();
        }
        
        function applyCropFromBox(skipVisibilityCheck = false) {
            // Only proceed if we have the full original image
            if (!fullOriginalImage) {
                // If no fullOriginalImage but we have rawUploadedImage, use that
                if (!rawUploadedImage || (!cropperVisible && !skipVisibilityCheck)) return;
            } else if (!cropperVisible && !skipVisibilityCheck) {
                return;
            }
            
            // IMPORTANT: While cropper is visible, we need to use the stored full processed image dimensions
            // NOT the cropper preview image dimensions (which might change)
            // Find the active preview image (size panel, crop panel, or regular)
            let previewImg = document.getElementById('size-panel-img');
            if (!previewImg || previewImg.style.display === 'none') {
                previewImg = document.getElementById('crop-panel-img');
            }
            if (!previewImg || previewImg.style.display === 'none') {
                previewImg = document.getElementById('png-preview-img');
            }
            if (!previewImg) return;
            
            // Use fullOriginalImage if available, otherwise fall back to rawUploadedImage
            const sourceImage = fullOriginalImage || rawUploadedImage;
            
            // If cropper is visible, use fixed dimensions based on fullProcessedImageDataURL
            // This prevents any changes to the cropper preview image
            let imgDisplayWidth, imgDisplayHeight;
            if (cropperVisible && fullProcessedImageDataURL) {
                // Use fixed dimensions - preview is always 400px max with aspect ratio 1:1
                imgDisplayWidth = 400;
                imgDisplayHeight = 400;
            } else {
                // Normal case: get dimensions from preview image
                const imgRect = previewImg.getBoundingClientRect();
                if (imgRect.width === 0 || imgRect.height === 0) return;
                imgDisplayWidth = imgRect.width;
                imgDisplayHeight = imgRect.height;
            }
            
            // Calculate scale from preview display size to actual image size
            const scale = sourceImage.width / imgDisplayWidth;
            
            // Check if crop covers the entire displayed image (within a small threshold)
            // Check in displayed coordinates first, before converting to source coordinates
            const threshold = 10; // pixels tolerance in displayed coordinates
            const coversFullWidth = Math.abs(cropX) < threshold && Math.abs(cropX + cropSize - imgDisplayWidth) < threshold;
            const coversFullHeight = Math.abs(cropY) < threshold && Math.abs(cropY + cropSize - imgDisplayHeight) < threshold;
            const isFullSize = Math.abs(cropSize - imgDisplayWidth) < threshold && Math.abs(cropSize - imgDisplayHeight) < threshold;
            
            // If crop covers the full displayed image, reset crop coordinates to null (no crop)
            if (coversFullWidth && coversFullHeight && isFullSize) {
                cropCoordinates = null;
            } else {
                // Calculate actual pixel coordinates in the full original image
                const x = cropX * scale;
                const y = cropY * scale;
                const size = cropSize * scale;
                
                // Snap to grid cells
                const gridSize = selectedGridSize;
                const cellSize = size / gridSize;
                const snappedSize = Math.floor(size / cellSize) * cellSize;
                
                // Ensure we have valid crop dimensions
                if (snappedSize <= 0 || x < 0 || y < 0 || x + snappedSize > sourceImage.width || y + snappedSize > sourceImage.height) {
                    return;
                }
                
                // Store crop coordinates for use in processImage
                // DO NOT modify rawUploadedImage - keep it as the full original always
                cropCoordinates = { x, y, size: snappedSize };
            }
            
            // IMPORTANT: Prevent fullProcessedImageDataURL from being overwritten during cropping
            const savedFullProcessedImageDataURL = fullProcessedImageDataURL;
            
            // Process image with current crop settings
            processImage();
            
            // Restore fullProcessedImageDataURL after processing
            fullProcessedImageDataURL = savedFullProcessedImageDataURL;
        }

        // Paint Functions
        function selectPaintColor(r, g, b, element) {
            selectedPaintColor = { r, g, b };
            // Update selected state
            document.querySelectorAll('.color-swatch').forEach(swatch => {
                swatch.classList.remove('selected');
            });
            element.classList.add('selected');
            console.log('Selected paint color:', selectedPaintColor);
        }

        function zoomInProcessed() {
            const processedCanvas = document.getElementById('processed-canvas');
            const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
            const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
            const panBtn = document.getElementById('processed-pan-btn');
            
            if (zoomMode === 'zoom-in') {
                // Deactivate zoom in mode
                zoomMode = null;
                if (processedCanvas) processedCanvas.style.cursor = 'crosshair';
                if (zoomInBtn) zoomInBtn.style.background = 'white';
            } else {
                // Activate zoom in mode
                zoomMode = 'zoom-in';
                isPanningProcessed = false;
                if (processedCanvas) processedCanvas.style.cursor = 'zoom-in';
                if (zoomInBtn) zoomInBtn.style.background = '#e0e0e0';
                if (zoomOutBtn) zoomOutBtn.style.background = 'white';
                if (panBtn) panBtn.style.background = 'white';
            }
        }

        function zoomOutProcessed() {
            const processedCanvas = document.getElementById('processed-canvas');
            const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
            const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
            const panBtn = document.getElementById('processed-pan-btn');
            
            if (zoomMode === 'zoom-out') {
                // Deactivate zoom out mode
                zoomMode = null;
                if (processedCanvas) processedCanvas.style.cursor = 'crosshair';
                if (zoomOutBtn) zoomOutBtn.style.background = 'white';
            } else {
                // Activate zoom out mode
                zoomMode = 'zoom-out';
                isPanningProcessed = false;
                if (processedCanvas) processedCanvas.style.cursor = 'zoom-out';
                if (zoomOutBtn) zoomOutBtn.style.background = '#e0e0e0';
                if (zoomInBtn) zoomInBtn.style.background = 'white';
                if (panBtn) panBtn.style.background = 'white';
            }
        }

        function resetZoomProcessed() {
            processedZoom = 1.0;
            processedZoomOffsetX = 0;
            processedZoomOffsetY = 0;
            zoomMode = null;
            isPanningProcessed = false;
            
            const processedCanvas = document.getElementById('processed-canvas');
            const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
            const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
            const panBtn = document.getElementById('processed-pan-btn');
            
            if (processedCanvas) processedCanvas.style.cursor = 'crosshair';
            if (zoomInBtn) zoomInBtn.style.background = 'white';
            if (zoomOutBtn) zoomOutBtn.style.background = 'white';
            if (panBtn) panBtn.style.background = 'white';
            
            redrawProcessedCanvas();
        }
        
        function togglePanProcessed() {
            const btn = document.getElementById('processed-pan-btn');
            const processedCanvas = document.getElementById('processed-canvas');
            const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
            const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
            
            if (isPanningProcessed) {
                isPanningProcessed = false;
                zoomMode = null;
                btn.style.background = 'white';
                if (processedCanvas) processedCanvas.style.cursor = 'crosshair';
            } else {
                isPanningProcessed = true;
                zoomMode = null;
                btn.style.background = '#e0e0e0';
                if (processedCanvas) processedCanvas.style.cursor = 'move'; // Use 'move' cursor for panning
                if (zoomInBtn) zoomInBtn.style.background = 'white';
                if (zoomOutBtn) zoomOutBtn.style.background = 'white';
            }
        }
        
        // Function to deactivate all zoom/pan modes
        function deactivateZoomPanModes() {
            zoomMode = null;
            isPanningProcessed = false;
            
            const processedCanvas = document.getElementById('processed-canvas');
            const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
            const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
            const panBtn = document.getElementById('processed-pan-btn');
            
            if (processedCanvas) processedCanvas.style.cursor = 'crosshair';
            if (zoomInBtn) zoomInBtn.style.background = 'white';
            if (zoomOutBtn) zoomOutBtn.style.background = 'white';
            if (panBtn) panBtn.style.background = 'white';
        }
        
        function zoomToPoint(x, y, zoomFactor) {
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas) return;
            
            const rect = processedCanvas.getBoundingClientRect();
            const w = processedCanvas.width;
            const h = processedCanvas.height;
            
            // Convert click position to canvas coordinates (absolute, not relative to center)
            const canvasX = x - rect.left;
            const canvasY = y - rect.top;
            
            // Calculate the point in image space that corresponds to this canvas click
            // In redrawProcessedCanvas, transforms are:
            // 1. translate(w/2, h/2) - center
            // 2. translate(offsetX, offsetY) - pan
            // 3. scale(zoom, zoom)
            // 4. draw at (-w/2, -h/2)
            // So: canvasX = imageX * zoom + offsetX + w/2
            // Therefore: imageX = (canvasX - w/2 - offsetX) / zoom
            const imageX = (canvasX - w/2 - processedZoomOffsetX) / processedZoom;
            const imageY = (canvasY - h/2 - processedZoomOffsetY) / processedZoom;
            
            // Calculate new zoom level
            // For zoom out, limit to minimum zoom that doesn't show whitespace (image should fill at least the canvas)
            const minZoom = 1.0; // Don't zoom out past original size
            const newZoom = zoomMode === 'zoom-in' 
                ? Math.min(processedZoom * zoomFactor, 10)
                : Math.max(processedZoom / zoomFactor, minZoom);
            
            // Calculate new offset so the clicked image point stays at the same canvas position
            // After zoom: canvasX = imageX * newZoom + newOffsetX + w/2
            // So: newOffsetX = canvasX - w/2 - imageX * newZoom
            const newOffsetX = canvasX - w/2 - imageX * newZoom;
            const newOffsetY = canvasY - h/2 - imageY * newZoom;
            
            // Constrain offsets to prevent showing whitespace
            constrainPanBounds(newZoom);
            
            // Update zoom and offset
            processedZoom = newZoom;
            processedZoomOffsetX = newOffsetX;
            processedZoomOffsetY = newOffsetY;
            
            // Apply bounds again after setting
            constrainPanBounds(processedZoom);
            
            redrawProcessedCanvas();
        }
        
        function constrainPanBounds(zoom) {
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas) return;
            
            const w = processedCanvas.width;
            const h = processedCanvas.height;
            
            // Calculate the maximum allowed offset to keep image within bounds
            // When zoomed, the image is scaled, so we need to prevent panning too far
            // Image is drawn at (-w/2, -h/2) with size (w, h) before transforms
            // After scale(zoom), the visible image size becomes w*zoom, h*zoom
            // We want to constrain so that image edges stay within canvas bounds
            
            // Maximum offset should keep the image edges visible
            // If zoom >= 1, we can pan more freely
            // If zoom < 1, we should limit panning to keep image centered
            if (zoom >= 1.0) {
                // When zoomed in, allow more panning
                const maxOffset = (w * zoom - w) / 2;
                processedZoomOffsetX = Math.max(-maxOffset, Math.min(maxOffset, processedZoomOffsetX));
                processedZoomOffsetY = Math.max(-maxOffset, Math.min(maxOffset, processedZoomOffsetY));
            } else {
                // When zoomed out, limit panning to keep image visible
                // At zoom 1.0, offset should be 0
                const maxOffset = w * (1 - zoom) / 2;
                processedZoomOffsetX = Math.max(-maxOffset, Math.min(maxOffset, processedZoomOffsetX));
                processedZoomOffsetY = Math.max(-maxOffset, Math.min(maxOffset, processedZoomOffsetY));
            }
        }

        function redrawProcessedCanvas() {
            if (!processedImageData) return;
            
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas) return;
            const processedCtx = processedCanvas.getContext('2d');
            const pixelSize = selectedGridSize;
            
            // Create temp canvas at pixel size with current data
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = pixelSize;
            tempCanvas.height = pixelSize;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(processedImageData, 0, 0);
            
            // Get display size (may be different from canvas internal size)
            const displayWidth = processedCanvas.width;
            const displayHeight = processedCanvas.height;
            
            // Clear and redraw with zoom
            processedCtx.clearRect(0, 0, displayWidth, displayHeight);
            
            if (processedZoom === 1.0 && processedZoomOffsetX === 0 && processedZoomOffsetY === 0) {
                // No zoom, just draw normally
                processedCtx.imageSmoothingEnabled = false;
                processedCtx.drawImage(tempCanvas, 0, 0, displayWidth, displayHeight);
            } else {
                // Draw with zoom and offset
                // The image is drawn centered, then scaled and translated
                processedCtx.save();
                // Translate to center, then apply offset, then scale
                processedCtx.translate(displayWidth / 2, displayHeight / 2);
                processedCtx.translate(processedZoomOffsetX, processedZoomOffsetY);
                processedCtx.scale(processedZoom, processedZoom);
                processedCtx.imageSmoothingEnabled = false;
                // Draw image centered at origin (before transforms)
                processedCtx.drawImage(tempCanvas, -displayWidth / 2, -displayHeight / 2, displayWidth, displayHeight);
                processedCtx.restore();
            }
        }

        // Paint pixel function with brush size support
        function paintPixelAt(clickX, clickY, processedCanvas) {
            if (!processedImageData) return false;
            
            const pixelSize = selectedGridSize;
            
            // Convert to pixel coordinates
            const pixelX = Math.floor((clickX / processedCanvas.width) * pixelSize);
            const pixelY = Math.floor((clickY / processedCanvas.height) * pixelSize);
            
            // Paint a brush area based on brush size
            // Brush size N paints an NxN square (N pixels wide, N pixels tall)
            // Size 1 = 1x1 (1 pixel), Size 2 = 2x2 (4 pixels), Size 3 = 3x3 (9 pixels), etc.
            let painted = false;
            
            // Calculate the start position (top-left corner of the square)
            // Center the brush on the click position
            const startX = pixelX - Math.floor(brushSize / 2);
            const startY = pixelY - Math.floor(brushSize / 2);
            
            // Paint all pixels in the NxN square
            for (let dy = 0; dy < brushSize; dy++) {
                for (let dx = 0; dx < brushSize; dx++) {
                    const x = startX + dx;
                    const y = startY + dy;
                    
                    // Ensure within bounds
                    if (x >= 0 && x < pixelSize && y >= 0 && y < pixelSize) {
                        // Update pixel color in image data
                        const index = (y * pixelSize + x) * 4;
                        processedImageData.data[index] = selectedPaintColor.r;     // R
                        processedImageData.data[index + 1] = selectedPaintColor.g; // G
                        processedImageData.data[index + 2] = selectedPaintColor.b; // B
                        processedImageData.data[index + 3] = 255;                  // A
                        painted = true;
                    }
                }
            }
            
            return painted;
        }

        // Add click and drag handlers to processed canvas for pixel painting
        let isPainting = false;
        
        // Set up paint event listeners (called after DOM loads and when canvas is recreated)
        function setupPaintHandlers() {
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas) return;
            
            // Use a flag to prevent duplicate listeners
            if (processedCanvas.dataset.paintHandlersSetup === 'true') return;
            processedCanvas.dataset.paintHandlersSetup = 'true';
            
            let isDraggingPan = false;
            
            processedCanvas.addEventListener('mousedown', (e) => {
                if (zoomMode === 'zoom-in') {
                    // Zoom in to the clicked point
                    zoomToPoint(e.clientX, e.clientY, 1.3);
                } else if (zoomMode === 'zoom-out') {
                    // Zoom out from the clicked point
                    zoomToPoint(e.clientX, e.clientY, 1.3);
                } else if (isPanningProcessed) {
                    // Start panning - store the initial mouse position and current offset
                    isDraggingPan = true;
                    processedPanStartX = e.clientX;
                    processedPanStartY = e.clientY;
                    const startOffsetX = processedZoomOffsetX;
                    const startOffsetY = processedZoomOffsetY;
                    
                    // Store start offsets in the event listener closure
                    processedCanvas.dataset.panStartOffsetX = startOffsetX;
                    processedCanvas.dataset.panStartOffsetY = startOffsetY;
                } else if (processedImageData && !isPanningProcessed && paintingEnabled) {
                    // Start painting (only if Paint panel is active and not in pan mode)
                    // Save state to undo stack before starting to paint
                    if (!isPainting) {
                        savePaintState();
                    }
                    isPainting = true;
                    const rect = processedCanvas.getBoundingClientRect();
                    
                    // Calculate click position in image space accounting for zoom and offset
                    // The image is drawn with transforms: translate(center) -> translate(offset) -> scale(zoom)
                    // So to reverse: get canvas coords, subtract center, subtract offset, divide by zoom
                    const canvasX = e.clientX - rect.left;
                    const canvasY = e.clientY - rect.top;
                    const w = processedCanvas.width;
                    const h = processedCanvas.height;
                    
                    // Convert to coordinates relative to center
                    const centerRelativeX = canvasX - w / 2;
                    const centerRelativeY = canvasY - h / 2;
                    
                    // Apply inverse transform: subtract offset, then divide by zoom
                    const imageSpaceX = (centerRelativeX - processedZoomOffsetX) / processedZoom;
                    const imageSpaceY = (centerRelativeY - processedZoomOffsetY) / processedZoom;
                    
                    // Convert to coordinates where image is drawn at (-w/2, -h/2) with size (w, h)
                    // So add w/2 and h/2 to get coordinates from 0 to w/h
                    const normalizedX = imageSpaceX + w / 2;
                    const normalizedY = imageSpaceY + h / 2;
                    
                    if (paintPixelAt(normalizedX, normalizedY, processedCanvas)) {
                        redrawProcessedCanvas();
                    }
                }
            });
        
            processedCanvas.addEventListener('mousemove', (e) => {
                if (isPanningProcessed && isDraggingPan) {
                    // Pan the view - calculate delta from start position
                    const deltaX = e.clientX - processedPanStartX;
                    const deltaY = e.clientY - processedPanStartY;
                    const startOffsetX = parseFloat(processedCanvas.dataset.panStartOffsetX || 0);
                    const startOffsetY = parseFloat(processedCanvas.dataset.panStartOffsetY || 0);
                    
                    // Update offset based on drag delta
                    processedZoomOffsetX = startOffsetX + deltaX;
                    processedZoomOffsetY = startOffsetY + deltaY;
                    
                    // Constrain to bounds
                    constrainPanBounds(processedZoom);
                    
                    redrawProcessedCanvas();
                } else if (isPainting && processedImageData && !isPanningProcessed && paintingEnabled) {
                    // Continue painting (only if not in pan mode)
                    const rect = processedCanvas.getBoundingClientRect();
                    
                    // Calculate position in image space accounting for zoom and offset
                    const canvasX = e.clientX - rect.left;
                    const canvasY = e.clientY - rect.top;
                    const w = processedCanvas.width;
                    const h = processedCanvas.height;
                    
                    // Convert to coordinates relative to center
                    const centerRelativeX = canvasX - w / 2;
                    const centerRelativeY = canvasY - h / 2;
                    
                    // Apply inverse transform: subtract offset, then divide by zoom
                    const imageSpaceX = (centerRelativeX - processedZoomOffsetX) / processedZoom;
                    const imageSpaceY = (centerRelativeY - processedZoomOffsetY) / processedZoom;
                    
                    // Convert to coordinates where image is drawn at (-w/2, -h/2) with size (w, h)
                    const normalizedX = imageSpaceX + w / 2;
                    const normalizedY = imageSpaceY + h / 2;
                    
                    if (paintPixelAt(normalizedX, normalizedY, processedCanvas)) {
                        redrawProcessedCanvas();
                    }
                }
            });
            
            processedCanvas.addEventListener('mouseup', () => {
                if (isPainting) {
                    // Paint stroke finished - update undo/redo buttons
                    updateUndoRedoButtons();
                }
                isPainting = false;
                isDraggingPan = false;
            });
            
            processedCanvas.addEventListener('mouseleave', () => {
                if (isPainting) {
                    // Paint stroke finished - update undo/redo buttons
                    updateUndoRedoButtons();
                }
                isPainting = false;
                isDraggingPan = false;
            });
        }
        
        // Call setup when page loads
        window.addEventListener('load', () => {
            setupPaintHandlers();
            
            // Deactivate zoom/pan modes when clicking outside the canvas or buttons
            document.addEventListener('click', (e) => {
                const processedCanvas = document.getElementById('processed-canvas');
                const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
                const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
                const panBtn = document.getElementById('processed-pan-btn');
                const resetBtn = document.querySelector('[onclick="resetZoomProcessed()"]');
                
                // Check if click is outside canvas and outside all zoom/pan buttons
                const isClickOnCanvas = processedCanvas && processedCanvas.contains(e.target);
                const isClickOnZoomIn = zoomInBtn && (zoomInBtn.contains(e.target) || zoomInBtn === e.target);
                const isClickOnZoomOut = zoomOutBtn && (zoomOutBtn.contains(e.target) || zoomOutBtn === e.target);
                const isClickOnPan = panBtn && (panBtn.contains(e.target) || panBtn === e.target);
                const isClickOnReset = resetBtn && (resetBtn.contains(e.target) || resetBtn === e.target);
                
                // If click is outside all these elements, deactivate modes
                if (!isClickOnCanvas && !isClickOnZoomIn && !isClickOnZoomOut && !isClickOnPan && !isClickOnReset) {
                    deactivateZoomPanModes();
                }
            });
        });

        // Brush size slider
        document.getElementById('brush-size-slider').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brush-size-value').textContent = brushSize;
        });

        // Reset processed image to original state
        function resetProcessedImage() {
            if (!originalProcessedImageData) {
                console.log('No original image data to reset to');
                return;
            }
            
            // Restore the original image data
            processedImageData = new ImageData(
                new Uint8ClampedArray(originalProcessedImageData.data),
                originalProcessedImageData.width,
                originalProcessedImageData.height
            );
            
            // Redraw the canvas
            redrawProcessedCanvas();
            
            // Clear undo/redo stacks on reset
            undoStack = [];
            redoStack = [];
            updateUndoRedoButtons();
            
            console.log('‚úÖ Image reset to original state');
        }

        // Save current paint state to undo stack
        function savePaintState() {
            if (!processedImageData) return;
            
            // Create a deep copy of the current image data
            const stateCopy = new ImageData(
                new Uint8ClampedArray(processedImageData.data),
                processedImageData.width,
                processedImageData.height
            );
            
            // Save to undo stack
            undoStack.push(stateCopy);
            
            // Clear redo stack when new paint happens
            redoStack = [];
            
            // Limit undo stack size to prevent memory issues (keep last 50 states)
            if (undoStack.length > 50) {
                undoStack.shift();
            }
            
            // Show undo/redo buttons
            document.getElementById('undo-redo-buttons').style.display = 'flex';
            updateUndoRedoButtons();
        }

        // Update undo/redo button states
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const undoRedoContainer = document.getElementById('undo-redo-buttons');
            
            if (!undoBtn || !redoBtn || !undoRedoContainer) return;
            
            if (undoStack.length === 0 && redoStack.length === 0) {
                // Hide buttons if no history
                undoRedoContainer.style.display = 'none';
            } else {
                // Show buttons if there's history
                undoRedoContainer.style.display = 'flex';
                undoBtn.disabled = undoStack.length === 0;
                redoBtn.disabled = redoStack.length === 0;
            }
        }

        // Undo last paint operation
        function undoPaint() {
            if (undoStack.length === 0 || !processedImageData) return;
            
            // Save current state to redo stack before undoing
            const currentState = new ImageData(
                new Uint8ClampedArray(processedImageData.data),
                processedImageData.width,
                processedImageData.height
            );
            redoStack.push(currentState);
            
            // Restore previous state from undo stack
            const previousState = undoStack.pop();
            processedImageData = new ImageData(
                new Uint8ClampedArray(previousState.data),
                previousState.width,
                previousState.height
            );
            
            // Redraw canvas
            redrawProcessedCanvas();
            
            // Update button states
            updateUndoRedoButtons();
        }

        // Redo last undone paint operation
        function redoPaint() {
            if (redoStack.length === 0 || !processedImageData) return;
            
            // Save current state to undo stack before redoing
            const currentState = new ImageData(
                new Uint8ClampedArray(processedImageData.data),
                processedImageData.width,
                processedImageData.height
            );
            undoStack.push(currentState);
            
            // Restore next state from redo stack
            const nextState = redoStack.pop();
            processedImageData = new ImageData(
                new Uint8ClampedArray(nextState.data),
                nextState.width,
                nextState.height
            );
            
            // Redraw canvas
            redrawProcessedCanvas();
            
            // Update button states
            updateUndoRedoButtons();
        }

        // Keyboard shortcuts for undo/redo
        document.addEventListener('keydown', (e) => {
            // Check if we're in the editor panel (painting is active)
            const editorPanel = document.getElementById('editor-panel');
            if (!editorPanel || editorPanel.style.display === 'none') return;
            
            // Check if user is typing in an input field (don't intercept)
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
                return;
            }
            
            // Cmd+Z (Mac) or Ctrl+Z (Windows/Linux) for undo
            if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undoPaint();
            }
            
            // Cmd+Shift+Z (Mac) or Ctrl+Y (Windows/Linux) for redo
            if ((e.metaKey && e.shiftKey && e.key === 'z') || (e.ctrlKey && e.key === 'y')) {
                e.preventDefault();
                redoPaint();
            }
        });

        // Slider event listeners
        document.getElementById('contrast-slider').addEventListener('input', (e) => {
            editorSettings.contrast = parseFloat(e.target.value);
            document.getElementById('contrast-value').textContent = e.target.value;
            processImage();
        });

        document.getElementById('brightness-slider').addEventListener('input', (e) => {
            editorSettings.brightness = parseFloat(e.target.value);
            document.getElementById('brightness-value').textContent = e.target.value;
            processImage();
        });

        document.getElementById('tones-slider').addEventListener('input', (e) => {
            editorSettings.tones = parseInt(e.target.value);
            document.getElementById('tones-value').textContent = `${editorSettings.tones}`;
            processImage();
        });

        // Initialize Three.js
        function initThree() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xfafafa);
            
            // Add lights to show geometry details and textures
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Soft overall lighting
            scene.add(ambientLight);
            
            // Main directional light from above-left
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(50, 100, 50);
            directionalLight1.castShadow = false;
            scene.add(directionalLight1);
            
            // Secondary directional light from opposite side for fill
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-50, 50, -50);
            directionalLight2.castShadow = false;
            scene.add(directionalLight2);

            // Camera
            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.set(100, 100, 100);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width || window.innerWidth, height || 600, true);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Grid
            const gridHelper = new THREE.GridHelper(200, 20, 0xcccccc, 0xe0e0e0);
            scene.add(gridHelper);

            // Animate
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            // Handle resize
            window.addEventListener('resize', () => {
                const w = container.clientWidth || window.innerWidth;
                const h = container.clientHeight || window.innerHeight - 200;
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h, true);
            });
        }

        // Auto tune contrast/brightness using percentile stretch (P5..P95)
        function autoTuneSettingsFromImage(img) {
            try {
                const tmp = document.createElement('canvas');
                const s = 128;
                tmp.width = s; tmp.height = s;
                const ctx = tmp.getContext('2d');
                ctx.drawImage(img, 0, 0, s, s);
                const d = ctx.getImageData(0, 0, s, s).data;
                const values = [];
                for (let i = 0; i < d.length; i += 4) {
                    values.push(0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2]);
                }
                values.sort((a,b)=>a-b);
                const q = (p)=> values[Math.max(0, Math.min(values.length-1, Math.floor(p*(values.length-1))))];
                const p5 = q(0.05);
                const p95 = q(0.95);
                editorSettings.blackPoint = Math.max(0, Math.min(254, Math.round(p5)));
                editorSettings.whitePoint = Math.max(editorSettings.blackPoint+1, Math.min(255, Math.round(p95)));
                // Keep C/B neutral post stretch
                editorSettings.contrast = 1.0;
                editorSettings.brightness = 1.0;
                saveSimpleState();
            } catch (e) {
                editorSettings.blackPoint = 0;
                editorSettings.whitePoint = 255;
                editorSettings.contrast = 1.0;
                editorSettings.brightness = 1.0;
            }
        }

        // Load STL file
        function loadSTL(file) {
            const reader = new FileReader();
            reader.onload = function(event) {
                const loader = new THREE.STLLoader();
                let geometry = loader.parse(event.target.result);

                // Ensure per-triangle unique vertices so colors don't bleed across shared vertices
                if (geometry.index) {
                    geometry = geometry.toNonIndexed();
                }

                // Store original geometry
                originalGeometry = geometry.clone();

                // Remove old mesh
                if (currentMesh) {
                    scene.remove(currentMesh);
                }

                // Create new mesh with lit material to show geometry details (bumps, cubes, textures)
                // Use MeshStandardMaterial for realistic lighting that shows surface details
                const material = new THREE.MeshStandardMaterial({
                    color: 0xffffff, // base white so vertex colors show true values
                    vertexColors: true, // Enable vertex colors for the painted image
                    side: THREE.DoubleSide,
                    flatShading: false, // Use smooth shading to show geometry details
                    metalness: 0.1, // Slight metalness for better detail visibility
                    roughness: 0.7 // Moderate roughness to catch light on surface details
                });
                currentMesh = new THREE.Mesh(geometry, material);

                // Center the mesh
                geometry.computeBoundingBox();
                const center = new THREE.Vector3();
                geometry.boundingBox.getCenter(center);
                currentMesh.position.sub(center);

                scene.add(currentMesh);

                // Hide placeholder
                document.getElementById('three-placeholder').style.display = 'none';

                // Fit camera
                const box = new THREE.Box3().setFromObject(currentMesh);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                camera.position.set(maxDim, maxDim, maxDim);
                controls.target.set(0, 0, 0);
                controls.update();

                // Apply colors if PNG is already loaded
                if (pngImage) {
                    applyColorsToMesh();
                }
            };
            reader.readAsArrayBuffer(file);
        }

        // Apply PNG colors to the 3D mesh
        function applyColorsToMesh() {
            if (!currentMesh || !pngImage || !originalGeometry) return;

            console.log('Applying colors to mesh...');

            const geometry = currentMesh.geometry;
            const positions = geometry.attributes.position;
            const vertices = [];
            
            // Get all vertices
            for (let i = 0; i < positions.count; i++) {
                vertices.push(new THREE.Vector3(
                    positions.getX(i),
                    positions.getY(i),
                    positions.getZ(i)
                ));
            }

            // Compute XY bounds based ONLY on near-horizontal (top) faces to avoid side thickness skew
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            const faceCount = positions.count / 3;
            for (let f = 0; f < faceCount; f++) {
                const a = f * 3, b = a + 1, c = a + 2;
                const v0 = vertices[a], v1 = vertices[b], v2 = vertices[c];
                // Face normal
                const abx = v1.x - v0.x, aby = v1.y - v0.y, abz = v1.z - v0.z;
                const acx = v2.x - v0.x, acy = v2.y - v0.y, acz = v2.z - v0.z;
                const nx = aby * acz - abz * acy;
                const ny = abz * acx - abx * acz;
                const nz = abx * acy - aby * acx;
                const len = Math.hypot(nx, ny, nz) || 1;
                const nzUnit = nz / len;
                if (nzUnit > 0.5) { // top-ish
                    minX = Math.min(minX, v0.x, v1.x, v2.x);
                    minY = Math.min(minY, v0.y, v1.y, v2.y);
                    maxX = Math.max(maxX, v0.x, v1.x, v2.x);
                    maxY = Math.max(maxY, v0.y, v1.y, v2.y);
                }
            }
            if (!isFinite(minX) || !isFinite(minY)) {
                // Fallback to bbox if no top faces detected
                geometry.computeBoundingBox();
                const bbox = geometry.boundingBox;
                minX = bbox.min.x; minY = bbox.min.y; maxX = bbox.max.x; maxY = bbox.max.y;
            }
            const sizeX = Math.max(1e-9, maxX - minX);
            const sizeY = Math.max(1e-9, maxY - minY);

            // Create canvas to read pixel data
            const canvas = document.createElement('canvas');
            canvas.width = pngImage.width;
            canvas.height = pngImage.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(pngImage, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            // Create color array for each face (triangle)
            const numFaces = positions.count / 3;
            const colors = new Float32Array(positions.count * 3);

            for (let faceIndex = 0; faceIndex < numFaces; faceIndex++) {
                const i0 = faceIndex * 3;
                const i1 = faceIndex * 3 + 1;
                const i2 = faceIndex * 3 + 2;

                // Get triangle centroid
                const v0 = vertices[i0];
                const v1 = vertices[i1];
                const v2 = vertices[i2];
                
                const cx = (v0.x + v1.x + v2.x) / 3;
                const cy = (v0.y + v1.y + v2.y) / 3;
                // Snap by selected grid cells to reduce tiny drift across adjacent triangles
                const u = Math.max(0, Math.min(0.999999, (cx - minX) / sizeX));
                const v = Math.max(0, Math.min(0.999999, (cy - minY) / sizeY));
                // Always use selectedGridSize, not pngImage width (which might be from a different size)
                const grid = selectedGridSize;
                const cellU = Math.floor(u * grid) + 0.5; // center of cell
                const cellV = Math.floor(v * grid) + 0.5;
                const snappedU = cellU / grid;
                const snappedV = cellV / grid;
                // Map to image coordinates
                const px = Math.floor(snappedU * (pngImage.width - 1));
                const py = Math.floor((1 - snappedV) * (pngImage.height - 1)); // Flip Y

                // Get pixel color
                const pixelIndex = (py * pngImage.width + px) * 4;
                const r = imageData.data[pixelIndex] / 255;
                const g = imageData.data[pixelIndex + 1] / 255;
                const b = imageData.data[pixelIndex + 2] / 255;

                // Apply color to all 3 vertices of this triangle
                for (let j = 0; j < 3; j++) {
                    const vertexIndex = (i0 + j) * 3;
                    colors[vertexIndex] = r;
                    colors[vertexIndex + 1] = g;
                    colors[vertexIndex + 2] = b;
                }
            }

            // Apply colors to geometry
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Update material to use vertex colors
            currentMesh.material.vertexColors = true;
            currentMesh.material.needsUpdate = true;
            // Keep smooth shading to show geometry details (bumps, cubes, textures)
            // The geometry itself has the detail - lighting will show it naturally
            if ('flatShading' in currentMesh.material) {
                currentMesh.material.flatShading = false; // Smooth shading shows surface details better
            }
            // Ensure normals are computed for proper lighting
            geometry.computeVertexNormals();
            geometry.attributes.color.needsUpdate = true;

            console.log('Colors applied successfully!');
        }

        function resetCamera() {
            if (currentMesh) {
                const box = new THREE.Box3().setFromObject(currentMesh);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                camera.position.set(maxDim, maxDim, maxDim);
                controls.target.set(0, 0, 0);
                controls.update();
            }
        }

        function toggleWireframe() {
            if (currentMesh) {
                currentMesh.material.wireframe = !currentMesh.material.wireframe;
            }
        }

        // File upload handlers
        // Load STL from server based on grid size (auto-load, no user upload)
        async function loadSTLFromServer(size) {
            try {
                console.log(`Loading STL for ${size}√ó${size} grid from server...`);
                const response = await fetch(`/get-stl/${size}`);
                if (!response.ok) {
                    // Try to get error message from response
                    let errorMessage = `Failed to load ${size}√ó${size} grid`;
                    try {
                        const errorData = await response.json();
                        if (errorData.error) {
                            errorMessage = errorData.error;
                            console.error(`Server error: ${errorData.error}`);
                        }
                    } catch (e) {
                        // If response isn't JSON, use status text
                        errorMessage = `Failed to load ${size}√ó${size} grid: ${response.statusText || 'File not found'}`;
                        console.error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    stlFile = null;
                    document.getElementById('stl-upload-area').classList.remove('has-file');
                    document.getElementById('stl-upload-text').textContent = errorMessage;
                    document.getElementById('stl-upload-subtext').textContent = `Click here to manually upload ${size}x${size}_grid.stl file`;
                    // Show STL upload section so user can manually upload
                    document.getElementById('stl-section').style.display = 'block';
                    
                    // Show status message to user
                    showStatus('error', `‚ùå ${errorMessage}. You can manually upload the STL file using the upload area below.`);
                    return;
                }
                const blob = await response.blob();
                
                // Verify blob is not empty
                if (blob.size === 0) {
                    throw new Error('Received empty STL file');
                }
                
                stlFile = new File([blob], `${size}x${size}_grid.stl`, { type: 'application/octet-stream' });
                document.getElementById('stl-upload-area').classList.add('has-file');
                document.getElementById('stl-upload-text').textContent = `${size}√ó${size} grid loaded`;
                document.getElementById('stl-upload-subtext').textContent = `${size}√ó${size} cube grid`;
                
                // Hide STL upload section when file loads successfully (optional - can keep visible for manual override)
                // document.getElementById('stl-section').style.display = 'none';
                
                // Save to IndexedDB for caching
                saveFileToDB(dbKey('stl', size), stlFile);
                
                loadSTL(stlFile);
                console.log(`‚úÖ Loaded STL for ${size}√ó${size} grid from server (${blob.size} bytes)`);
            } catch (error) {
                console.error('Error loading STL:', error);
                stlFile = null;
                document.getElementById('stl-upload-area').classList.remove('has-file');
                document.getElementById('stl-upload-text').textContent = `Error loading ${size}√ó${size} grid`;
                document.getElementById('stl-upload-subtext').textContent = `Click here to manually upload ${size}x${size}_grid.stl file`;
                // Show STL upload section so user can manually upload
                document.getElementById('stl-section').style.display = 'block';
                showStatus('error', `‚ùå Error loading STL file: ${error.message || 'Unknown error'}. You can manually upload the STL file using the upload area below.`);
            }
        }

        // STL file upload event listener
        document.getElementById('stl-input').addEventListener('change', (e) => {
            stlFile = e.target.files[0];
            if (stlFile) {
                document.getElementById('stl-upload-area').classList.add('has-file');
                document.getElementById('stl-upload-text').textContent = stlFile.name;
                loadSTL(stlFile);

                // Persist STL to IndexedDB for current grid size
                saveFileToDB(dbKey('stl', selectedGridSize), new File([stlFile], stlFile.name, { type: stlFile.type }));
            }
        });

        document.getElementById('png-input').addEventListener('change', async (e) => {
            pngFile = e.target.files[0];
            if (pngFile) {
                document.getElementById('png-upload-area').classList.add('has-file');
                document.getElementById('png-upload-text').textContent = pngFile.name;
                
                let fileToProcess = pngFile;
                
                // Check if file is HEIC/HEIF and convert it
                const fileExtension = pngFile.name.toLowerCase().split('.').pop();
                const isHeic = fileExtension === 'heic' || fileExtension === 'heif' || 
                               pngFile.type === 'image/heic' || pngFile.type === 'image/heif';
                
                if (isHeic && typeof heic2any !== 'undefined') {
                    try {
                        showStatus('loading', 'Converting HEIC image...');
                        // Convert HEIC to JPEG
                        const convertedBlob = await heic2any({
                            blob: pngFile,
                            toType: 'image/jpeg',
                            quality: 0.92
                        });
                        // heic2any returns an array, take the first element
                        const convertedFile = convertedBlob instanceof Array ? convertedBlob[0] : convertedBlob;
                        // Create a new File object with the converted blob
                        fileToProcess = new File([convertedFile], pngFile.name.replace(/\.(heic|heif)$/i, '.jpg'), { 
                            type: 'image/jpeg' 
                        });
                        showStatus('success', 'HEIC image converted successfully');
                    } catch (error) {
                        console.error('HEIC conversion error:', error);
                        showStatus('error', 'Failed to convert HEIC image. Please try a different format.');
                        return;
                    }
                }
                
                // Load image and show preview
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        rawUploadedImage = img; // Store raw image for editor (ALWAYS keep as full original)
                        fullOriginalImage = img; // Store full original uncropped image
                        cropCoordinates = null; // Reset crop coordinates when new image is uploaded
                        
                        // Reset cropper state when new image is uploaded
                        fullProcessedImageDataURL = null;
                        cropperVisible = false;
                        cropperManuallyHidden = false; // Reset flag for new image
                        cropInitialized = false;
                        const previewImg = document.getElementById('png-preview-img');
                        if (previewImg) {
                            previewImg.removeAttribute('data-cropper-fixed');
                        }
                        document.getElementById('png-preview').style.display = 'none';
                        document.getElementById('crop-canvas').style.display = 'none';
                        
                        // Auto-tune settings per new image
                        autoTuneSettingsFromImage(img);
                        // Update sliders/labels
                        document.getElementById('contrast-slider').value = String(editorSettings.contrast);
                        document.getElementById('brightness-slider').value = String(editorSettings.brightness);
                        document.getElementById('contrast-value').textContent = editorSettings.contrast.toFixed(1);
                        document.getElementById('brightness-value').textContent = editorSettings.brightness.toFixed(1);
                        // Don't set preview image here - it will be set to processed version after processImage() runs
                        // document.getElementById('png-preview-img').src = event.target.result;
                        // Hide upload area after image is uploaded
                        document.getElementById('png-upload-area').style.display = 'none';
                        
                        // On mobile, don't show png-preview initially - crop panel will show it
                        if (window.innerWidth > 1024) {
                            // Show image preview when image is uploaded (desktop only)
                            document.getElementById('png-preview').style.display = 'block';
                        } else {
                            // Hide png-preview on mobile - crop panel will handle showing the original image
                            document.getElementById('png-preview').style.display = 'none';
                        }
                        
                        // Show STL section and action buttons after image upload
                        document.getElementById('stl-section').style.display = 'block';
                        document.getElementById('action-buttons-section').style.display = 'flex';
                        
                        // Ensure editor is visible so user can adjust before mapping
                        showEditorPanel();
                        processImage();
                        
                        // On mobile, automatically show size panel with cropper after image is processed
                        if (window.innerWidth <= 1024) {
                            setTimeout(() => {
                                // Show size panel with original image and cropper
                                showMobilePanel('size');
                            }, 200);
                        } else {
                            // Desktop: Automatically show cropper after image is processed (with small delay to ensure processed canvas is ready)
                            // Only auto-show if user hasn't manually hidden it
                            if (!cropperManuallyHidden) {
                                setTimeout(() => {
                                    showCropper();
                                }, 100);
                            }
                        }

                        // Persist converted file to IndexedDB for current grid size
                        saveFileToDB(dbKey('png'), fileToProcess);
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(fileToProcess);
            }
        });


        // TEST: Add to Cart / Purchase button - Creates order without redirecting
        document.getElementById('add-to-cart-btn').addEventListener('click', async () => {
            if (!stlFile || !pngFile) {
                alert('Please upload both STL and PNG files first');
                return;
            }

            console.log('TEST: Creating order...');
            const btn = document.getElementById('add-to-cart-btn');
            btn.disabled = true;
            btn.textContent = 'Processing...';

            try {
                // Get the processed image from the canvas (matches what user sees)
                let processedPngFile = pngFile;
                const processedCanvas = document.getElementById('processed-canvas');
                if (processedCanvas && processedCanvas.width > 0) {
                    // Create a canvas at the exact grid size
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = selectedGridSize;
                    tempCanvas.height = selectedGridSize;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // Draw the processed canvas to the temp canvas at exact size
                    tempCtx.imageSmoothingEnabled = false;
                    tempCtx.drawImage(processedCanvas, 0, 0, selectedGridSize, selectedGridSize);
                    
                    // Convert to blob/file
                    tempCanvas.toBlob((blob) => {
                        if (blob) {
                            processedPngFile = new File([blob], 'processed.png', { type: 'image/png' });
                            sendOrderRequest(processedPngFile);
                        } else {
                            sendOrderRequest(pngFile); // Fallback to original
                        }
                    }, 'image/png');
                } else {
                    sendOrderRequest(pngFile);
                }
                
                async function sendOrderRequest(pngToSend) {
                    // Generate and upload file for checkout
                    const formData = new FormData();
                    formData.append('stl', stlFile);
                    formData.append('png', pngToSend);
                    formData.append('grid_size', String(selectedGridSize));
                    formData.append('stand_selected', String(standSelected));
                    formData.append('mounting_selected', String(selectedAddons.mounting));
                    
                    // Calculate total price
                    let totalPrice = 0;
                    if (prices && prices[`${selectedGridSize}x${selectedGridSize}`]) {
                        totalPrice += prices[`${selectedGridSize}x${selectedGridSize}`];
                    }
                    if (standSelected && prices && prices.stand) {
                        totalPrice += prices.stand;
                    }
                    if (selectedAddons.mounting && prices && prices.wall_mounting_dots) {
                        totalPrice += prices.wall_mounting_dots;
                    }
                    formData.append('total_price', String(totalPrice));

                    const response = await fetch('/upload-for-checkout', {
                        method: 'POST',
                        body: formData
                    });

                    if (!response.ok) {
                        const error = await response.json().catch(() => ({ error: 'Failed to create order' }));
                        throw new Error(error.error || 'Failed to create order');
                    }

                    const result = await response.json();
                    const orderId = result.order_id;
                    
                    console.log('TEST: Order created:', orderId);
                    alert(`‚úÖ TEST ORDER CREATED!\n\nOrder ID: ${orderId.substring(0, 8)}\nTotal: $${totalPrice.toFixed(2)}\n\nCheck the Admin Orders tab to see it!`);
                    
                    btn.textContent = 'ADD TO CART';
                    btn.disabled = false;
                }

            } catch (error) {
                console.error('TEST: Order creation error:', error);
                alert(`‚ùå Error: ${error.message}`);
                btn.textContent = 'ADD TO CART';
                btn.disabled = false;
            }
        });

        // Buy Now - Generate file and redirect to Shopify
        document.getElementById('buy-now-btn').addEventListener('click', async () => {
            if (!stlFile || !pngFile) return;

            console.log('Proceeding to checkout...');
            showStatus('loading', '<span class="spinner"></span>Preparing your order...');
            document.getElementById('buy-now-btn').disabled = true;

            try {
                // Get the processed image from the canvas (matches what user sees)
                let processedPngFile = pngFile;
                const processedCanvas = document.getElementById('processed-canvas');
                if (processedCanvas && processedCanvas.width > 0) {
                    // Create a canvas at the exact grid size
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = selectedGridSize;
                    tempCanvas.height = selectedGridSize;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // Draw the processed canvas to the temp canvas at exact size
                    tempCtx.imageSmoothingEnabled = false;
                    tempCtx.drawImage(processedCanvas, 0, 0, selectedGridSize, selectedGridSize);
                    
                    // Convert to blob/file
                    await new Promise((resolve) => {
                        tempCanvas.toBlob((blob) => {
                            if (blob) {
                                processedPngFile = new File([blob], 'processed.png', { type: 'image/png' });
                            }
                            resolve();
                        }, 'image/png');
                    });
                }
                
                // Generate and upload file for checkout
                const formData = new FormData();
                formData.append('stl', stlFile);
                formData.append('png', processedPngFile);
                formData.append('grid_size', String(selectedGridSize));
                formData.append('stand_selected', String(standSelected));
                formData.append('mounting_selected', String(selectedAddons.mounting));
                
                // Calculate total price
                let totalPrice = 0;
                if (prices && prices[`${selectedGridSize}x${selectedGridSize}`]) {
                    totalPrice += prices[`${selectedGridSize}x${selectedGridSize}`];
                }
                if (standSelected && prices && prices.stand) {
                    totalPrice += prices.stand;
                }
                if (selectedAddons.mounting && prices && prices.wall_mounting_dots) {
                    totalPrice += prices.wall_mounting_dots;
                }
                formData.append('total_price', String(totalPrice));

                const response = await fetch('/upload-for-checkout', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const error = await response.json().catch(() => ({ error: 'Failed to prepare order' }));
                    throw new Error(error.error || 'Failed to prepare order');
                }

                const result = await response.json();
                const orderId = result.order_id;
                
                console.log('Order ID:', orderId);
                
                // Redirect to Shopify with order ID as parameter
                const shopifyUrl = `${SHOPIFY_PRODUCT_URL}?order_id=${orderId}`;
                window.location.href = shopifyUrl;

            } catch (error) {
                console.error('Checkout error:', error);
                showStatus('error', `‚ùå Error: ${error.message}`);
                document.getElementById('buy-now-btn').disabled = false;
            }
        });

        function showStatus(type, message) {
            const statusMessage = document.getElementById('status-message');
            statusMessage.className = `status-message ${type}`;
            statusMessage.innerHTML = message;
            statusMessage.style.display = 'block';

            if (type === 'success') {
                setTimeout(() => {
                    statusMessage.style.display = 'none';
                }, 5000);
            }
        }

        // Initialize Three.js when page loads
        window.addEventListener('load', initThree);

        // Restore state and files on load; start with upload section visible (mobile)
        window.addEventListener('load', async () => {
            loadSimpleState();

            // Reflect selected grid size buttons
            document.querySelectorAll('.grid-btn').forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.dataset.size) === selectedGridSize) {
                    btn.classList.add('active');
                }
            });
            document.getElementById('png-upload-subtext').textContent = `Will be resized to ${selectedGridSize}√ó${selectedGridSize} pixels`;

            // Load prices from API
            await loadPrices();

            // Reset to initial state on mobile - don't restore images
            // Clear any uploaded image state
            document.getElementById('png-upload-area').style.display = 'flex';
            document.getElementById('png-upload-area').classList.remove('has-file');
            document.getElementById('png-upload-text').textContent = 'Upload an image to convert to brick art';
            document.getElementById('png-preview').style.display = 'none';
            document.getElementById('stl-section').style.display = 'none';
            document.getElementById('action-buttons-section').style.display = 'none';
            
            // Show main content elements
            document.querySelector('.info-box').style.display = 'block';
            document.querySelector('.title').style.display = 'block';
            
            // Hide all panels
            document.querySelectorAll('.mobile-panel').forEach(panel => {
                panel.style.display = 'none';
            });
            
            // Ensure viewer panel is hidden on mobile
            document.querySelector('.viewer-panel').classList.add('hidden-on-mobile');
            document.getElementById('editor-panel').style.display = 'none';
            document.getElementById('canvas-container').style.display = 'none';
            
            // Load STL for selected grid size (but don't show it until image is uploaded)
            await loadSTLFromServer(selectedGridSize);
            
            // Setup paint handlers after everything is loaded
            setTimeout(() => {
                setupPaintHandlers();
            }, 500);
        });
    </script>
</body>
</html>
